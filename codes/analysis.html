<!DOCTYPE html>
<html lang="en">
    <head>

		<link rel="shortcut icon" href="#">
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

        <title>Dimensionality Explorer for Single-Cell Analysis</title>
		<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
		<script src = "https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.1/Rx.min.js"></script>
		 <link rel="stylesheet" href="d3-context-menu.css" />
		 <link href="css/styles.css" rel="stylesheet" />
		<script src="clipper.js"></script>
		
		<style>
			body {
			  margin: 0;
			}

			

			.lasso path {
				stroke: rgb(80,80,80);
				stroke-width:2px;
			}

			.lasso .drawn {
				fill-opacity:.05 ;
			}

			.lasso .loop_close {
				fill:none;
				stroke-dasharray: 4,4;
			}

			.lasso .origin {
				fill:#3399FF;
				fill-opacity:.5;
			}

			.not_possible {
				fill: rgb(200,200,200);
			}

			.possible {
				fill: #EC888C;
			}

			.selected {
				fill: green;
			}
			
			.jb-large { font-size: large; }
			.jb-x-large { font-size: x-large; }
			.jb-xx-large { font-size: xx-large; }
			
			.texts { font-size: 15; }
			
			
			
			
			#playlist-wrapper ul li{
				height: 50px;
				overflow-y: hidden;
				overflow: auto;
				white-space: nowrap;
			}

			#playlist-wrapper{
				height: 150px;
				width:150px;
				overflow-y: hidden;
				overflow: auto;
				white-space: nowrap;
			}
			
			.outer {
			  display: flex; /* displays flex-items (children) inline */
			  overflow-x: auto;
			}
			
			input[type=range]::-webkit-slider-thumb { 
				-webkit-appearance: none; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
			
			}
				
			.slider::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 25px;
				height: 25px;
				border-radius: 50%;
				background: #4CAF50;
				cursor: pointer;
				
			}
			.slider {
				margin-top: 30px;
				margin-bottom: 30px;
				-webkit-appearance: none;
				width: 100%;
				height: 15px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			.loader {
			  border: 16px solid #f3f3f3; /* Light grey */
			  border-top: 16px solid #3498db; /* Blue */
			  border-radius: 50%;
			  width: 120px;
			  height: 120px;
			  animation: spin 2s linear infinite;
			}


			@keyframes spin {
			  0% { transform: rotate(0deg); }
			  100% { transform: rotate(360deg); }
			}
			
			
			
			input[type=range][orient=vertical]::-webkit-slider-thumb {
	
				
				-webkit-appearance: slider-vertical; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
				
			}
			
			
			
			
			
			input[type=range][orient=vertical]
			{
				
				-webkit-appearance: slider-vertical;
				width: 8px;
				height: 175px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			
			.slider_vertical::-webkit-slider-thumb {

				
				-webkit-appearance: none; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
				
			}
			.slider_vertical {
			
			
				-webkit-transform: rotate(270deg);
				-moz-transform: rotate(270deg);
				-o-transform: rotate(270deg);
				-ms-transform: rotate(270deg);
				transform: rotate(270deg)
	
				margin-left: 30px;
				margin-right: 30px;
				-webkit-appearance: none;
				width: 175px;
				height: 8px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			
			.slider_hist {
			  -webkit-appearance: none;
		
			  outline: none;
		
			}

			.slider_hist:hover {
			  opacity: 1;
			}

			.slider_hist::-webkit-slider-thumb {
			  -webkit-appearance: none;
			  appearance: none;
		
			  cursor: pointer;
			}

			.slider_hist::-moz-range-thumb {
		
			  cursor: pointer;
			}
			
			input {
			  box-sizing: border-box;
			}

			.progress {
				position:relative;
				width:400px;
				border: 1px solid #ddd;
				padding: 1px;
				border-radius: 3px;
			}
			.bar {
				background-color: #B4F5B4; 
				width:0%;
				height:20px; 
				border-radius: 3px;
			}
			.percent { 
				position:absolute; 
				display:inline-block; 
				top:3px; 
				left:48%; 
			}
			#set_center {
				display:flex;
				justify-content: center;
				align-items: center;
			}

			
		</style>
    </head>
    <body class="sb-nav-fixed">
        <nav class="sb-topnav navbar navbar-expand navbar-dark bg-dark">

            <a class="navbar-brand ps-3" href="index.html"> <img src="figures/logo2.png" style="max-width: 20%; height: auto;"> Dimensionality Explorer for Single-Cell Analysis</a>

        </nav>
        <div id="layoutSidenav">
            <div id="layoutSidenav_nav">
                <nav class="sb-sidenav accordion sb-sidenav-dark" id="sidenavAccordion">
                    <div class="sb-sidenav-menu">
                        <div class="nav">
                          
                            <a class="nav-link" href="analysis.html">
                                <div class="sb-nav-link-icon"><i class="fas fa-table"></i></div>
                                Analysis
                            </a>
                        </div>
                    </div>
      
                </nav>
            </div>
      
            
			<div id="layoutSidenav_content">
				<main>
					<div class="container-fluid">

						<div class="row">		
                            <div class="col-xl-4">
									<ol class="breadcrumb mb-4">
										<li class="texts">P: <input id="participant" class="texts" type="text" size = "30" ></li>
									</ol>
						
							</div>
                            
                            <div class="col-xl-4">
									<ol class="breadcrumb mb-4">
										<li class="texts">RDS file: <input id="rds" class="texts" type="text" size = "30" value="pbmc.rds"></li>
									</ol>
						
							</div>
							<div class="col-xl-4">
								<ol class="breadcrumb mb-4">	
									<li class="texts">The first dimension: <input id="fd" class="texts" type="number" min="2" max="49" style="margin-right: 10px" value="2"></li>
									<li class="texts">The last dimension: <input id="ld" class="texts" type="number" min="3" max="50" value="30"></li>
								</ol>
							</div>	
                        
		
						</div>
						<div class="row">							
																				
				
							<div class="col-xl-12">
								<ol class="breadcrumb mb-4">
									<div class="row">
										<input type = "text" id = "added_markers" class="texts" size = "100" style = "margin-right: 1px" value="IL7R CCR7 CD14 LYZ IL7R S100A4 MS4A1 CD8A FCGR3A MS4A7 GNLY NKG7 FCER1A CST3 PPBP"/>
									</div>
									<div class="row">
										<input id="add_button" class="texts" value="Add markers" type="button" style = "margin-right: 1px"/>
										<input id="remove_button" class="texts" value="Remove markers" type="button" style = "margin-right: 1px" />
										<input id="add_groups_button" class="texts" value="Add groups" type="button" style = "margin-right: 1px" />
										<input id="remove_groups_button" class="texts" value="Remove groups" type="button"  />
                                        <input id="save_labels_button" class="texts" value="Save labels" type="button"  />
														</div>
									
								</ol>
							</div>
						
						</div>
							
							
						
						
						<div class="card mb-4" style="block: none" id="card_heatmap">
							<div class="card-header texts">Hull Heatmap</div>
							<div class="card-body">

								<div class="outer">
										<div id="heatmap"></div>
								</div>

							</div>
						</div>
						
						
						
						
						
						<div class="row">
							<div class="col-xl-3" >								
								<div class="card mb-4" style="block: none" id="card_cluster_plot">
									<div class="card-header texts">Cluster Plot</div>
									<div class="card-body" >
										<div id="clustering"></div>									
									</div>
								</div>	
                                <div class="card mb-4" style="block: none" id="upldated_cluster_plot">
									<div class="card-header texts">Updated Cluster Plot</div>
									<div class="card-body" >
										<div id="updated_clustering"></div>									
									</div>
								</div>   
       
                                
						
											<input id ="slider" class="slider" type="range" style="display:none"></input>
										
							</div>
							<div class="col-xl-8" >
								<div class="card mb-4" style="block: none" id="card_meps">
									<div class="card-header texts">Marker Expression Plots</div>
									<div class="card-body">
										<div id="marker_plots"></div>
									</div>
								</div>
							</div>
							<div class="col-xl-1 texts" >
							
								<div class="row">
									<div class="card mb-4" style="block: none" id="card_plot_size">
										<div class="card-header texts" id="plot_size_value" ></div>
										<div class="card-body" id = "vsb">
											<div class="row">
												<style data="test_vertical" type="text/css"></style>
															<input id="plot_size_slider" type="range" class="slider_vertical" value="5" min="1" max="10" style="margin-top:0px;"/>
											</div>
										</div>
											</div>
								</div>
							</div>
					
						</div>

						
					</div>
				</main>
			  
			</div>
		
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
        <script src="js/scripts.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js" crossorigin="anonymous"></script>
  
        <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" crossorigin="anonymous"></script>

		
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" crossorigin="anonymous"></script>
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.form/4.2.2/jquery.form.min.js"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
		
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
   
        <script src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js" crossorigin="anonymous"></script>
        <script src="https://cdn.datatables.net/1.10.20/js/dataTables.bootstrap4.min.js" crossorigin="anonymous"></script>
 	
		<script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js" charset="utf-8"></script>

		<script src="https://d3js.org/d3.v5.min.js"></script>
		<script src="https://unpkg.com/d3-simple-slider"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>
		<script src="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js"></script>
		<script src="d3-lasso.min.js"></script>
		<script src="KMEANS.js"></script>
		<script src="DBSCAN.js"></script>
		<script src="papaparse.min.js"></script>
		<script src="https://darshit-shah.github.io/d3.floatingScale.js"></script>

		<link
		  rel="stylesheet"
		  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
		  integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
		  crossorigin="anonymous"
		/>
		
		<script>
			$(function() {

			var progressbar = $("#progressbar");
			var progressLabel = $(".progress-label");
			progressbar.progressbar({
				value: true,
				change: function() {
					progressLabel.text("Current Progress: " + progressbar.progressbar("value") + "%");
				},
				complete: function() {
					progressLabel.text("Complete!");
					$(".ui-dialog button").last().trigger("focus");
				}
			});
			
			$('form').ajaxForm({
				url: "1.php", 
				type: "POST", 
				beforeSubmit: function(arr, $form, options) {
				
					progressbar.progressbar( "value", 0 );
				},
				uploadProgress: function(event, position, total, percentComplete) {
		
					progressbar.progressbar( "value", percentComplete );
				},
				success: function(text, status, xhr, element) {
			
					progressbar.progressbar( "value", 100 );
				}
			});
			});

		</script>
	
	

		<script type="x-shader/x-vertex" id="vertexshader">

		  attribute float size;
		  uniform float pointSize;
		  uniform vec3 color;
		  uniform float alpha;
		  varying vec4 vColor;
		  varying vec2 myPosition;
		  varying float mySize;
		  uniform sampler2D vertices;
		  attribute float id;
		  uniform int tw;
		  uniform int th;
		  uniform float ratio;
		  uniform float interval;
		  uniform int cur_dim;
		  uniform int n_dims;
		  varying float x2;
		  varying float y2;
		  varying float id2;
		  uniform int nrow;
		  uniform int ndots;		
		  uniform sampler2D marker;
		  uniform int max_ncircles;
		  uniform vec3 total_ncircles;
		  uniform int mw;
		  uniform int mh;
		  uniform float cell_size;
		  uniform int mae;
          uniform sampler2D expression;
          uniform int eh;
          varying float exp;
		  void main() {
			
			vec4 pos3;
		   
			if (int(id) < nrow)
			{
				
				int v1 = th - 1 - int(id)/4;
				float v_final1 = float(v1)/float(th) + 1.0/(2.0*float(th));
				
				int u1 = int(id) - (int(id)/4)*4;
				int u2 = (n_dims*2*u1+cur_dim*2) / 4;
				float u_final1 = float(u2)/float(tw) + 1.0/(2.0*float(tw));
				
				int rgba = (n_dims*2*u1+cur_dim*2) - ((n_dims*2*u1+cur_dim*2)/4)*4;
				
	
				
	
				
				vec2 pos1, pos2;
				
				if (rgba==0)
				{			
					pos1 = texture2D(vertices, vec2(u_final1, v_final1)).rg;
					pos2 = texture2D(vertices, vec2(u_final1, v_final1)).ba;
					
					
				}
				else if (rgba==2)
				{	
					pos1 = texture2D(vertices, vec2(u_final1, v_final1)).ba;
					
					
					
					if (u2==(tw-1))
					{
						int v2 = th - 1 - (int(id)+1)/4;
						float v_final2 = float(v2)/float(th) + 1.0/(2.0*float(th));
						
						float u_final2 = 1.0/(2.0*float(tw));
						
						pos2 = texture2D(vertices, vec2(u_final2, v_final2)).rg;
					}
				
					else
					{	
						float u_final2 = float(u2+1)/float(tw) + 1.0/(2.0*float(tw));
						
						pos2 = texture2D(vertices, vec2(u_final2, v_final1)).rg;				
					}
				}
                
                
                
                int v = eh - 1 - int(id)/4;
                float v_final = float(v)/float(eh) + 1.0/(2.0*float(eh));
   
                int rgba_e = int(id) - (int(id)/4)*4;
                
           
                
                if (rgba_e==0)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).r;
                }
                else if (rgba_e==1)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).g;
                }
                else if (rgba_e==2)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).b;
                }
                else if (rgba_e==3)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).a;
                }
                
				

				float x = (pos1.x*ratio + pos2.x*(interval-ratio))/interval;
				float y = (pos1.y*ratio + pos2.y*(interval-ratio))/interval;
				

				
				
				// pos3 = vec4(x, y, 0.0, 1.0);
                pos3 = vec4(x, y, exp, 1.0);
				
				id2 = id;
	
				
				
				gl_PointSize = cell_size*2.0;
			}
			
	
			
			else if ((int(id) < (nrow+ndots)) && (mae==1))
			{	
				int cur_dot = int(id) - nrow;
				
				
				
				
				
				int u = cur_dot/2;
				float u_final = float(u)/float(mw) + 1.0/(2.0*float(mw));
				
				int u_rgba = cur_dot - (cur_dot/2)*2;
				
				
				
				
				
				
				int v_pre = mh - 1 - cur_dim;
				float v_final_pre = float(v_pre)/float(mh) + 1.0/(2.0*float(mh));
				
				int v_next = mh - 2 - cur_dim;
				float v_final_next = float(v_next)/float(mh) + 1.0/(2.0*float(mh));
				
				
				
				
				vec2 pos_pre, pos_next;
				
				
				if (u_rgba==0)
				{
					pos_pre = texture2D(marker, vec2(u_final, v_final_pre)).rg;
					pos_next = texture2D(marker, vec2(u_final, v_final_next)).rg;
				}
				
				else
				{
					pos_pre = texture2D(marker, vec2(u_final, v_final_pre)).ba;
					pos_next = texture2D(marker, vec2(u_final, v_final_next)).ba;
				}
				
				
				
				
				float x = (pos_pre.x*ratio + pos_next.x*(interval-ratio))/interval;
				float y = (pos_pre.y*ratio + pos_next.y*(interval-ratio))/interval;
				
				
				// pos3 = vec4(x, y, 0.0, 1.0);
                pos3 = vec4(x, y, 999.0, 1.0);
				
				
				
			 
				id2 = id;
		
				
			
				exp = 0.0;
				
				gl_PointSize = cell_size*3.0;
			}
			
			else
			{
				pos3 = vec4(0.0, 0.0, 0.0, 0.0);
                
                
                id2 = id;
                
                exp = 0.0;
			}
			
			
			vec4 mvPosition = modelViewMatrix * pos3;			
			mySize = size; 
			gl_Position = projectionMatrix * mvPosition;
			vColor = vec4(color, alpha);
			
			
			
		}
		</script>

		
		
		
		<script type="x-shader/x-fragment" id="fragmentshader">
		  varying vec4 vColor;
		  varying vec2 myPosition;
		  varying float mySize;
		  varying float x2;
		  varying float y2;
		  varying float id2;
		  uniform int th;
		  uniform int nrow;
		  uniform float e_max;
          uniform float e_min;
		  uniform int ew;
		  uniform int eh;
		  uniform sampler2D expression;
		  uniform int mae;
		  uniform int ndots;
          varying float exp;
		  
		  void main() {
			

		   
			float id3 = id2;
			
			
			
			vec4 point_color = vec4(0.0, 0.0, 1.0, 1.0);
			
			vec4 base_color = vec4(1.0, 1.0, 1.0, 1.0);
			
			if (int(id3) < nrow)
			{
				if (mae==1)
				{
				

					
					
                    float ratio = (exp-e_min) / (e_max-e_min);
            
                    gl_FragColor = ratio*point_color + (1.0 - ratio)*base_color;
					
			
				}
				
				else
				{
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
				}
				
			}
			
			
			
			
			else if ((int(id3) < (nrow+ndots)) && (mae==1))
			{
				gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
			}
			
			else
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			


		  }
		</script>

		<script>

		var plot_data, gene_data, gene_data2, dataTex, tw, th, ratio, interval, cur_dim, n_dims, uniforms, 
			tex_data, nrow, ncol, test_data, id, expression, exTex, e_max, e_min, circle1, selected_genes, genes_th,
			gene_exp_no, cur_circles_num, circles_vnum, clusters_num, cw, clustersTex, clusters_num2, ctn,
			ex_bars, ex_bar1, ex_bar2, th_cells, rgbs, point_color, base_color, svg, sm_data2, ndots, max_ncircles,
			ncircles, smw, smh, smTex, ncirclesTex, ncw, sm_tex_data, nc, nci, nci_array, par_dim, cndc, xy, xyc, svg2,
			pdi, dims_check, smaller, start_dim, x, eps, minPts, pps, margin, x2, xy_json, jsonData, jsstring,
			xy_json2, max_eps, max_minPts, lassos, lasso0, lasso1, selected, selected2, cdata, max_iter, cpn, sdn,
			slider_change, first_pause, marker_count, can_list, can_data2, can_list2, max_markers, total_ncircles,
			marker_tex_data, mw, mh, markerTex, dom, rm_id, svg_width, marker_tex_data_temp, draw_time, draw_time2, 
			ani_time, ani_time2, marker_time, marker_time2, dr_y, added_markers_list, added_markers, markers, new_markers, markers_string,
			dims_cells_data, dbscan_data2, heatmap_genes, heatmap_groups, heatmap_data, csv_lines, groups, markers_on, selected_dim,
			cur_groups, cur_markers, old_markers, dbscan_data, clusterings, expressions, circles, mpn, dim_id, markers_ani,
			added_markers_ani, new_markers_ani, old_markers_ani, cur_markers_ani, fd_num, ld_num, animations, svg_expression, ep, console_test,
			ep_array, ep_svgs, ep_dots, ep_lassos, lasso_func, max_ep, lasso_gene, groups_markers, new_group, old_group, group_name, intersect,
			lasso_groups, groups_params, heatmap_circles, total_heatmap_circles, hc_scale_x, hc_scale_y, rec_size, cl, mp_ranges, others, canvas, gl, ext, svgs,
			others2, others2_index, menu_size, space_size, text_size, menu_width, menu_height, menu_svgs, test_console, added_degs,
			colorDomains, colorScales, renderer, scene, camera, rma_list, rec_width, rec_height, plot_size, ani_size, 
			ortho_size, font_size, margin_size, font_size_str, outer_width, heatmap_width, heatmap_circles_x, y_length, hct,
			tooltip, mouseover, mousemove, mouseleave, heatmap_margin, legend_size, clustering_width, cell_size, selected_index,
			selected_gene, slider_height, shs, state, deg_test, dcx, dcy, border_size, lasso_temp, ep_size, ep_cell_size, rds_name,
			rds_name_only, unit_height, deg_others, ew, eh, ex_tex_data, mae, am, rem, dcm, ccm, rsm, total_expressions, cl_test,
			ex_colors, lasso_test, develop, num_bins, hist_test, hist_margin, lasso_temp_test, hist_x_test, selected_ex, bins, bins_ids,
			bins_range, hist_th, area_test, areas, cat_test, dim_cells_results, genes_stride, cell_ids, dims_stride, selected_string_test,
			reponse_test, total_markers, histo_ex, ex_maxs, ex_mins, dec, filtering_on, density_on, density_colors, filtering_size, x_filtering, tml,
			final_selected, hulls, lines, line, svg_ani, path_ani, new_marker_ani, cur_marker_ani, old_marker_ani, intersect_tf, sorted_indices,
			reverse_sorted_indices, selected_density, density_indices, density_values, sorted_density_colors, largest_dim, selected_cp,
			lasso_cp, cp_window_tf, filtered_ids, density_th, density_test, density_min_test, density_max_test, color_scale_test, legend_click_test,
            filtered_ids_test, density_string_test, ids_test, density_test, valid_groups_test, lasso_cells, dom_arr, overlap_groups, areas_ratio,
			path_diff, path_inter, areas_marker, paths, inter_groups, group_colors, cur_color_id, total, temp_cell_ids, ones, hulls_mean,
			path_diff_dom, path_inter_dom, hulls_dom, row_sizes, labels, means, gt, gt_string, pos_in_hulls, labels_in_hulls, cur_mep_select, pca, timeString, first_update_clu;
			
		var run_status = false;
		var ani_status = false;	
		var pause_status = true;
		var first_time = true;
		var first_add = true;
		var first_plots = true;
		var first_ani = true;
		var first_mp = true;
		var rds_exist = false;

		var t = 0;


	
		$(document).ready(function(){
			d3.select("#card_heatmap").style("display", "none");
			d3.select("#card_cluster_plot").style("display", "none");
			d3.select("#card_meps").style("display", "none");
			d3.select("#card_plot_size").style("display", "none");
			d3.select("#card_animation").style("display", "none");
		});
	
        $(document).ready(function(){
			$("#start").click(function(){
                

                d3.select("#start")["_groups"][0][0].style.color = "red";

                console.time("Total time: ");
               
            });
        });
        
        
        $(document).ready(function(){
			$("#finish").click(function(){
                
 
                
                console.timeEnd("Total time: ");
                
                d3.select("#finish")["_groups"][0][0].style.color = "red";
            });
        });
        
        
		
		function debounce(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) func.apply(context, args);
			};
		};
		
		
		$(function() {
			$range = $('#plot_size_slider');
			$display = $('#plot_size_value');

			document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;

			
			$range.on('change', debounce(function() {
				
				
				ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
				ep_cell_size = ep_size*0.002;

				
				
				
				if (!first_mp)
				{
					rsm = new Array();
					
					
					
					
					for (var i=0; i<groups.length; i++)
					{
						rsm[rsm.length] = groups[i];
					}
					
					for (var i=0; i<markers.length; i++)
					{
						rsm[rsm.length] = markers[i];
					}
					
					draw_markers_plots();
				}
				
			
				document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;
			}, 250));
		});
		
		
		
		
		
		function polygonClosed(points) {
		  const [ax, ay] = points[0], [bx, by] = points[points.length - 1];
		  return ax === bx && ay === by;
		}
		
		function lineIntersect([ax, ay], [bx, by], [cx, cy], [dx, dy]) {
		  const bax = bx - ax, bay = by - ay, dcx = dx - cx, dcy = dy - cy;
		  const k = (bax * (cy - ay) - bay * (cx - ax)) / (bay * dcx - bax * dcy);
		  return [cx + k * dcx, cy + k * dcy];
		}
		
		function lineOrient([px, py], [ax, ay], [bx, by]) {
		  return (bx - ax) * (py - ay) < (by - ay) * (px - ax);
		}
		
		
		function polygonClip(clip, subject) {
		  const closed = polygonClosed(subject);
		  const n = clip.length - polygonClosed(clip);
		  subject = subject.slice();
		  for (let i = 0, a = clip[n - 1], b, c, d; i < n; ++i) {
			const input = subject.slice();
			const m = input.length - closed;
			subject.length = 0;
			b = clip[i];
			c = input[m - 1];
			for (let j = 0; j < m; ++j) {
			  d = input[j];
			  if (lineOrient(d, a, b)) {
				if (!lineOrient(c, a, b)) {
				  subject.push(lineIntersect(c, d, a, b));
				}
				subject.push(d);
			  } else if (lineOrient(c, a, b)) {
				subject.push(lineIntersect(c, d, a, b));
			  }
			  c = d;
			}
			if (closed) subject.push(subject[0]);
			a = b;
		  }
		  return subject.length ? subject : null;
		}
		
		
		
		
		$(document).ready(function(){
			$("#lasso_reset").click(function(){
				
				if (rds_exist)
				{
				
					
					
					lasso_temp.classed("selected",false);
					
					
					
					lasso_temp = new Array();
					
					
					selected = new Array();
					
					
					
					
					var members = lasso_gene.split("_")
					var morg = true;
					
					if (members.length==1)
						morg = true;
					else
						morg = false;
					
					if (morg)
						d3.select('#lasso_window').remove();
					
					else
					{
						for (var i=0; i<members.length; i++)
						{
							d3.select("#lasso_window" + members[i]).remove();
						}
					}
					

					alert("Reset Complete.");
				}
				
				
				else
				{
					alert("Please add markers first.");
				}
			});
		});
		
		
		function add_degs ()
		{
				
			
			new_markers = new Array();
			old_markers = new Array();
			
			for (var i=0; i<added_markers_list.length; i++)
			{
				if (markers.indexOf(added_markers_list[i]) == -1 )
				{
					
					new_markers[new_markers.length] = added_markers_list[i];
				}
				
				else if (cur_markers.indexOf(added_markers_list[i]) == -1)
				{
					old_markers[old_markers.length] = added_markers_list[i];
				}
			}
			
			for (var i=0; i<old_markers.length; i++)
			{
				cur_markers[cur_markers.length] = old_markers[i];
			}

			
			
			if (new_markers.length > 0)
			{
				markers_string = "";
			
			
				for (var i=0; i<new_markers.length; i++)
				{
					if (i == new_markers.length-1)
					{
						markers_string += new_markers[i];
					}
					
					else
					{
						markers_string = markers_string + new_markers[i] + "_";
					}
					
					
				}
		
		
		


			  
				dims_cells_data = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
				  + rds_name + "_" + markers_string;
			 
												
										
				console.log ("dim_cells.r start");
										
				console.time("dims_cells.r time:");	
			  
				$.ajax({
				
					async: true,
					type: "POST",
				
					url: "../rscripts/dims_cells.r",
				
					data: dims_cells_data,
				
					contentType: "application/json" 
					,

					success: function(response){
						
						
						console.timeEnd("dims_cells.r time:");
						
						console.log("dims_cells.r finish")
						
						
						
						
						dim_cells_results = response;
						
						var split_dcr = dim_cells_results.split(",");
						 
						
						var result_markers = split_dcr[0];
						var data_markers = split_dcr[0].split("_")
						
						
					

						if (result_markers!="")
						{

					  
							for (var i=0; i<data_markers.length; i++)
							{		
								
								cur_markers[cur_markers.length] = data_markers[i];	
							}
							
							
							
							
		
							y_length = 1 + cur_groups.length + cur_markers.length;
							
							var cur_height = y_length*unit_height;
							var half_height = height/2;
							
							if (cur_height > half_height)
							{
								rec_height = half_height/y_length;
							}
							else
								rec_height = unit_height;
							

							
	

    
							for (var i=0; i<data_markers.length; i++)
							{		
								markers[markers.length] = data_markers[i];
								
							}
							
							
							

							if (first_add)
							{
								
								var dimensions_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
								+ document.getElementById("ld").value + "/dimensions.csv";
							
								var req_dim = new XMLHttpRequest();
								req_dim.open("GET", dimensions_path, false); 
								req_dim.send(null);

								var dim_lines = req_dim.responseText.split('\n');
								
								
								
								dimensions = new Array();
								for (var i=0; i<dim_lines.length-1; i++)
								{
									if (dim_lines[i+1] != "")
									{
										dimensions[i] = dim_lines[i+1].split(",");																								
									}												
								}
								
								nrow = dimensions.length;
								
		
								
								
								
								
								for (var i=0; i<n_dims; i++)
								{
									dom_arr[i] = Number.MIN_VALUE;
								}
								
								
								for (var i=0; i<dimensions.length; i++)
								{
									for (var j=1; j<dimensions[0].length; j++)
									{
										var cur_d = Math.floor((j - 1) / 2);
										
										var cur_v = Math.abs(Number(dimensions[i][j]));
										
										if (cur_v > dom_arr[cur_d])
										{											
											dom_arr[cur_d] = cur_v;
										}
									}
								}
								
								
								var largest = 0;
								for (var i=0; i<dimensions.length; i++)
								{
									for (var j=1; j<dimensions[0].length; j++)
									{
										var cur_v = Math.abs(Number(dimensions[i][j]));
										if (cur_v > largest)
										{
											
											largest = cur_v;
										}
									}
								}
								
								
								dom = largest*(11/10);
								
							
								
								
								var clu_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
								+ document.getElementById("ld").value + "/clusterings.csv";
					
							
								var req_clu = new XMLHttpRequest();
								req_clu.open("GET", clu_path, false); 
								req_clu.send(null);

								var clu_lines = req_clu.responseText.split('\n');
								
								
								
								clusterings = new Array();
								for (var i=0; i<clu_lines.length-1; i++)
								{
									if (clu_lines[i+1] != "")
									{
										clusterings[i] = clu_lines[i+1].split(",");																								
									}												
								}
					
							}
 
  
  
                            var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
							  + rds_name + "_" + nrow + "_" + n_dims + "_" + data_markers.length + "_" + density_th + "_" + split_dcr[1];
							  
							console.time("density.py time:");	
					                    
                            $.ajax({
                                async: true,
                            
                                url: "density.py",
                                type: 'POST',
                                
                                contentTpye: 'application/json',
                                dataType: 'json',
                            
                                data: {'fd_ld': density_string},
                                
                                success: function(response){
                                    
                                    var endTime2 = new Date().getTime();
                                    
                                    console.timeEnd("density.py time:");
                                    
                                    console.log("density.py finish");
                                    
                                   
                                    
                                    var filtered_ids_result = response["filtered_ids"];
									
				
                                    
                                    var split_cell_ids = split_dcr[1].split(" ");
                                    
                                    
                                    
                                    for (var i=0; i<data_markers.length; i++)
                                    {
                                        var cur_marker_name = data_markers[i];
                                        
                                        
                                        
                                        
                                        
                                        var cell_num = Number(split_cell_ids[i*(1+nrow)]);
                                        
                                        cell_ids[cur_marker_name] = new Array();
                                        
                                        for (var j=0; j<cell_num; j++)
                                        {
                                            cell_ids[cur_marker_name][j] = Number(split_cell_ids[i*(1+nrow) + 1+j]);
                                        }
                                        
                                        
                                        
                                        filtered_ids[cur_marker_name] = new Array();
                                        
                                        filtered_ids[cur_marker_name][0] = new Array();
                                        
                                        
										var cur_cell_ids = cell_ids[cur_marker_name];
							
										var cur_ids_len = cur_cell_ids.length;
										
										var temp_arr = new Array();
										
										for (var j=0; j<cur_ids_len; j++)
										{
											temp_arr[j] = cur_cell_ids[j];
										}
										
										
										for (var k=0; k<n_dims; k++)
										{                                                                                     																	
											for (var l=0; l<cur_ids_len; l++)
											{
												var cur_id = filtered_ids_result[i*n_dims*nrow + k*nrow + l];
												
												if (cur_id == -1 && temp_arr[l] != -1) 
												{
													temp_arr[l] = -1;
												}
											}
										}
										
										
										
										
										var fc = 0;
										
										for (var j=0; j<cur_ids_len; j++)
										{
											var cur_id = temp_arr[j];
											
											if (temp_arr[j] != -1)
											{
												// filtered_ids[cur_marker_name][fc] = cur_id;
                                                filtered_ids[cur_marker_name][0][fc] = cur_id;
												
												fc++;
											}
										}
										
										
                                        

                                        
                                        
                                      
                                        
                                        
                                        if (!expressions.hasOwnProperty(cur_marker_name))
                                        {									
                                            var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
                                            + document.getElementById("ld").value + "/" + cur_marker_name + "_expression.csv";
                                
                                        
                                            var req_ex = new XMLHttpRequest();
                                            req_ex.open("GET", ex_path, false); 
                                            req_ex.send(null);

                                            expressions[cur_marker_name] = req_ex.responseText.split('\n');	
                                        }	
                                            
                                            
                                        if (!ex_colors.hasOwnProperty(cur_marker_name))	
                                        {	
                                            var cur_ex = expressions[cur_marker_name];
                                            
                                            var ex_max = Number.MIN_VALUE;
                                            var ex_min = Number.MAX_VALUE;
                                            
                                            var cur_ex_temp = new Array();
                    
                                            for (var j=0; j<nrow; j++)
                                            {		
                                                var cur_value = Number(cur_ex[j+1]);
                                                
                                                cur_ex_temp[j] = cur_value;
                                                
                                                if (cur_value > ex_max)
                                                {
                                                    ex_max = cur_value;
                                                }
                                                
                                                if (cur_value < ex_min)
                                                {
                                                    ex_min = cur_value;
                                                }
                                            }
                                            
                                            ex_maxs[cur_marker_name] = ex_max;
                                            ex_mins[cur_marker_name] = ex_min;
                                            
                                            
                                            sorted_indices[cur_marker_name] = new Array();
                                            
                                            var cur_indices = sorted_indices[cur_marker_name];
                                            
                                            for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
                                            cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
                                        
                                        
                                            
                                            reverse_sorted_indices[cur_marker_name] = new Array();
                                            
                                            var cur_reverse_indices = reverse_sorted_indices[cur_marker_name];
                                            
                                            for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
                                            cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
                                        
                                        
                                            ex_colors[cur_marker_name] = new Array();
                                            var cur_color = ex_colors[cur_marker_name];
                                            
                                            
                                            for (var j = 0; j < nrow; j++)
                                            {
                                                var ge = Number(cur_ex[cur_indices[j]+1]);
                                               
                                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                                
                                                cur_color[j] = new Array();
                                                
                                                
                                                
                                                for (var k = 0; k < 3; k++)
                                                {
                                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
                                                }
                                               
                                            }

                                            
                                        }

                                        
                                      
                                        var cur_marker_ids = filtered_ids[cur_marker_name][0];
                                        
                                        hulls[cur_marker_name] = new Array();
                                        areas[cur_marker_name] = new Array();
                                        areas_marker[cur_marker_name] = new Array();
                                    
										hulls_dom[cur_marker_name] = new Array();
										row_sizes[cur_marker_name] = Number.MIN_VALUE;
										hulls_mean[cur_marker_name] = new Array();
										
										if (cur_marker_ids.length > 2)
                                        {
										
											for (var j=0; j<n_dims; j++)
											{						

												
												
												var cur_dom = dom_arr[j] * (11/10);
										
												var cur_x2 = d3.scaleLinear()
																.domain([-cur_dom, cur_dom])
																.range([0, ep_size]);
														
												
												var points = new Array();
												

												for (var k=0; k<cur_marker_ids.length; k++)
												{
													var cur_id_dim = dimensions[cur_marker_ids[k]];
													
													points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
												}


												
											 
												var cur_hull = d3.polygonHull(points);
												
				
												
												hulls[cur_marker_name][j] = new Array();
												
												
												hulls[cur_marker_name][j][0] = cur_hull;
												
												
												var sum_x = 0;
												var sum_y = 0;
												
												for (var k=0; k<cur_hull.length; k++)
												{
													var cur_point = cur_hull[k];
													
													sum_x += cur_point[0];
													sum_y += cur_point[1];
													
												}
												
												var mean_x = sum_x / cur_hull.length;
												var mean_y = sum_y / cur_hull.length;
												
												
												hulls_mean[cur_marker_name][j] = [mean_x, mean_y];
												
												
												hulls_dom[cur_marker_name][j] = new Array();
												
												hulls_dom[cur_marker_name][j][0] = new Array();
												
												var cur_one = d3.scaleLinear()
																.domain([-cur_dom, cur_dom])
																.range([-1, 1]);
												
												for (var k=0; k<cur_hull.length; k++)
												{
													var cur_point = cur_hull[k];
													
													var cur_x = cur_one(cur_point[0] - mean_x);
													
													var cur_y = cur_one(-(cur_point[1] - mean_y));
													
													hulls_dom[cur_marker_name][j][0][k] = [cur_x, cur_y];
													
													if (Math.abs(cur_x) > row_sizes[cur_marker_name])
													{
														row_sizes[cur_marker_name] = Math.abs(cur_x);
													}

													if (Math.abs(cur_y) > row_sizes[cur_marker_name])
													{
														row_sizes[cur_marker_name] = Math.abs(cur_y);
													}														
												}
												

												var cur_area = Math.abs(d3.polygonArea(cur_hull));
												
												areas[cur_marker_name][j] = cur_area;
												
												var scaled_hull = new Array();
													
												for (var k=0; k<cur_hull.length; k++)
												{
													scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
												}
												
												areas_marker[cur_marker_name][j] = Math.abs(d3.polygonArea(scaled_hull));
											}
										}
										else
										{
						
											
											for (var j=0; j<n_dims; j++)
											{
												hulls[cur_marker_name][j] = new Array();
												areas[cur_marker_name][j] = 0;
												areas_marker[cur_marker_name][j] = 0;
												
												hulls_dom[cur_marker_name][j] = new Array();
												row_sizes[cur_marker_name] = 0;
											}
									
										}                   
                                    }             
                                            
                                    all_genes_done();
                            
                                    console.log("add_degs finish");
                                }
                            });
		
				
						}
						
						else
						{	
							if (old_markers.length > 0)
							{
								y_length = 1 + cur_groups.length + cur_markers.length;
							
								var cur_height = y_length*unit_height;
								var half_height = height/2;
								
								if (cur_height > half_height)
								{
									rec_height = half_height/y_length;
								}
								else
									rec_height = unit_height;

							
								
				
								all_genes_done();
								
								console.log("add_degs finish");
							}
							
							
							else
							{
								alert("The genes you entered are not in the data or the genes are differentially expressed in less than 3 cells.");
								
								d3.select('.loader').remove();
							}
						}
				
					}
				});

			}
			
			else
			{
				y_length = 1 + cur_groups.length + cur_markers.length;
						
				var cur_height = y_length*unit_height;
				var half_height = height/2;
				
				if (cur_height > half_height)
				{
					rec_height = half_height/y_length;
				}
				else
					rec_height = unit_height;
				
				

						
				
				
				all_genes_done();
				
				
				console.log("add_degs finish");
			}	
		}
		
		
		
		
		
		function more()	
		{	
			console.log("more start")
			
			
			
			document.getElementById("more_button").remove();
			
			
			
			var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
			var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
			
			
			
			console.log("loader: more");
			
		
			d3.select('.d3-context-menu')
				.append('div')											
				.attr('class', 'loader')
				.style('position', 'absolute')
			
				.style('left', menu_loader_width)
				.style('top', menu_loader_height)
				.raise();
			
			
		
			
			
			
			var degs_string2 = "";
					
					
			for (var i=0; i<menu_size; i++)
			{
				var cur_index = others2_index + i;
				
				if (others2.length>cur_index)
				{
				
					if ((i == (menu_size-1)) || (cur_index == (others2.length-1)))
					{
						degs_string2 += others2[cur_index];
					}
					
					else
					{
						degs_string2 = degs_string2 + others2[cur_index] + "_";
					}
				}
				
			}
			
		
			var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
			"_" + rds_name + "_" + degs_string2;
			
			console.log(degs_string);
			
			console.time("degs.r time:");	
  
			$.ajax({
	
				async: true,
				type: "POST",
				url: "../rscripts/degs.r",
				data: degs_string,
				contentType: "application/json",
				

				success: function(response){


					console.timeEnd("degs.r time:");

					console.log("degs.r finish")

					for (var i=0; i<menu_size; i++)
					{
						var cur_index = others2_index + i;
						
						if (others2.length>cur_index)
						{
							
							var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
							+ document.getElementById("ld").value + "/" + others2[cur_index] + "_expression.csv";
				
						
							var req_ex = new XMLHttpRequest();
							req_ex.open("GET", ex_path, false); 
							req_ex.send(null);

							expressions[others2[cur_index]] = req_ex.responseText.split('\n');
							
							
							
							var cur_ex = expressions[others2[cur_index]];
									
							var ex_max = Number.MIN_VALUE;
                            var ex_min = Number.MAX_VALUE;
							
							var cur_ex_temp = new Array();
	
							for (var j=0; j<nrow; j++)
							{		
								var cur_value = Number(cur_ex[j+1]);
								
								cur_ex_temp[j] = cur_value;
								
								if (cur_value > ex_max)
								{
									ex_max = cur_value;
								}
                                
                                if (cur_value < ex_min)
								{
									ex_min = cur_value;
								}
							}
							
							ex_maxs[others2[cur_index]] = ex_max;
							ex_mins[others2[cur_index]] = ex_min;
							
							
							sorted_indices[others2[cur_index]] = new Array();
				
							var cur_indices = sorted_indices[others2[cur_index]];
							
							for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
							cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
						
						
							
							reverse_sorted_indices[others2[cur_index]] = new Array();
							
							var cur_reverse_indices = reverse_sorted_indices[others2[cur_index]];
							
							for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
							cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
						
						
						
							ex_colors[others2[cur_index]] = new Array();
							var cur_color = ex_colors[others2[cur_index]];
							
							
							for (var j = 0; j < nrow; j++)
							{
								var ge = Number(cur_ex[cur_indices[j]+1]);
                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                
                               
								cur_color[j] = new Array();
								
								for (var k = 0; k < 3; k++)
								{
								  
								   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
								}
							   
							}
							
							
							

							var cur_xy = new Array();
		
							var cur_indices = sorted_indices[others2[cur_index]];
							
							
							
							
							
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[cur_indices[j]];
								
								cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
		
        
        
        
							var deg_svg = d3.selectAll('.d3-context-menu')
								.append('svg')
								.attr("id", others2[cur_index] + "deg")
								.attr("width", plot_size/2)
								.attr("height", plot_size/2+text_size)
								.on("click", function() {
									var gene_string = this.textContent;
									var d3_id = '#' + gene_string + "deg";
									var border_str = border_size + "px solid #3b5998"
									
									var di = added_degs.indexOf(gene_string);
									if (di==-1)
									{	
										added_degs[added_degs.length] = gene_string;
										d3.select(d3_id).style("border", border_str);
									}
									else
									{
										added_degs.splice(di, 1);
										d3.select(d3_id).style("border", "none");
									}
								})
							
							
							menu_svgs[menu_svgs.length] = deg_svg;
							
							deg_svg.append("text")						
								.attr("x", (plot_size / 4))             								
								.attr("y", (text_size*2)/3)
								.attr("text-anchor", "middle")  														 
								.style("font-size", "10px")  
								.text(others2[cur_index])
							
							
							
							
							var mep_dots_data = deg_svg
							.selectAll()				
							.data(cur_xy).enter()
							.append("circle")
							.attr("id", function(d, i) {return i;})
							.attr("cx", function(d) {return x4(d[0])})
							.attr("cy", function(d) {return x4(-d[1])})			
							.attr("r", cell_size/2)
							
							
							mep_dots_data
								.data(ex_colors[others2[cur_index]])
								.attr("fill", function(d) {
								return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
							
							
							
						}
						
					}
					
					
					
					
					if (others2.length > (others2_index + menu_size) )
					{
						
						d3.selectAll('.d3-context-menu')
							.append("input")
							.attr("id", "more_button")
							.attr("type", "button")
							.attr("value", "More")
							.style("display", "block")
							.style("margin", "0 auto")
							.on("click", function() {
								more();
							})
							
							
						others2_index += menu_size;
						
						
						
						
						d3.select('.loader').remove();
					}
					
					else
					{
			
						
						d3.select('.loader').remove();
					}
				}
			});	
		}
		
		
	
		
		
		
		d3.contextMenu = function (menu, openCallback) {
			
			
			
			
			$(document).mouseup(function (e) { 
				if ($(e.target).closest(".d3-context-menu").length 
							=== 0) { 
					d3.select('.d3-context-menu').remove();
				} 
			}); 
			

			
			return function(data, index) {	
			
				// console.log("success!");
				d3.event.preventDefault();
				
				d3.select('.d3-context-menu').remove();
				
				
				console.log("loader: d3.contextMenu");
				d3.select('body')
					.append('div')
					.attr('class', 'loader')
					.style('position', 'absolute')
					.style('left', width/2 + 'px')		
			
					.style('top', $(document).scrollTop() + height/2 + 'px')
					
				
				
				
				
				menu_svgs = new Array();
				added_degs = new Array();
				
				menu_size = 16;
				space_size = 10;
				text_size = font_size;
				menu_width = plot_size*2 + space_size*(Math.sqrt(menu_size)-1) + 'px';
				menu_height = (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
				
				
				// console.log(text_size, font_size, menu_width, plot_size, menu_height);
				
				
					
				d3.select('body')
					.append('div')
					.attr('class', 'd3-context-menu')
					.style('width', menu_width)
					.style('height', menu_height)
					
				
				
				dcx = d3.event.pageX;
				dcy = d3.event.pageY;
				
			

			
				
				
				deg_test = this;
				cl_test = this;
				
				var cur_circle_id = this;
				
				
				
				selected_gene = this["parentNode"].textContent;
				selected_index = markers_on.indexOf(selected_gene);
				
				// console.log(selected_gene);
				// console.log(selected_index);
				
				
				var cur_id = "#" + selected_gene;
				
				var cur_bounding = d3.select(cur_id)["_groups"][0][0].getBoundingClientRect();
			
            
				
				var others_exist = false;
				
				if (selected_gene in deg_others)
				{
					if (typeof deg_others[selected_gene][dim_id] != "undefined")
					{		
						
						others_exist = true;
						
						others2 = new Array();
						
						for (var i=0; i<deg_others[selected_gene][dim_id].length; i++)
						{
							others2[i] = deg_others[selected_gene][dim_id][i];
						}
						
						
						
						var others2_string;
							
						if (others2.length==0)
						{
							others2_string = "No gene."
						}
						else
						{
							others2_string = "";
							
							for (var j=0; j<others2.length; j++)
							{
								if (j==(others2.length-1))
									others2_string = others2_string + others2[j];
								else
									others2_string = others2_string + others2[j] + " ";
							}
						}
										
						var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
						menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
						
						d3.selectAll('.d3-context-menu')
							.style("height", menu_height)
						
						
						
						var degs_width = plot_size*2 - 30 + 'px';
						
						var degs = d3.selectAll('.d3-context-menu')
						.append('ol')
						.attr('class', 'breadcrumb mb-4')
						
						
							.append('span')
						
							.html(others2_string)
							.style("display", "block")
							.style("width", degs_width)
							.style("word-wrap", "break-word")
							
						
						
						d3.selectAll('.d3-context-menu')
						.append("input")
						.attr("id", "add_degs_button")
						.attr("type", "button")
						.attr("value", "Add genes to the cirlce heatmap")
						.style("display", "block")
						.style("margin", "0 auto")
						.on("click", function() {
							
						
							
							
							var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
							var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
							
							console.log("loader: d3.contextMenu");
							
							d3.select('.d3-context-menu')
								.append('div')											
								.attr('class', 'loader')
								.style('position', 'absolute')
							
								.style('left', menu_loader_width)
								.style('top', menu_loader_height)
								.raise();
							
						
							
							added_markers_list = new Array();
							
							for (var i=0; i<added_degs.length; i++)
							{
								added_markers_list[i] = added_degs[i];
							}
							
							added_degs = new Array();
							
							add_degs();
						})
				
				
						for (var i=0; i<menu_size; i++)
						{
							
							if (others2.length>i)
							{
							
				
								
								var deg_svg = d3.selectAll('.d3-context-menu')
									.append('svg')
									.attr("id", others2[i]+"deg")
									.attr("width", plot_size/2)
									.attr("height", plot_size/2+text_size)
									.on("click", function() {
										var gene_string = this.textContent;
										var d3_id = '#' + gene_string + "deg";
										var border_str = border_size + "px solid #3b5998"
										
										var di = added_degs.indexOf(gene_string);
										if (di==-1)
										{	
											added_degs[added_degs.length] = gene_string;
											d3.select(d3_id).style("border", border_str);
										}
										else
										{
											added_degs.splice(di, 1);
											d3.select(d3_id).style("border", "none");
										}
									})
									
								menu_svgs[menu_svgs.length] = deg_svg;
								
								var small_font_size_str = (font_size*2)/3 + "px";
								deg_svg.append("text")
									.attr("x", (plot_size / 4))             								
									.attr("y", (text_size*2)/3)
									.attr("text-anchor", "middle")  														 
									.style("font-size", small_font_size_str)  
									.text(others2[i])
									
								
	
								
								var cur_xy = new Array();
							
								var cur_indices = sorted_indices[others2[i]];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices[j]];
									
									cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								
							
								
								
								
								var mep_dots_data = deg_svg
								.selectAll()				
								.data(cur_xy).enter()
								.append("circle")
								.attr("id", function(d, i) {return i;})
								.attr("cx", function(d) {return x4(d[0])})
								.attr("cy", function(d) {return x4(-d[1])})			
								.attr("r", cell_size/2)
								
								
								mep_dots_data
									.data(ex_colors[others2[i]])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
								
								
								
								
								
							}
							
						}
						
						if (others2.length > menu_size)
						{
							
							
							d3.selectAll('.d3-context-menu')
								.append("input")
								.attr("id", "more_button")
								.attr("type", "button")
								.attr("value", "More")
								.style("display", "block")
								.style("margin", "0 auto")
								.on("click", function() {
									more();
								})
						
						
							others2_index = menu_size;
							
							
							
							
							var range2 = cur_cirlce_id["parentNode"]["parentNode"].getBoundingClientRect();
				
							var menu_space = range2["x"]+range2["width"]-dcx + 10;
							
							d3.select('.d3-context-menu')
							
								.style('left', (dcx - 2 + menu_space) + 'px')
							
								.style('top', range2["y"] + 'px')
								.style('display', 'block');

				
							
							d3.select('.loader').remove();
						}
						
						
						else
						{

				
							var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
				
						
							var menu_space = range2["x"]+range2["width"]-dcx + 10;
							
							d3.select('.d3-context-menu')
									.style("position", "absolute")
									
									.style("left", cur_bounding.left + "px")
								
									.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
									.style('display', 'block')
									.raise()
									
								
					
							
							d3.select('.loader').remove();
						}
							
							
				
					}	
				}
				
				if (!others_exist)
				{
					

                    var cur_cell_ids = filtered_ids[selected_gene][dim_id];
					
					
					var cell_ids_string = "";
					for (var i=0; i<cur_cell_ids.length; i++)
					{
						if (i==(cur_cell_ids.length-1))
							cell_ids_string = cell_ids_string + cur_cell_ids[i];
						else
							cell_ids_string = cell_ids_string + cur_cell_ids[i] + "_";
					}
					
					
					var gene_label = document.getElementById("fd").value + "," + document.getElementById("ld").value + 
					"," + rds_name + "," + dim_id + "," + selected_gene + "," + cell_ids_string;
					

					
					console.time("others.r time:");	
		  
					$.ajax({
						
						async: true,
						type: "POST",
						url: "../rscripts/others.r",
						data: gene_label,
						contentType: "application/json",
						

						success: function(response){


							console.timeEnd("others.r time:");

							console.log("others.r finish")
							
							
							
						
							
							
							others2 = response.split(" ");
							
							if (others2=="")
								others2 = new Array();
							
						
							if (!(selected_gene in deg_others))
							{
								deg_others[selected_gene] = new Array();		
							}
							
						
							deg_others[selected_gene][dim_id] = new Array();
							
												
							for (var j=0; j<others2.length; j++)
							{
								deg_others[selected_gene][dim_id][j] = others2[j];		
							}
							
							
							
							
							var others2_string;
							
							if (others2.length==0)
							{
								others2_string = "No gene."
							}
							else
							{
								others2_string = "";
								
								for (var j=0; j<others2.length; j++)
								{
									if (j==(others2.length-1))
										others2_string = others2_string + others2[j];
									else
										others2_string = others2_string + others2[j] + " ";
								}
							}
											
							var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
							menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
							
							d3.selectAll('.d3-context-menu')
								.style("height", menu_height)
							
							
							
							var degs_width = plot_size*2 - 30 + 'px';
							
							var degs = d3.selectAll('.d3-context-menu')
							.append('ol')
							.attr('class', 'breadcrumb mb-4')
							
							
								.append('span')
								
								.html(others2_string)
								.style("display", "block")
								.style("width", degs_width)
								.style("word-wrap", "break-word")
							
							
							if (others2.length!=0)
							{

								
								var degs_string2 = "";
									
									
								for (var i=0; i<menu_size; i++)
								{
									if (others2.length>i)
									{
									
										if ((i == (menu_size-1)) || (i == (others2.length-1)))
										{
											degs_string2 += others2[i];
										}
										
										else
										{
											degs_string2 = degs_string2 + others2[i] + "_";
										}
									}
									
								}
								
								
								
								var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
								"_" + rds_name + "_" + degs_string2;
								
		
								
								console.time("degs.r time:");	
					  
								$.ajax({
									
									async: true,
									type: "POST",
									url: "../rscripts/degs.r",
									data: degs_string,
									contentType: "application/json",
									

									success: function(response){


										console.timeEnd("degs.r time:");

										console.log("degs.r finish")

										d3.selectAll('.d3-context-menu')
										.append("input")
										.attr("id", "add_degs_button")
										.attr("type", "button")
										.attr("value", "Add genes to the cirlce heatmap")
										.style("display", "block")
										.style("margin", "0 auto")
										.on("click", function() {
											
											
											
											
											var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
											var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
											
											
											console.log("loader: d3.contextMenu");
											
											d3.select('.d3-context-menu')
												.append('div')											
												.attr('class', 'loader')
												.style('position', 'absolute')
											
												.style('left', menu_loader_width)
												.style('top', menu_loader_height)
												.raise();
											
										
											
											added_markers_list = new Array();
											
											for (var i=0; i<added_degs.length; i++)
											{
												added_markers_list[i] = added_degs[i];
											}
											
											added_degs = new Array();
											
											add_degs();
										})
								
								
										for (var i=0; i<menu_size; i++)
										{
											
											if (others2.length>i)
											{
												
												var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
												+ document.getElementById("ld").value + "/" + others2[i] + "_expression.csv";
									
											
												var req_ex = new XMLHttpRequest();
												req_ex.open("GET", ex_path, false); 
												req_ex.send(null);

												expressions[others2[i]] = req_ex.responseText.split('\n');
												
												
												
												
												
												var cur_ex = expressions[others2[i]];
									
												var ex_max = Number.MIN_VALUE;
                                                var ex_min = Number.MAX_VALUE;
												
												var cur_ex_temp = new Array();
						
												for (var j=0; j<nrow; j++)
												{		
													var cur_value = Number(cur_ex[j+1]);
													
													cur_ex_temp[j] = cur_value;
													
													if (cur_value > ex_max)
													{
														ex_max = cur_value;
													}
                                                    
                                                    if (cur_value < ex_min)
													{
														ex_min = cur_value;
													}
												}
												
												ex_maxs[others2[i]] = ex_max;
												ex_mins[others2[i]] = ex_min;
												
												
												sorted_indices[others2[i]] = new Array();
									
												var cur_indices = sorted_indices[others2[i]];
												
												for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
												cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
											
											
												
												reverse_sorted_indices[others2[i]] = new Array();
												
												var cur_reverse_indices = reverse_sorted_indices[others2[i]];
												
												for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
												cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
											
											
											
												ex_colors[others2[i]] = new Array();
												var cur_color = ex_colors[others2[i]];
												
												
												for (var j = 0; j < nrow; j++)
												{
													var ge = Number(cur_ex[cur_indices[j]+1]);                                                    
                                                    var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                                    
												   
													cur_color[j] = new Array();
													
													for (var k = 0; k < 3; k++)
													{
													   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
													}
												   
												}
												
												
									
											
												
												var deg_svg = d3.selectAll('.d3-context-menu')
													.append('svg')
													.attr("id", others2[i] + "deg")
													.attr("width", plot_size/2)
													.attr("height", plot_size/2+text_size)
													.on("click", function() {
														var gene_string = this.textContent;
														var d3_id = '#' + gene_string + "deg";
														var border_str = border_size + "px solid #3b5998"
														
														var di = added_degs.indexOf(gene_string);
														if (di==-1)
														{	
															added_degs[added_degs.length] = gene_string;
															d3.select(d3_id).style("border", border_str);
														}
														else
														{
															added_degs.splice(di, 1);
															d3.select(d3_id).style("border", "none");
														}
													})
													
												menu_svgs[menu_svgs.length] = deg_svg;
												
												var small_font_size_str = (font_size*2)/3 + "px";
												deg_svg.append("text")
													.attr("x", (plot_size / 4))             								
													.attr("y", (text_size*2)/3)
													.attr("text-anchor", "middle")  														 
													.style("font-size", small_font_size_str)  
													.text(others2[i])
												



												var cur_xy = new Array();
							
												var cur_indices = sorted_indices[others2[i]];
												
												
												
												
												
												for (var j=0; j<nrow; j++)
												{
													var cur_index = dimensions[cur_indices[j]];
													
													cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
												}
												
												
												
											
												
												
												
												var mep_dots_data = deg_svg
												.selectAll()				
												.data(cur_xy).enter()
												.append("circle")
												.attr("id", function(d, i) {return i;})
												.attr("cx", function(d) {return x4(d[0])})
												.attr("cy", function(d) {return x4(-d[1])})			
												.attr("r", cell_size/2)
												
												
												mep_dots_data
													.data(ex_colors[others2[i]])
													.attr("fill", function(d) {
													return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
												
												
												
												
											}
											
										}
										
										if (others2.length > menu_size)
										{
											
											d3.selectAll('.d3-context-menu')
												.append("input")
												.attr("id", "more_button")
												.attr("type", "button")
												.attr("value", "More")
												.style("display", "block")
												.style("margin", "0 auto")
												.on("click", function() {
													more();
												})
										
										
											others2_index = menu_size;
											
											
											
										
											var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
								
											var menu_space = range2["x"]+range2["width"]-dcx + 10;
											
											d3.select('.d3-context-menu')
												.style("position", "absolute")
												
												.style("left", cur_bounding.left + "px")
												
												.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
												.style('display', 'block')
												.raise()
												
											
									
											
											d3.select('.loader').remove();
										}
										
										
										else
										{
		
										
											var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
								
											
											var menu_space = range2["x"]+range2["width"]-dcx + 10;
											
											d3.select('.d3-context-menu')
												.style("position", "absolute")
												
												.style("left", cur_bounding.left + "px")
										
												.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
												.style('display', 'block')
												.raise()
												
											
											
											
											d3.select('.loader').remove();
										}
									}
								});
							}
							
							
				
							
							else
							{
							
								
								var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
					
							
								var menu_space = range2["x"]+range2["width"]-dcx + 10;
								
								
								d3.select('.d3-context-menu')
									.style("position", "absolute")
								
									.style("left", cur_bounding.left + "px")
									
									.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
									.style('display', 'block')
									.raise()
									
									
								
								d3.select('.loader').remove();
							}
							
							
							
							
							
						}
					});
				}
				
				
			};
		};
		
        
        
        
        function remove_filtering_windows()
        {
            var cur_members = lasso_gene.split("_")
            var cur_morg = true;
            
            if (cur_members.length==1)
                cur_morg = true;
            else
                cur_morg = false;
            
            
            		
                
            var lasso_gene_id = "#" + lasso_gene;
            
            
            
            if (cur_morg)
                d3.select("#lasso_window" + lasso_gene).remove();
            else
            {
                
                if (density_on)
                {
                    
                    
                    if (final_selected.length > 0)
                    {
                        lasso_temp.classed("selected",false);
                    
                    
                    
                        lasso_temp = new Array();
                        
                        
                        
                        
                        var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                        
                        for (var j=0; j<selected_density.length; j++)
                        {
            
                            cur_lasso_dots[selected_density[j]].setAttribute("class", "");
                        }

                    }
                }
                
                else
                {
                
                    var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                
                    for (var i=0; i<sorted_dec.length; i++)
                    {
                        
                        
                        cur_circle[sorted_dec[i]].setAttribute("class", "");
                    
                        
                    }
                }
                
                var cur_xy_fo = new Array();
            
                var cur_indices_fo = sorted_indices[lasso_gene];
                
                
                
                
                for (var j=0; j<nrow; j++)
                {
                    var cur_index = dimensions[cur_indices_fo[j]];
                    
                    cur_xy_fo[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                }
                
                var cur_dom = dom_arr[dim_id] * (11/10);
				
				var cur_x2 = d3.scaleLinear()
								.domain([-cur_dom, cur_dom])
								.range([0, ep_size]);
                
            
                
                d3.select(lasso_gene_id)
                    .select("#mep_dots")
                    .selectAll('circle')								
                    .data(cur_xy_fo)															
                    .attr("cx", function(d) {return cur_x2(d[0])})
                    .attr("cy", function(d) {return cur_x2(-d[1])})			
                
                
                
                
                d3.select(lasso_gene_id)
                    .select("#mep_dots")
                    .selectAll('circle')
                    .data(ex_colors[lasso_gene])
                    .attr("fill", function(d) {
                    return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
                
                
            
                
                for (var j=0; j<cur_members.length; j++)
                    d3.select("#lasso_window" + cur_members[j]).remove();
                
                d3.select("#inputs_window").remove();
                
                
                
            }
            
            
            d3.select("#legend").remove();
            
            
            
            selected = new Array();
                
            final_selected = new Array();
            selected_density = new Array();
            
            density_on = false;
            filtering_on = false;
			
			d3.select("#plot_size_slider").style('display', 'block');
			d3.select("#stop_plot_size_change").style('display', 'none');
                
                
                
            
        }
		
		
		function draw_overlap_hulls(cur_group)
		{
			
			
			d3.select("#"+cur_group+"_overlap").remove();
			
			var svg_name = '#' + cur_group;
													
			var g_overlap = d3.select(svg_name).select('#mep_dots')
				.append('g')
				.attr("id", cur_group + "_overlap");
			
			

			var cur_dim_inter_groups = inter_groups[cur_group][dim_id];
						
			var name_spaces = new Array();
			
			for (var j=0; j<4; j++)
			{
				name_spaces[j] = 0;
			}
			
			var smallest_len = 100;
			var largest_len = 0;
			
			for (var j=0; j<cur_dim_inter_groups.length; j++)
			{
				var cur_inter_group = cur_dim_inter_groups[j]; 
				
				var cur_len = cur_inter_group.length;
				
				if (cur_len < smallest_len)
				{
					smallest_len = cur_len;
				}
				
				if (cur_len > largest_len)
				{
					largest_len = cur_len;
				}
			}
			
			
			
			
			var cur_dom = dom_arr[dim_id] * (11/10);
				
			var cur_x2 = d3.scaleLinear()
							.domain([-cur_dom, cur_dom])
							.range([0, ep_size]);
							
			
				
			
				
			var mep_select = document.querySelector("#" + cur_group);
        
            
			var bbox_mep = mep_select.getBBox();

			
			for (var j=0; j<cur_dim_inter_groups.length; j++)
			{
				var cur_inter_group = cur_dim_inter_groups[j];
				

				
				var cur_hulls = hulls[cur_inter_group][dim_id];
				
				for (var l=0; l<cur_hulls.length; l++)
				{
					var cur_hull = cur_hulls[l];
					
					var scaled_hull = new Array();
					
					for (var k=0; k<cur_hull.length; k++)
					{
						scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
					}
					
					var cur_color;
					
					if (Object.keys(group_colors).includes(cur_inter_group))
					{
						cur_color = group_colors[cur_inter_group];
					}
					
					else
					{
						cur_color = d3_category437[cur_color_id];
						
						cur_color_id++;
						
						if (cur_color_id==5)
						{
							cur_color_id++;
						}
						
						group_colors[cur_inter_group] = cur_color;
					}
				
					var cur_id = cur_group + "_" + cur_inter_group + "_" + l;
															

					g_overlap
						.append("path")
						.attr("id", cur_id)									
						.style("fill", "transparent")
						.style("stroke", cur_color)
						.style("stroke-width", ep_cell_size*2)
						.attr("d", line(scaled_hull))
				}
		
	
				
				var first_id = cur_group + "_" + cur_inter_group + "_0";


				
				var cur_id_s = "#" + first_id;
						
				let bgPath = document.querySelector(cur_id_s)
				
				let bbox = bgPath.getBBox();
				let x = bbox.x + bbox.width / 2;
				let y = bbox.y + bbox.height / 2;
				
				
				
				var x_center = bbox_mep.x + bbox_mep.width/2;
				var y_center = bbox_mep.y + bbox_mep.height/2;
				
				var x_trans, y_trans;
				

				var cur_inter_space_y = font_size*0.5;
				

				var cur_font_size = font_size*0.8;
				
				if (x <= x_center && y <= y_center)
				{																
					var cur_len = name_spaces[0];
					
					x_trans = bbox_mep.x + smallest_len*3;
					y_trans = bbox_mep.y + cur_inter_space_y + cur_font_size*cur_len;
					
					name_spaces[0]++;

					
				}
				
				else if (x >= x_center && y <= y_center)
				{
					var cur_len = name_spaces[1];
					
					x_trans = bbox_mep.x + bbox_mep.width - largest_len*9;
					y_trans = bbox_mep.y + cur_inter_space_y + cur_font_size*cur_len;
					
					name_spaces[1]++;
				}
				
				else if (x <= x_center && y >= y_center)
				{
					var cur_len = name_spaces[2];
					
					x_trans = bbox_mep.x + smallest_len*3;
					y_trans = bbox_mep.y + ep_size - cur_inter_space_y - cur_font_size*cur_len;
					
					name_spaces[2]++;
				}
				
				else
				{
					var cur_len = name_spaces[3];
					
					x_trans = bbox_mep.x + bbox_mep.width - largest_len*9;
					y_trans = bbox_mep.y + ep_size - cur_inter_space_y - cur_font_size*cur_len;
					
					name_spaces[3]++;
				}
				
				
				

				let textElem = document.createElementNS(bgPath.namespaceURI, "text");
		
				textElem.setAttribute("id", first_id + "_text");
				
				textElem.setAttribute("x", x_trans);
				textElem.setAttribute("y", y_trans);
	
				
				var cur_style = "fill: " + cur_color + "; font-size: " + cur_font_size + "px";
				textElem.setAttribute("style", cur_style);
				
		
				textElem.textContent = cur_inter_group;
		
				bgPath.after(textElem);
			}	
		}
		
		
		function draw_markers_plots()
		{
			d3.select("#card_meps").style("display", "block");
			d3.select("#card_plot_size").style("display", "block");
			
			console.log("draw_markers_plots start");
			
			if (first_mp)
				first_mp = false;
			
			
		
			
			var am_tf = false;
			var rem_tf = false;
			var dcm_tf = false;
			var ccm_tf = false;
			var rsm_tf = false;
			
			var mep_markers = new Array();
			
			console.log(ccm);
			
			if (am.length > 0)
			{
				am_tf = true;
				
				for (var i=0; i<am.length; i++)
					mep_markers[i] = am[i];
			}
			
			if (rem.length > 0)
			{
				
				
				rem_tf = true;
				
				for (var i=0; i<rem.length; i++)				
					mep_markers[i] = rem[i];
				
				
				
			}
			
			if (dcm.length > 0)
			{
				dcm_tf = true;
				
				for (var i=0; i<dcm.length; i++)
					mep_markers[i] = dcm[i];
			}
			
			if (ccm.length > 0)
			{
				ccm_tf = true;
				
				for (var i=0; i<ccm.length; i++)
				{
					mep_markers[i] = ccm[i];
				}
				
				console.log(mep_markers);
				console.log(ccm);
			}
			
			if (rsm.length > 0)
			{
				rsm_tf = true;
				
				for (var i=0; i<rsm.length; i++)
					mep_markers[i] = rsm[i];
			}
			
			
			
			if (am_tf)
			{
			
				for (var i=0; i<mep_markers.length; i++)
				{
					var members = mep_markers[i].split("_")
					var morg = true;
					
					if (members.length==1)
						morg = true;
					else
						morg = false;
					

					
					var mep_svg = d3.select("#marker_plots")
					.append("svg")		
					.attr("id", mep_markers[i])
					.attr("width", ep_size)
					.attr("height", ep_size+legend_size+10)
					
					
					

					mep_svg
						.append("rect")
						.attr("id", mep_markers[i]+"_rect")
						.attr("x", 0)
						.attr("y", 0)
						.attr("width", ep_size)
						.attr("height", ep_size+legend_size)				
					
						.attr("fill", "none")
						.attr("stroke", "black")
						.attr("stroke-width", ep_cell_size*2)
			
					

					mep_svg.append("text")
					.attr("x", (ep_size / 2)) 
					.attr("y", legend_size/2+10)
					.attr("text-anchor", "middle")  					 
					.style("font-size", font_size_str)
					.style("fill", "black")
					.style("text-decoration", "underline")
					.text(mep_markers[i])
					.on("click", function(d) {
						lasso_gene = this.textContent;
						
						
						var cur_members = lasso_gene.split("_")
						var cur_morg = true;
						
						if (cur_members.length==1)
							cur_morg = true;
						else
							cur_morg = false;
						
						
						if (filtering_on)
						{		
							remove_filtering_windows();
							
                            d3.select("#plot_size_slider").style('display', 'block');
							d3.select("#stop_plot_size_change").style('display', 'none');
						}
						
						else
						{
							
							
							var filtering_start = true;
							
							
							if (!cur_morg)
							{
									
								for (var j=0; j<cur_members.length; j++)
								{
								
									
									if (!document.getElementById(cur_members[j]))
									{
									
										
										filtering_start = false;
										
										break;
									}
								}
							}
							
							
							
							if (filtering_start)
							{
					
								
								filtering_on = true;
								
								d3.select("#plot_size_slider").style('display', 'none');
								d3.select("#stop_plot_size_change").style('display', 'block');
								
								cell_filtering();
							}
							
							else
							{
						
								
								alert("Please add group member markers to Marker Expression Plots to perfoem Cell Filtering on this Group.");
							}
							
						}	
					})
					
					
					var cur_xy_am = new Array();
							
					var cur_indices_am = sorted_indices[mep_markers[i]];
					
					
					if (cur_indices_am.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[cur_indices_am[j]];
							
							cur_xy_am[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_am[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					var cur_dom = dom_arr[dim_id] * (11/10);
				
					var cur_x2 = d3.scaleLinear()
									.domain([-cur_dom, cur_dom])
									.range([0, ep_size]);
				
					
					var mep_trans = 'translate(0,' + legend_size+10 + ')';
					
					var mep_dots = mep_svg.append('g')
					.attr("id", "mep_dots")
					.attr('transform', mep_trans);
					
					
					var mep_dots_data = mep_dots.selectAll()
		
					.data(cur_xy_am).enter()
					.append("circle")
					.attr("id", function(d, i) {return i;})
					.attr("cx", function(d) {return cur_x2(d[0])})
					.attr("cy", function(d) {return cur_x2(-d[1])})			
					.attr("r", ep_cell_size)
					
					
					mep_dots_data.data(ex_colors[mep_markers[i]])
						.attr("fill", function(d) {
						return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
					
					var menu = [];
					

					
					var cur_hulls = hulls[mep_markers[i]][dim_id];
					
					for (var l=0; l<cur_hulls.length; l++)
					{
						var cur_hull = cur_hulls[l];
					
					
				
						var scaled_hull = new Array();
							
						for (var k=0; k<cur_hull.length; k++)
						{
							scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
						}
						
												
	
						mep_dots.append("path")
								.attr("id", mep_markers[i] + "_path_" + l)								
								.style("fill", "transparent")
								.style("stroke", "black")
								.style("stroke-width", ep_cell_size*2)
								.attr("d", line(scaled_hull))						
	
					}
					
					
		
					
					if (cur_groups.indexOf(mep_markers[i]) != -1)
					{
						draw_overlap_hulls(mep_markers[i]);	
					}
				


	
	
				}
				
			}	
			
			if (rem_tf)
			{
			
				
				console.log("rem_tf");
				console.log(rem_tf);
				
				
				for (var i=0; i<mep_markers.length; i++)
				{
				
					
					var svg_name = '#' + mep_markers[i];
					
		
					
					d3.select(svg_name).remove();
					
				}
			}
			
			
			
			if (dcm_tf)
			{
				if (filtering_on)
				{
                    remove_filtering_windows();
						
					d3.select("#plot_size_slider").style('display', 'block');
					d3.select("#stop_plot_size_change").style('display', 'none');	
                }
                    
                    
                for (var i=0; i<mep_markers.length; i++)
				{
					
					
					
                    
                    
                    var cur_xy_dcm = new Array();
							
					var cur_indices_dcm = sorted_indices[mep_markers[i]];
					
					
					if ( cur_indices_dcm.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[ cur_indices_dcm[j]];
							
							cur_xy_dcm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_dcm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
				
				
					var cur_dom = dom_arr[dim_id] * (11/10);
										
					var cur_x2 = d3.scaleLinear()
									.domain([-cur_dom, cur_dom])
									.range([0, ep_size]);
				
					
	
					var svg_name = '#' + mep_markers[i];
					
					d3.select(svg_name).select('#mep_dots').selectAll('circle')
					.data(cur_xy_dcm)
					.attr("cx", function(d) {return cur_x2(d[0])})
					.attr("cy", function(d) {return cur_x2(-d[1])})			
				
					
					

					
					
					
				
					if (hulls[mep_markers[i]].length > 0)
					{

						
						var cur_hulls = hulls[mep_markers[i]][dim_id];
						
						for (var l=0; l<cur_hulls.length; l++)
						{
							var cur_hull = cur_hulls[l];
				
							var scaled_hull = new Array();
								
							for (var k=0; k<cur_hull.length; k++)
							{
								scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
							}
							
							var cur_path_id = "#" + mep_markers[i] + "_path_" + l;
							
							d3.select(cur_path_id)						
								.attr("d", line(scaled_hull));
			
						}
					
					}
					
					if (cur_groups.indexOf(mep_markers[i]) != -1)
					{
						draw_overlap_hulls(mep_markers[i]);	
					}
					
	
				}
			}
			
			
			
			if (ccm_tf)
			{
				for (var i=0; i<mep_markers.length; i++)
				{
						
					
					console.log ("ccm_tf");
					
					
					
					var svg_name = '#' + mep_markers[i];
					
	
					

					selected = new Array();
					
					
	
					
					var test = mep_markers[i].split("_")
					var morg = true;
					
					if (test.length==1)
						morg = true;
					else
						morg = false;
					
					
					
					var cur_path_id = "#" + mep_markers[i] + "_path_0";
					
					var count = 0;
					
					while (d3.select(cur_path_id)._groups[0][0]!=null)
					{
						d3.select(cur_path_id).remove();
						
						count++;
						
						cur_path_id = "#" + mep_markers[i] + "_path_" + count;
					}
					
					

					var cur_dom = dom_arr[dim_id] * (11/10);
										
					var cur_x2 = d3.scaleLinear()
									.domain([-cur_dom, cur_dom])
									.range([0, ep_size]);
					
					
					console.log(mep_markers[i]);
					
					var cur_hulls = hulls[mep_markers[i]][dim_id];
					
					for (var l=0; l<cur_hulls.length; l++)
					{
						var cur_hull = cur_hulls[l];
					
					
				
						var scaled_hull = new Array();
							
						for (var k=0; k<cur_hull.length; k++)
						{
							scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
						}
						
												
	
						d3.select(svg_name).select('#mep_dots')
								.append("path")
								.attr("id", mep_markers[i] + "_path_" + l)								
								.style("fill", "transparent")
								.style("stroke", "black")
								.style("stroke-width", ep_cell_size*2)
								.attr("d", line(scaled_hull))						
						
					}
					
					
					
					
					
			
					
					
					
					
					if (!morg)
					{
						
						lasso_temp = new Array();
						
						
						
						
						var cur_xy_ccm = new Array();
							
						var cur_indices_ccm = sorted_indices[mep_markers[i]];
						
						
						if (cur_indices_ccm.length > 0)
						{
						
						
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[cur_indices_ccm[j]];
								
								cur_xy_ccm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
						}
						
						else
						{
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[j];
								
								cur_xy_ccm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
						}
				
					

						
						d3.select(svg_name).select('#mep_dots').selectAll('circle')
						.data(cur_xy_ccm)
						.attr("cx", function(d) {return cur_x2(d[0])})
						.attr("cy", function(d) {return cur_x2(-d[1])})		
						
						
						
						
						
						
						
						var cur_color = ex_colors[mep_markers[i]];
						
						d3.select("#" + mep_markers[i])
							.select('#mep_dots')
							.selectAll('circle')
							.data(cur_color)
							.attr("fill", function(d) {
								return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
					}
					
					

					
					for (var j=0; j<markers_on.length; j++)
					{
						var cur_group = markers_on[j];
						
						if (cur_groups.includes(cur_group))
						{
							draw_overlap_hulls(cur_group);	
						}
					}

				}
			}
			
			
			
			if (rsm_tf)
			{
				for (var i=0; i<mep_markers.length; i++)
				{
					var test = mep_markers[i].split("_")
					var morg = true;
					
					if (test.length==1)
						morg = true;
					else
						morg = false;
					
				
					
					
					
					var svg_name = '#' + mep_markers[i];
					
					
					d3.select(svg_name)
					.attr("width", ep_size)
					.attr("height", ep_size+legend_size)
                    
                    cur_mep_select = document.querySelector(svg_name);
                    
                    
                    console.log("cur_mep_select");
                    console.log(svg_name);
                    console.log(cur_mep_select);
					
					
					d3.select(svg_name)
						.select('rect')				
						.attr("width", ep_size)
						.attr("height", ep_size+legend_size)									
						.attr("stroke-width", ep_cell_size*2)
					

					
					d3.select(svg_name)
					.select('text')
					.attr("x", (ep_size / 2)) 
					.attr("y", legend_size/2+10)							 
					.style("font-size", font_size_str)  
					
					
					
					
					
					var cur_xy_rsm = new Array();
							
					var cur_indices_rsm = sorted_indices[mep_markers[i]];
					
					
					if (cur_indices_rsm.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[cur_indices_rsm[j]];
							
							cur_xy_rsm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_rsm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
				
					var cur_dom = dom_arr[dim_id] * (11/10);
										
					var cur_x2 = d3.scaleLinear()
									.domain([-cur_dom, cur_dom])
									.range([0, ep_size]);
				
					
					
					
					d3.select(svg_name).select('#mep_dots').selectAll('circle')
					.data(cur_xy_rsm)
					.attr("cx", function(d) {return cur_x2(d[0])})
					.attr("cy", function(d) {return cur_x2(-d[1])})	
					.attr("r", ep_cell_size)
					
					
					
					
					
					
					if (hulls[mep_markers[i]].length > 0)
					{						
						var cur_hulls = hulls[mep_markers[i]][dim_id];
						
						for (var l=0; l<cur_hulls.length; l++)
						{
							var cur_hull = cur_hulls[l];
				
							var scaled_hull = new Array();
								
							for (var k=0; k<cur_hull.length; k++)
							{
								scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
							}
							
							var cur_path_id = "#" + mep_markers[i] + "_path_" + l;
							
							d3.select(cur_path_id)						
								.attr("d", line(scaled_hull));
						
						}

					}
					
					
					if (cur_groups.indexOf(mep_markers[i]) != -1)
					{
						draw_overlap_hulls(mep_markers[i]);	
					}
				}	
			}
			
			

			am = new Array();
			rem = new Array();
			dcm = new Array();
			ccm = new Array();
			rsm = new Array();
			

		}
		
		
		
		var d3_category437 = [

		0xd3fe14, 0xfec7f8, 0x0bf0e9, 0xc203c8, 0xfd9b39, 0x888593, 
		0x906407, 0x98ba7f, 0xfe6794, 0x10b0ff, 0xac7bff, 0xfee7c0, 0x964c63, 
		0x1da49c, 0x0ad811, 0xbbd9fd, 0xfe6cfe, 0x297192, 0xd1a09c, 0x78579e, 
		0x81ffad, 0x739400, 0xca6949, 0xd9bf01, 0x646a58, 0xd5097e, 0xbb73a9, 
		0xccf6e9, 0x9cb4b6, 0xb6a7d4, 0x9e8c62, 0x6e83c8, 0x01af64, 0xa71afd, 
		0xcfe589, 0xd4ccd1, 0xfd4109, 0xbf8f0e, 0x2f786e, 0x4ed1a5, 0xd8bb7d, 
		0xa54509, 0x6a9276, 0xa4777a, 0xfc12c9, 0x606f15, 0x3cc4d9, 0xf31c4e, 
		0x73616f, 0xf097c6, 0xfc8772, 0x92a6fe, 0x875b44, 0x699ab3, 0x94bc19, 
		0x7d5bf0, 0xd24dfe, 0xc85b74, 0x68ff57, 0xb62347, 0x994b91, 0x646b8c, 
		0x977ab4, 0xd694fd, 0xc4d5b5, 0xfdc4bd, 0x1cae05, 0x7bd972, 0xe9700a, 
		0xd08f5d, 0x8bb9e1, 0xfde945, 0xa29d98, 0x1682fb, 0x9ad9e0, 0xd6cafe, 
		0x8d8328, 0xb091a7, 0x647579, 0x1f8d11, 0xe7eafd, 0xb9660b, 0xa4a644, 
		0xfec24c, 0xb1168c, 0x188cc1, 0x7ab297, 0x4468ae, 0xc949a6, 0xd48295, 
		0xeb6dc2, 0xd5b0cb, 0xff9ffb, 0xfdb082, 0xaf4d44, 0xa759c4, 0xa9e03a, 
		0x0d906b, 0x9ee3bd, 0x5b8846, 0x0d8995, 0xf25c58, 0x70ae4f, 0x847f74, 
		0x9094bb, 0xffe2f1, 0xa67149, 0x936c8e, 0xd04907, 0xc3b8a6, 0xcef8c4, 
		0x7a9293, 0xfda2ab, 0x2ef6c5, 0x807242, 0xcb94cc, 0xb6bdd0, 0xb5c75d, 
		0xfde189, 0xb7ff80, 0xfa2d8e, 0x839a5f, 0x28c2b5, 0xe5e9e1, 0xbc79d8, 
		0x7ed8fe, 0x9f20c3, 0x4f7a5b, 0xf511fd, 0x09c959, 0xbcd0ce, 0x8685fd, 
		0x98fcff, 0xafbff9, 0x6d69b4, 0x5f99fd, 0xaaa87e, 0xb59dfb, 0x5d809d, 
		0xd9a742, 0xac5c86, 0x9468d5, 0xa4a2b2, 0xb1376e, 0xd43f3d, 0x05a9d1, 
		0xc38375, 0x24b58e, 0x6eabaf, 0x66bf7f, 0x92cbbb, 0xddb1ee, 0x1be895, 
		0xc7ecf9, 0xa6baa6, 0x8045cd, 0x5f70f1, 0xa9d796, 0xce62cb, 0x0e954d, 
		0xa97d2f, 0xfcb8d3, 0x9bfee3, 0x4e8d84, 0xfc6d3f, 0x7b9fd4, 0x8c6165, 
		0x72805e, 0xd53762, 0xf00a1b, 0xde5c97, 0x8ea28b, 0xfccd95, 0xba9c57, 
		0xb79a82, 0x7c5a82, 0x7d7ca4, 0x958ad6, 0xcd8126, 0xbdb0b7, 0x10e0f8, 
		0xdccc69, 0xd6de0f, 0x616d3d, 0x985a25, 0x30c7fd, 0x0aeb65, 0xe3cdb4, 
		0xbd1bee, 0xad665d, 0xd77070, 0x8ea5b8, 0x5b5ad0, 0x76655e, 0x598100, 
		0x86757e, 0x5ea068, 0xa590b8, 0xc1a707, 0x85c0cd, 0xe2cde9, 0xdcd79c, 
		0xd8a882, 0xb256f9, 0xb13323, 0x519b3b, 0xdd80de, 0xf1884b, 0x74b2fe, 
		0xa0acd2, 0xd199b0, 0xf68392, 0x8ccaa0, 0x64d6cb, 0xe0f86a, 0x42707a, 
		0x75671b, 0x796e87, 0x6d8075, 0x9b8a8d, 0xf04c71, 0x61bd29, 0xbcc18f, 
		0xfecd0f, 0x1e7ac9, 0x927261, 0xdc27cf, 0x979605, 0xec9c88, 
		0x8c48a3,0x676769, 0x546e64, 0x8f63a2, 0xb35b2d, 0x7b8ca2, 0xb87188, 
		0x4a9bda, 0xeb7dab, 0xf6a602, 0xcab3fe, 0xddb8bb, 0x107959, 0x885973, 
		0x5e858e, 0xb15bad, 0xe107a7, 0x2f9dad, 0x4b9e83, 0xb992dc, 0x6bb0cb, 
		0xbdb363, 0xccd6e4, 0xa3ee94, 0x9ef718, 0xfbe1d9, 0xa428a5, 0x93514c, 
		0x487434, 0xe8f1b6, 0xd00938, 0xfb50e1, 0xfa85e1, 0x7cd40a, 0xf1ade1, 
		0xb1485d, 0x7f76d6, 0xd186b3, 0x90c25e, 0xb8c813, 0xa8c9de, 0x7d30fe, 
		0x815f2d, 0x737f3b, 0xc84486, 0x946cfe, 0xe55432, 0xa88674, 0xc17a47, 
		0xb98b91, 0xfc4bb3, 0xda7f5f, 0xdf920b, 0xb7bbba, 0x99e6d9, 0xa36170, 
		0xc742d8, 0x947f9d, 0xa37d93, 0x889072, 0x9b924c, 0x23b4bc, 0xe6a25f, 
		0x86df9c, 0xa7da6c, 0x3fee03, 0xeec9d8, 0xaafdcb, 0x7b9139, 0x92979c, 
		0x72788a, 0x994cff, 0xc85956, 0x7baa1a, 0xde72fe, 0xc7bad8, 0x85ebfe, 
		0x6e6089, 0x9b4d31, 0x297a1d, 0x9052c0, 0x5c75a5, 0x698eba, 0xd46222, 
		0x6da095, 0xb483bb, 0x04d183, 0x9bcdfe, 0x2ffe8c, 0x9d4279, 0xc909aa, 
		0x826cae, 0x77787c, 0xa96fb7, 0x858f87, 0xfd3b40, 0x7fab7b, 0x9e9edd, 
		0xbba3be, 0xf8b96c, 0x7be553, 0xc0e1ce, 0x516e88, 0xbe0e5f, 0x757c09, 
		0x4b8d5f, 0x38b448, 0xdf8780, 0xebb3a0, 0xced759, 0xf0ed7c, 0xe0eef1, 
		0x0969d2, 0x756446, 0x488ea8, 0x888450, 0x61979c, 0xa37ad6, 0xb48a54, 
		0x8193e5, 0xdd6d89, 0x8aa29d, 0xc679fe, 0xa4ac12, 0x75bbb3, 0x6ae2c1, 
		0xc4fda7, 0x606877, 0xb2409d, 0x5874c7, 0xbf492c, 0x4b88cd, 0xe14ec0, 
		0xb39da2, 0xfb8300, 0xd1b845, 0xc2d083, 0xc3caef, 0x967500, 0xc56399, 
		0xed5a05, 0xaadff6, 0x6685f4, 0x1da16f, 0xf28bff, 0xc9c9bf, 0xc7e2a9, 
		0x5bfce4, 0xe0e0bf, 0xe8e2e8, 0xddf2d8, 0x9108f8, 0x932dd2, 0xc03500, 
		0xaa3fbc, 0x547c79, 0x9f6045, 0x04897b, 0x966f32, 0xd83212, 0x039f27, 
		0xdf4280, 0xef206e, 0x0095f7, 0xa5890d, 0x9a8f7f, 0xbc839e, 0x88a23b, 
		0xe55aed, 0x51af9e, 
		0x5eaf82, 0x9e91fa, 0xf76c79, 0x99a869, 0xd2957d, 0xa2aca6, 0xe3959e, 
		0xadaefc, 0x5bd14e, 0xdf9ceb, 0xfe8fb1, 0x87ca80, 0xfc986d, 0x2ad3d9, 
		0xe8a8bb, 0xa7c79c, 0xa5c7cc, 0x7befb7, 0xb7e2e0, 0x85f57b, 0xf5d95b, 
		0xdbdbff, 0xfddcff, 0x6e56bb, 0x226fa8, 0x5b659c, 0x58a10f, 0xe46c52, 
		0x62abe2, 0xc4aa77, 0xb60e74, 0x087983, 0xa95703, 0x2a6efb, 0x427d92
		].map(d3_rgbString);


		function d3_rgbString (value) {
		return d3.rgb(value >> 16, value >> 8 & 0xff, value & 0xff);
		}
		
		
		
		function draw_cluster_plot()
		{
			d3.select("#card_cluster_plot").style("display", "block")
			
			if (!first_plots)
			{
				d3.select("#clustering").select("svg").remove();	
			}
			
			else
			{
				first_plots = false;
			}

			
			var cur_clustering = new Array();

			for (var i=0; i<nrow; i++)
			{
				
				
				cur_clustering[i] = new Array();
				
				cur_clustering[i][0] = Number(dimensions[i][1+2*dim_id]);
				cur_clustering[i][1] = Number(dimensions[i][1+2*dim_id+1]);
				cur_clustering[i][2] = Number(clusterings[i][dim_id]);
				cur_clustering[i][3] = i;
			}
			
		
			
			cur_clustering.sort(function (a,b){ return a[2] - b[2] });
			
			
			
			
			
			
			
			var svg_clustering = d3.select("#clustering")	
			.append("svg")
			.attr("width", clustering_width)
			.attr("height", clustering_width)



			var legend_str = 'translate(' + legend_size + ',0)';
			var g = svg_clustering.append('g')
			.attr('transform', legend_str);


			var legend_font_size = (font_size*2)/3 + "px";
			var legend_trans = 'translate(' + smaller*0.007 + ',' + smaller*0.007 + ')';
			var colorLegendG = svg_clustering.append('g')
			.attr('transform', legend_trans)
			.style("font-size", legend_font_size);


			const colorScale = d3.scaleOrdinal()
			
			.range(d3_category437);

			
			var legend_circle_size = smaller * 0.002;
			const colorLegend = d3.legendColor()
			.scale(colorScale)
			.shape('circle')
			.shapeRadius(legend_circle_size);

			
			var cur_dom = dom_arr[dim_id] * (11/10);
										
			var cur_x = d3.scaleLinear()
							.domain([-cur_dom, cur_dom])
							.range([0, plot_size]);
			
			
			var dots = g.selectAll("circle")
			.data(cur_clustering).enter()
			.append("circle")
			.attr("id", function(d, i) {return d[3];})
			.attr("cx", function(d) {return cur_x(d[0])})
			.attr("cy", function(d) {return cur_x(-d[1])})
			.attr("r", cell_size)
			.attr("fill", function(d) {
			return colorScale(d[2])})
			

			colorLegendG.call(colorLegend)
			.selectAll('.cell text')
			.attr('dy', '0.005em');
			
			
			
			var lasso_start = function() {
					
				if (!cp_window_tf)
					lasso.items()				
			};
			
			
			var lasso_draw = function() {

			};
			
			
			
			
			var lasso_end = function() {
				

				if (selected_cp.length != 0)
				{
					lasso_cp.classed("selected",false);			
					lasso_cp = new Array();
					selected_cp = new Array();
					
				}
				
				lasso.selectedItems()
					.classed("selected",true);
				
				
				lasso_cp = lasso.selectedItems();
				
				
				selected_cp = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
				
				
				
				if (!cp_window_tf)
				{	
				
					var bounding_cp = d3.select("#clustering")["_groups"][0][0].getBoundingClientRect();
					
					d3.select('body')
						.append('div')

						.attr("id", "cp_window")
						
						.style('width', ep_size*1.5 + "px")
						
						.style('position', 'absolute')	
						.style('margin', '0 auto')
						.style('left', bounding_cp.left + 'px')
						.style('top', $(document).scrollTop() + bounding_cp.top + bounding_cp.height + 'px')
						.style('display', 'block')
						.style('background-color', '#e2e2e2')
						.raise()
						.append('ol')

						.attr("class", "col-xl-12")
						.attr("id", "cp_buttons")
					
						.style('position', 'absolute')
						.style('margin', '0 auto')						
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "window_removal")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Window Removal")	
						.on("click", function() {
							
							
							if (selected_cp.length != 0)
							{
								lasso_cp.classed("selected",false);			
								lasso_cp = new Array();
								selected_cp = new Array();
								
							}
							
							
							
							d3.select("#cp_window").remove();
							
							d3.select("#cluster_degs").remove();
							
							
							cp_window_tf = false;
							
						})
						
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "lasso_cancel_cp")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Lasso Cancel")	
						.on("click", function() {
							
							if (selected_cp.length != 0)
							{
								lasso_cp.classed("selected",false);			
								lasso_cp = new Array();
								selected_cp = new Array();
								
							}
							
							
							alert("Cancel Complete.");
						})	
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "done_cp")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Done")	
						.on("click", function() {
							
							
							if (selected_cp.length > 2)
							{
							
								d3.select('body')
									.append('div')
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')		
							
									.style('top', $(document).scrollTop() + height/2 + 'px')
									
								
								
								menu_svgs = new Array();
								added_degs = new Array();
								
								menu_size = 16;
								space_size = 10;
								text_size = font_size;
								menu_width = plot_size*2 + space_size*(Math.sqrt(menu_size)-1) + 'px';
								menu_height = (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
								
								var bounding_cp_window = d3.select("#cp_window")["_groups"][0][0].getBoundingClientRect();
								
								d3.select('body')
									.append('div')
									
									.attr('id', 'cluster_degs')
									.style('width', menu_width)
									.style('height', menu_height)
									.style("position", "absolute")									
									.style("left", bounding_cp_window.left + "px")					
									.style("top", $(document).scrollTop() + bounding_cp_window.top + bounding_cp_window.height + "px")
									.style('display', 'block')
								
									.style('background-color', '#f2f2f2')
									.raise()
								
								
							
						
						
								var cell_ids_string = "";
								for (var i=0; i<selected_cp.length; i++)
								{
									if (i==(selected_cp.length-1))
										cell_ids_string = cell_ids_string + selected_cp[i];
									else
										cell_ids_string = cell_ids_string + selected_cp[i] + "_";
								}
								
								var gene_cp = " ";
								
								
								var gene_label = document.getElementById("fd").value + "," + document.getElementById("ld").value + 
								"," + rds_name + "," + dim_id + "," + gene_cp + "," + cell_ids_string;
								
								
							
								
								console.time("others.r time:");	
					  
								$.ajax({
									
									async: true,
									type: "POST",
									url: "../rscripts/others.r",
									data: gene_label,
									contentType: "application/json",
									

									success: function(response){


										console.timeEnd("others.r time:");

										console.log("others.r finish")
										
										
										
										
										
										
										others2 = response.split(" ");
										
										if (others2=="")
											others2 = new Array();
										
										
		
										var others2_string;
										
										if (others2.length==0)
										{
											others2_string = "No gene."
										}
										else
										{
											others2_string = "";
											
											for (var j=0; j<others2.length; j++)
											{
												if (j==(others2.length-1))
													others2_string = others2_string + others2[j];
												else
													others2_string = others2_string + others2[j] + " ";
											}
										}
														
										var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
										menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
										
										d3.select("#cluster_degs")
											.style("height", menu_height)
										
										
										
										var degs_width = plot_size*2 - 30 + 'px';
										
										var degs = d3.select("#cluster_degs")
										.append('ol')
										.attr('class', 'breadcrumb mb-4')
										
										
											.append('span')
											
											.html(others2_string)
											.style("display", "block")
											.style("width", degs_width)
											.style("word-wrap", "break-word")
										
										
										if (others2.length!=0)
										{

											
											var degs_string2 = "";
												
												
											for (var i=0; i<menu_size; i++)
											{
												if (others2.length>i)
												{
												
													if ((i == (menu_size-1)) || (i == (others2.length-1)))
													{
														degs_string2 += others2[i];
													}
													
													else
													{
														degs_string2 = degs_string2 + others2[i] + "_";
													}
												}
												
											}
											
											
											
											var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
											"_" + rds_name + "_" + degs_string2;
											
											console.log(degs_string);
											
											console.time("degs.r time:");	
								  
											$.ajax({
												
												async: true,
												type: "POST",
												url: "../rscripts/degs.r",
												data: degs_string,
												contentType: "application/json",
												

												success: function(response){


													console.timeEnd("degs.r time:");

													console.log("degs.r finish")

													d3.select("#cluster_degs")
													.append("input")
													.attr("id", "add_degs_button")
													.attr("type", "button")
													.attr("value", "Add genes to the cirlce heatmap")
													.style("display", "block")
													.style("margin", "0 auto")
													.on("click", function() {
														
														
														
														
														var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
														var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
														
														
														
														d3.select("#cluster_degs")
															.append('div')											
															.attr('class', 'loader')
															.style('position', 'absolute')
														
															.style('left', menu_loader_width)
															.style('top', menu_loader_height)
															.raise();
														
													
														
														added_markers_list = new Array();
														
														for (var i=0; i<added_degs.length; i++)
														{
															added_markers_list[i] = added_degs[i];
														}
														
														added_degs = new Array();
														
														add_degs();
													})
											
											
													for (var i=0; i<menu_size; i++)
													{
														
														if (others2.length>i)
														{
															
															var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
															+ document.getElementById("ld").value + "/" + others2[i] + "_expression.csv";
												
														
															var req_ex = new XMLHttpRequest();
															req_ex.open("GET", ex_path, false); 
															req_ex.send(null);

															expressions[others2[i]] = req_ex.responseText.split('\n');
															
															
															
															
															
															var cur_ex = expressions[others2[i]];
												
															var ex_max = Number.MIN_VALUE;
                                                            var ex_min = Number.MAX_VALUE;
															
															var cur_ex_temp = new Array();
									
															for (var j=0; j<nrow; j++)
															{		
																var cur_value = Number(cur_ex[j+1]);
																
																cur_ex_temp[j] = cur_value;
																
																if (cur_value > ex_max)
																{
																	ex_max = cur_value;
																}
                                                                
                                                                if (cur_value < ex_min)
																{
																	ex_min = cur_value;
																}
															}
															
															ex_maxs[others2[i]] = ex_max;
                                                            ex_mins[others2[i]] = ex_min;
															
															
															
															sorted_indices[others2[i]] = new Array();
												
															var cur_indices = sorted_indices[others2[i]];
															
															for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
															cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
														
														
															
															reverse_sorted_indices[others2[i]] = new Array();
															
															var cur_reverse_indices = reverse_sorted_indices[others2[i]];
															
															for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
															cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
														
														
														
															ex_colors[others2[i]] = new Array();
															var cur_color = ex_colors[others2[i]];
															
															
															for (var j = 0; j < nrow; j++)
															{
																var ge = Number(cur_ex[cur_indices[j]+1]);
                                                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
															   
																cur_color[j] = new Array();
																
																for (var k = 0; k < 3; k++)
																{
																  
																   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
																}
															   
															}
															
													
												
														
															
															var deg_svg = d3.select("#cluster_degs")
																.append('svg')
																.attr("id", others2[i] + "deg")
																.attr("width", plot_size/2)
																.attr("height", plot_size/2+text_size)
																
																.style('background-color', '#f2f2f2')
																.on("click", function() {
																	var gene_string = this.textContent;
																	var d3_id = '#' + gene_string + "deg";
																	var border_str = border_size + "px solid #3b5998"
																	
																	var di = added_degs.indexOf(gene_string);
																	if (di==-1)
																	{	
																		added_degs[added_degs.length] = gene_string;
																		d3.select(d3_id).style("border", border_str);
																	}
																	else
																	{
																		added_degs.splice(di, 1);
																		d3.select(d3_id).style("border", "none");
																	}
																})
																
															menu_svgs[menu_svgs.length] = deg_svg;
															
															
															
															
															var small_font_size_str = (font_size*2)/3 + "px";
															deg_svg.append("text")
																.attr("x", (plot_size / 4))             								
																.attr("y", (text_size*2)/3)
																.attr("text-anchor", "middle")  														 
																.style("font-size", small_font_size_str)  
																.text(others2[i])
															



															var cur_xy = new Array();
										
															var cur_indices = sorted_indices[others2[i]];
															
															
															
															
															
															for (var j=0; j<nrow; j++)
															{
																var cur_index = dimensions[cur_indices[j]];
																
																cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
															}
															
															
															
														
															
															
															
															var mep_dots_data = deg_svg
															.selectAll()				
															.data(cur_xy).enter()
															.append("circle")
															.attr("id", function(d, i) {return i;})
															.attr("cx", function(d) {return x4(d[0])})
															.attr("cy", function(d) {return x4(-d[1])})			
															.attr("r", cell_size/2)
															
															
															mep_dots_data
																.data(ex_colors[others2[i]])
																.attr("fill", function(d) {
																return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
															
															
															
															
														}
														
													}
													
													if (others2.length > menu_size)
													{
														
														d3.select("#cluster_degs")
															.append("input")
															.attr("id", "more_button")
															.attr("type", "button")
															.attr("value", "More")
															.style("display", "block")
															.style("margin", "0 auto")
															.on("click", function() {
																more();
															})
													
													
														others2_index = menu_size;
														
														
														
													
														
														lasso_cp.classed("selected",false);			
														lasso_cp = new Array();
														selected_cp = new Array();
														
														d3.select('.loader').remove();
													}
													
													
													else
													{
					
												
														lasso_cp.classed("selected",false);			
														lasso_cp = new Array();
														selected_cp = new Array();
														
														d3.select('.loader').remove();
													}
												}
											});
										}
										
										
							
										
										else
										{
						
											lasso_cp.classed("selected",false);			
											lasso_cp = new Array();
											selected_cp = new Array();
											
											
											
											d3.select('.loader').remove();
											
											
										}
			
										
									}
								});
								
								
							}
							
							else
							{
								alert("Please select cells befor Done.");
							}
							
							
						})
						
					cp_window_tf = true;
				}


			};
			
			
			

			
			var lasso = d3.lasso()
			.closePathSelect(true)
			.closePathDistance(100)
			.items(dots)					
			.targetArea(svg_clustering)
			.on("start",lasso_start)
			.on("draw",lasso_draw)
			.on("end",lasso_end);
		
			// svg_clustering.call(lasso);
		}
		
		
		
		function highlight()
		{
			var highs = new Array();
			
			for (var i=0; i<markers_on.length; i++)
			{

				
				var morg;
				
				if (cur_groups.includes(markers_on[i]))
				{
					morg = false;
				}
				else
					morg = true;
				
				
				
				
				highs[i] = new Array();
				
				highs[i][0] = dim_id*rec_width;
				
				
				if (morg)
				{
					highs[i][1] = (1+cur_groups.length+cur_markers.indexOf(markers_on[i]))*rec_height;
				}
				else
				{
					highs[i][1] = (1+cur_groups.indexOf(markers_on[i]))*rec_height;
				}
		
			}
			
			
			
			svg.selectAll()
				.data(highs)
				.enter()
				.append("rect")
				.attr("id", "highlight")
				.attr("x", function(d) {return d[0]})
				.attr("y", function(d) {return d[1]})
				.attr("width", rec_width)
				.attr("height", rec_height)				
			
				.attr("fill", "none")
				.attr("stroke", '#ff0000')
				.attr("stroke-width", hct*2)
			
		}
		
		
		
		
		function draw_heatmap()
		{
			

			if (!first_add)
			{
				d3.select("#heatmap").select("svg").remove();
				
			
			}
			
			
			else
			{
				tooltip = d3.select("#heatmap")
				.append("div")
				.style("opacity", 0)
				.attr("class", "tooltip")
				.style("background-color", "white")
				.style("border", "solid")
				.style("border-width", "2px")
				.style("border-radius", "5px")
				.style("padding", "5px")
				.style("font-size", font_size_str)

				mouseover = function(d) {
					tooltip.style("opacity", 1)
				}
				mousemove = function(d) {
					tooltip
					  .html(d.circles)
					  .style("left", (d3.mouse(this)[0]+heatmap_margin.left) + "px")
					  .style("top", (d3.mouse(this)[1]+heatmap_margin.top) + "px")
				}
				mouseleave = function(d) {
					tooltip.style("opacity", 0)
				}
				
				
				tml = d3.select("#heatmap")
				.append("div")
				.style("opacity", 0)
				.attr("class", "tooltip")
				.attr("id", "tooltip_total")
				.style("background-color", "white")
				.style("border", "solid")
				.style("border-width", "2px")
				.style("border-radius", "5px")
				.style("padding", "5px")
				.style("font-size", font_size_str)
				// .raise();
				
				
				
				
				first_add = false;
			}
			
			

		
			
			

			
			
			var heatmap_height = rec_height * y_length;
			
			
			
  
			svg = d3.select("#heatmap")
				.append("svg")
					.attr("width", heatmap_width + heatmap_margin.left + heatmap_margin.right)
					.attr("height", heatmap_height + heatmap_margin.top + heatmap_margin.bottom)  
				.append("g")
					.attr("transform",
							"translate(" + heatmap_margin.left + "," + heatmap_margin.top + ")");
			
			
			var x_names = new Array();	
			
			
			for (var i=0; i<n_dims; i++)
			{
				x_names[i] = String(fd_num + i);
			}
			
			var y_names = new Array();
			
			
			
			for (var i=0; i<cur_markers.length; i++)
			{
				y_names[i] = cur_markers[cur_markers.length-1-i]; 
			}
			
			for (var i=0; i<cur_groups.length; i++)
			{
				y_names[cur_markers.length+i] = cur_groups[cur_groups.length-1-i];
			}
			
			y_names[y_names.length] = "Total";
			
			
			
			

			var x_axis = d3.scaleBand()
				.range([0, heatmap_width])
				.domain(x_names)
				.padding(0.01);
			svg.append("g")
				.attr("id", "xaxis")
				.attr("class", "x axis")
				.style("font-size", font_size_str)
				.call(d3.axisTop(x_axis))
				
				
			var y_axis = d3.scaleBand()
				.range([heatmap_height, 0])
				.domain(y_names)
				.padding(0.01);
			svg.append("g")
				.attr("id", "yaxis")
				.attr("class", "y axis")
				.style("font-size", font_size_str)
				.call(d3.axisLeft(y_axis))
				
			
			
			  
			  
			
			
			 
			 
			svg.selectAll()
				.data(heatmap_data, function(d) {return d.dim+':'+d.gene;})
				.enter()
				.append("rect")
				.attr("x", function(d) {return x_axis(d.dim)})
				.attr("y", function(d) {return y_axis(d.gene)})
				.attr("width", x_axis.bandwidth())
				.attr("height", y_axis.bandwidth())

				// .style("fill", function(d) {return colorScales[d.gene](d.circles)})
				.style("fill", function(d) {return d.color})
				.style("stroke", "black")
				.style("stroke-width", hct/2)
				.on("mouseover", mouseover)
				.on("mousemove", mousemove)
				.on("mouseleave", mouseleave)
			
			
			
			
			for (var i=0; i<markers_on.length; i++)
			{
				d3.select('#yaxis')
				.selectAll('text')
				.filter(function(x) {return x == markers_on[i];})
				.attr('style', "font-weight: bold;");
			}
			
			
			if (selected_dim!="empty")
			{
			
				d3.select('#xaxis')
				.selectAll('text')
				.filter(function(x) {return x == selected_dim;})
				.attr('style', "font-weight: bold;");
				
				
				if (markers_on.length>0)
				{
					
					highlight();
					
				}
			}
			
			
			
			
			
			
			d3.select('#yaxis')
			.selectAll('.tick')
			.on('click', function(d)
			{
			
				
				var mi = cur_markers.indexOf(d);
				var gi = cur_groups.indexOf(d);
				var oi = markers_on.indexOf(d);
				
				if ((mi!=-1 || gi!=-1) && oi==-1)
				{
					d3.select('#yaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: bold;");
					
					markers_on[markers_on.length] = d;
					
					if (dim_id!=-1)
					{
						d3.selectAll('#highlight').remove();						
						highlight();
					}
					
					if (!first_plots)
					{
						am = new Array();
						am[0] = d;
						
						draw_markers_plots();
					}
				}
				
				else if ((mi!=-1 || gi!=-1) && oi!=-1)
				{
					if (lasso_gene==d && filtering_on)
					{
                        remove_filtering_windows();
                    
						d3.select("#plot_size_slider").style('display', 'block');
						d3.select("#stop_plot_size_change").style('display', 'none');
					}
                    
                    
                    d3.select('#yaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: regular;");
					
					markers_on.splice(oi, 1);
					
					
					if (dim_id!=-1)
					{
						d3.selectAll('#highlight').remove();
						highlight();
					}
					
					if (!first_plots)
					{
						rem = new Array();
						rem[0] = d;
						
							
						draw_markers_plots();
					}
				}	
				
			
			})
			.on("mouseover", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{
					tml.style("opacity", 1);
					
					
							
				}
			})
			.on("mousemove", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{

					var total_string = total_markers[0];
					
					for (var i=1; i<total_markers.length; i++)
					{
						
						total_string += ", " + total_markers[i];
					}
					
					tml
					.html(total_string)
					.style("left", (d3.mouse(this)[0]+heatmap_margin.left) + "px")						
					.style("top", (d3.mouse(this)[1]+heatmap_margin.top) + "px")
		
				}
			})
			.on("mouseleave", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{
					tml.style("opacity", 0);
				
				}
			})
			
			
			
			d3.select('#xaxis')
			.selectAll('.tick')
			.on('click', function(d)
			{
				
				
				
				if (selected_dim!="empty" && selected_dim!=d)
				{
					d3.select('#xaxis')
					.selectAll('text')
					.filter(function(x) {return x == selected_dim;})
					.attr('style', "font-weight: regular;");
				}
				
				if (selected_dim!=d)
				{
					d3.select('#xaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: bold;");
					
					
					
					if (selected_dim=="empty")
					{
						am = new Array();
						
						for (var i=0; i<markers_on.length; i++)
						{
							am[i] = markers_on[i];
						}
					}
					
					else
					{
						dcm = new Array();
						for (var i=0; i<markers_on.length; i++)
						{
							dcm[i] = markers_on[i];
						}
					}
					
					
					
					selected_dim = d;
					
					var selected_dim2 = Number(d);
					
					dim_id = selected_dim2-fd_num;
					
					
					if (markers_on.length>0)
					{
						d3.selectAll('#highlight').remove();
						highlight();
					}
					
					
					
					
					draw_cluster_plot();
					
					
					
					
					
					draw_markers_plots();
					

				}

			});
			
			
			

			
			
			for (var i=0; i<cur_groups.length; i++)
			{
		
				var cur_group_name = cur_groups[i];

				
				var cur_diff = path_diff_dom[cur_group_name];
				var cur_inter = path_inter_dom[cur_group_name];
				
				var cur_row_size = row_sizes[cur_group_name] * (11/10);
				
				var cur_scale_x = d3.scaleLinear()
									.domain([-cur_row_size, cur_row_size])
									.range([0, rec_width]);
									
				var cur_scale_y = d3.scaleLinear()
									.domain([-cur_row_size, cur_row_size])
									.range([0, rec_height]);
				
		
				for (var j=0; j<n_dims; j++)
				{

					var cur_dim_inter = cur_inter[j];
					
					var cur_inter_len = cur_dim_inter.length;

					for (var l=0; l<cur_inter_len; l++)
					{
						
						var cur_hull = cur_dim_inter[l];
						
						var scaled_hull = new Array();
						
						for (var k=0; k<cur_hull.length; k++)
						{
							scaled_hull[k] = [cur_scale_x(cur_hull[k][0]) + rec_width*j, cur_scale_y(cur_hull[k][1]) + rec_height*(1+i)];
						}
						
						
						var cur_id = "#" + cur_group_name + j + "inter" + l;

						
						svg
							.append("path")
							.attr("id", cur_id)
							.style("fill", "none")

                            .style("stroke", "#be05fc")

							.style("stroke-width", hct)
			
							.attr("d", line(scaled_hull));

					}
					
					var cur_dim_diff = cur_diff[j];
					
					var cur_diff_len = cur_dim_diff.length;

					for (var l=0; l<cur_diff_len; l++)
					{
						
						var cur_hull = cur_dim_diff[l];
						
						var scaled_hull = new Array();
						
						for (var k=0; k<cur_hull.length; k++)
						{
							scaled_hull[k] = [cur_scale_x(cur_hull[k][0]) + rec_width*j, cur_scale_y(cur_hull[k][1]) + rec_height*(1+i)];
						}
						
						
						var cur_id = "#" + cur_group_name + j + "diff" + l;
						
 
						
						
						svg
							.append("path")
							.attr("id", cur_id)
							.style("fill", "none")
                            .style("stroke", "black")
							.style("stroke-width", hct)
							.attr("d", line(scaled_hull));

					}
				}
					
			}
			
			
			for (var i=0; i<cur_markers.length; i++)
			{
				

				
				var cur_marker = hulls_dom[cur_markers[i]];
				
		

				var cur_row_size = row_sizes[cur_markers[i]] * (11/10);
				
				var cur_scale_x = d3.scaleLinear()
									.domain([-cur_row_size, cur_row_size])
									.range([0, rec_width]);
									
				var cur_scale_y = d3.scaleLinear()
									.domain([-cur_row_size, cur_row_size])
									.range([0, rec_height]);					
			
				for (var j=0; j<n_dims; j++)
				{
	
					

					var cur_hulls = cur_marker[j];
					
					for (var l=0; l<cur_hulls.length; l++)
					{	
						
						var cur_hull = cur_hulls[l];
						
						
	
					
						var scaled_hull = new Array();
						
						for (var k=0; k<cur_hull.length; k++)
						{
									
							scaled_hull[k] = [cur_scale_x(cur_hull[k][0]) + rec_width*j, cur_scale_y(cur_hull[k][1]) + rec_height*(1+cur_groups.length+i)];
						}
						
						
						var cur_id = "#" + cur_markers[i] + j;
						
						
		
                        
						svg
							.append("path")
							.attr("id", cur_id)
							.style("fill", "none")
	
                            .style("stroke", "black")
							.style("stroke-width", hct)
							.attr("d", line(scaled_hull));
							
				
					}
				}
					
					
					
			
			}

			
		
				
			

			var smaller_wh = rec_width;
			
			if (rec_width > rec_height)
				smaller_wh = rec_height;
			
			var stride = smaller_wh * 0.1;

			var largest_arr = new Array();
			
			largest_arr[0] = [largest_dim["Total"]*rec_width + stride, stride];
			
			
			for (var i=0; i<cur_groups.length; i++)
			{
				largest_arr[largest_arr.length] = [largest_dim[cur_groups[i]]*rec_width + stride, (1+i)*rec_height + stride];
			}
			

			
			
			svg.selectAll()
				.data(largest_arr)
				.enter()
				.append("rect")
				.attr("id", "largest_dims")
				.attr("x", function(d) {return d[0]})
				.attr("y", function(d) {return d[1]})
				.attr("width", (rec_width - stride*2))
				.attr("height", (rec_height - stride*2))				
				
				.attr("fill", "none")

                .attr("stroke", "black")
				.attr("stroke-width", hct*2)

			
				
			new_markers = new Array();
			old_markers = new Array();
			
			
            
            new_groups = new Array();
            old_groups = new Array();

			
			
			
			console.log("draw_heatmap finish");
			
			
			
			highlight();
			
			
			
			
			
			

			d3.select('.loader').remove();	
			
		}
		
		
		
		
		
	
		var width = $(window).width();
		var height = $(window).height();
		console.log(width, height);
		
		smaller = 1000000;
		if (width > height)
		{
			smaller = height;
		}
		else
			smaller = width;
		
		
		
		var slider = document.getElementById("slider");

		var pointer_size = smaller * 0.02;

		
		slider_height = pointer_size / 4;
		shs = String(slider_height) + 'px';
		d3.select('.slider').style('height', shs);
		
		
		
		
		var slider_vertical = document.getElementById("plot_size_slider");
		var style_vertical = document.querySelector('[data="test_vertical"]');
		style_vertical.innerHTML = ".slider_vertical::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
		
		
		d3.select('.slider_vertical').style('height', shs);
		
		var slider_width = smaller/3;
		var sws = String(slider_width) + 'px';
		d3.select('.slider_vertical').style('width', sws);
		
		
		
		var svm = smaller*0.08 + 'px';
		d3.select('.slider_vertical').style('margin-top', svm);
		
		
		var vsb_len = smaller/3 + smaller*0.08 + 'px';
		d3.select('#vsb').style('height', vsb_len);
		
		
		font_size = smaller * 0.015;
		font_size_str = font_size + "px";
		
		border_size = font_size/5;
		
		d3.selectAll('.texts').style('font-size', font_size_str);
		
		
		
		
		
		
		document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;
		
		
		
		$(window).resize(function() {
			if(this.resizeTO) clearTimeout(this.resizeTO);
			this.resizeTO = setTimeout(function() {
				$(this).trigger('resizeEnd');
			}, 500);
		});

		$(window).bind('resizeEnd', function() {
			
			
			width = $(this).width();
			height = $(this).height();
			console.log(width, height);
			
			
	
			
			
			smaller = 1000000;
			if (width > height)
			{
				smaller = height;
			}
			else
				smaller = width;
			
			
			
			slider = document.getElementById("slider");

			pointer_size = smaller * 0.02;
		
			font_size = smaller * 0.015;
			font_size_str = font_size + "px";
			
			border_size = font_size/5;
			
			d3.selectAll('.texts').style('font-size', font_size_str);
			
			d3.select('.tooltip').style('font-size', font_size_str);
			
			slider_height = pointer_size / 4;
			shs = String(slider_height) + 'px';
			d3.select('.slider').style('height', shs);
			
			
			slider_vertical = document.getElementById("plot_size_slider");
			style_vertical = document.querySelector('[data="test_vertical"]');
			style_vertical.innerHTML = ".slider_vertical::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
			
			
			d3.select('.slider_vertical').style('height', shs);
			
			
			slider_width = smaller/3;
			sws = String(slider_width) + 'px';
			d3.select('.slider_vertical').style('width', sws);
			
			
			svm = smaller*0.08 + 'px';
			d3.select('.slider_vertical').style('margin-top', svm);
			
			vsb_len = smaller/3 + smaller*0.08 + 'px';
			d3.select('#vsb').style('height', vsb_len);
			
			

			
			
			
			margin_size = font_size*2;
			hct = smaller * 0.001;
			
			
			heatmap_margin = {top: margin_size, right: margin_size, bottom: margin_size, left: margin_size*7};
            
            hist_margin = {top: 10, right: 10, bottom: margin_size, left: margin_size*1.5};
			
			outer_width = d3.select('.outer')["_groups"][0][0].getBoundingClientRect().width;
			
			heatmap_width = outer_width - heatmap_margin.left - heatmap_margin.right;
			
			

			
			
			
			
					
			clustering_width = d3.select('#clustering')["_groups"][0][0].getBoundingClientRect().width;
						
			legend_size = width*0.015;	

			
			if (clustering_width > width*0.5)
			{
				plot_size = smaller*0.5;
				clustering_width = plot_size + legend_size;
			}
			else						
				plot_size = clustering_width - legend_size;
			
			ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
			ep_cell_size = ep_size*0.002;
			
			cell_size = smaller * 0.001;
			
	
				
			if (!first_add)
			{
		
				y_length = 1 + cur_groups.length + cur_markers.length;
			
			
				unit_height = height * 0.05;
				
				var cur_height = y_length*unit_height;
				var half_height = height/2;
				
				
				
				if (cur_height > half_height)
				{
					rec_height = half_height/y_length;
				}
				else
					rec_height = unit_height;
				
				if ((unit_height * n_dims) > heatmap_width)
				{
					rec_width = heatmap_width / n_dims;
				}
				else
				{
					rec_width = unit_height;
					heatmap_width = unit_height * n_dims;
				}

				
				draw_heatmap();
				
					
				
				
				if (dim_id!=-1)
				{
					draw_cluster_plot();
				
					if (markers_on.length > 0)
					{
						rsm = new Array();
						
						
						for (var i=0; i<groups.length; i++)
						{
							rsm[rsm.length] = groups[i];
						}
						
						for (var i=0; i<markers.length; i++)
						{
							rsm[rsm.length] = markers[i];
						}
						
						
						
						draw_markers_plots();
					}
				}
				
				
				
			}
			
			if (!first_ani)
			{
				renderer.setSize(plot_size, plot_size);
				uniforms[ "cell_size" ].value = cell_size;	
				if (cur_dim<(n_dims-1))
				{
					
					renderer.render(scene, camera);				
				}
			}
			
		});
		
		
		
		function getLinePoints(curvePoints, numPoints){
			path_ani.attr('d', line(curvePoints));
			var svgLine = path_ani.node();
			var lineLength = svgLine.getTotalLength();
			var interval;
			if (numPoints === 1) {
				interval = 0;
			} else {
				interval = lineLength / (numPoints - 1);
			}
			return d3.range(numPoints).map(function (d) {
			var point = svgLine.getPointAtLength(d * interval);
			return [ point.x, point.y ];
			});
		};
		
		
		

		
		
		function calculate_animation () {

			
			if (new_marker_ani != "")
			{
				animations[new_marker_ani] = new Array();
				
				
				for (var i=0; i<n_dims; i++)
				{
					animations[new_marker_ani][i] = getLinePoints(hulls[new_marker_ani][i], ndots)
					
					
				}

			}
			
			
			var cur_hulls = animations[cur_marker_ani];
			
			marker_tex_data = new Array();
					
			for (var i=0; i<n_dims; i++)
			{
				var cur_dim_hulls = cur_hulls[i];
				
				for (var j=0; j<ndots; j++)
				{
					var cur_dot = cur_dim_hulls[j];
					
					marker_tex_data[marker_tex_data.length] = cur_dot[0];
					marker_tex_data[marker_tex_data.length] = cur_dot[1];
				}
				
			}
		
			
			
			
			mw = ndots/2;
		
			mh = n_dims;
		   
			
			markerTex = new THREE.DataTexture(new Float32Array(marker_tex_data), mw, mh, THREE.RGBAGormat, THREE.FloatType);
			markerTex.minFilter = THREE.NearestFilter;
			markerTex.magFilter = THREE.NearestFilter;
			markerTex.needsUpdate = true;

			
			
	
			
			var members = cur_marker_ani.split("_");
			var morg = true;
			
			if (members.length > 1)
				morg = false;
			
			
			ex_tex_data = new Array();
			
			
			ew = 1;
			eh = Math.ceil(nrow/4);
			
			
			
			if (morg)
			{
			
				for (var j=0; j<nrow; j++)
				{
				
					var cur_value = Number(expressions[cur_marker_ani][j+1]);
					
					ex_tex_data[ex_tex_data.length] = cur_value;
	
				}
			
				
			}	
			
			else
			{
				var cur_ids = cell_ids[cur_marker_ani];
				
				for (var j=0; j<nrow; j++)
				{
					if (cur_ids.indexOf(j) == -1)
						ex_tex_data[j] = 0.0;
					else
						ex_tex_data[j] = 1.0;
					
					
	
				}
			}
				
				
				
			if (nrow%4!=0)
			{
				for (var j=0; j<(eh*4-nrow); j++)
				{
					ex_tex_data[ex_tex_data.length] = 0.0;
					
				}
			}
			
			
			
			exTex = new THREE.DataTexture(new Float32Array(ex_tex_data), ew, eh, THREE.RGBAGormat, THREE.FloatType);
			exTex.minFilter = THREE.NearestFilter;
			exTex.magFilter = THREE.NearestFilter;
			exTex.needsUpdate = true;
			
			
			uniforms["expression"].value = exTex;
			uniforms["ew"].value = ew;
			uniforms["eh"].value = eh;
			
			if (morg)
            {
				uniforms["e_max"].value = ex_maxs[cur_marker_ani];
                uniforms["e_min"].value = ex_mins[cur_marker_ani];
			}
            else
            {
				uniforms["e_max"].value = 1.0;
                uniforms["e_min"].value = 1.0;
			}
			
			
	
			
			uniforms["marker"].value = markerTex;
			uniforms["mw"].value = mw;
			uniforms["mh"].value = mh;
			
			

			d3.select("#card_animation").style("display", "block")
			
  
			if (cur_dim<(n_dims-1))		
			{
				
				renderer.render(scene, camera);
			}
		
			
			var cms = "";
			
			if (cur_marker_ani != "")
				cms = "<span style='color: red;'>" + cur_marker_ani + " </span>"
			
			
			document.querySelector("#current_markers").innerHTML = cms;
			
			
		
			
			
			new_marker_ani = "";
			old_marker_ani = "";
		}




		
		function intersect(a, b) {
			var tmp={}, res=[];
			for(var i=0;i<a.length;i++) tmp[a[i]]=1;
			for(var i=0;i<b.length;i++) if(tmp[b[i]]) res.push(b[i]);
			return res;
		}
		
		const pointInPolygon = function (polygon, point) {

			let odd = false;
	
			for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {

				if (((polygon[i][1] > point[1]) !== (polygon[j][1] > point[1])) 				&& (point[0] < ((polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]))) {

					odd = !odd;
				}
				j = i;

			}

			return odd;
		};
		
		function calculate_overlap()
		{
			console.log("calculate_overlap");
			
			areas_ratio = new Object;
			path_diff = new Object;
			path_inter = new Object;
			
			largest_dim = new Object;
			
			inter_groups = new Object;
			
			
			ones = new Object();
			
			for (var i=0; i<cur_groups.length; i++)
			{
				ones[cur_groups[i]] = new Array();
			}

			
			
			var valid_groups = new Array();
				
			for (var i=0; i<cur_groups.length; i++)
			{
	
				
				var cur_group_name = cur_groups[i];
				
				if (areas[cur_group_name][0]==0)
				{
					areas_ratio[cur_group_name] = new Array();
					path_diff[cur_group_name] = new Array();
					path_inter[cur_group_name] = new Array();
					inter_groups[cur_group_name] = new Array();
					
					largest_dim[cur_group_name] = 0;
					
					
					for (var j=0; j<n_dims; j++)
					{
						areas_ratio[cur_group_name][j] = 0;
						path_diff[cur_group_name][j] = new Array();
						path_inter[cur_group_name][j] = new Array();
						inter_groups[cur_group_name][j] = new Array();
					}
				}
				
				else
				{
	
					
					valid_groups[valid_groups.length] = cur_group_name;
				}
			}
			
			
			
			if (valid_groups.length == 1)
			{

				
				var cur_group_name = valid_groups[0];
				
				areas_ratio[cur_group_name] = new Array();
				path_diff[cur_group_name] = new Array();
				path_inter[cur_group_name] = new Array();
				inter_groups[cur_group_name] = new Array();
				
				var cur_group_hulls = hulls[cur_group_name];
				
				for (var i=0; i<n_dims; i++)
				{							
			
					areas_ratio[cur_group_name][i] = 1.0;
					path_inter[cur_group_name][i] = new Array();
					
					path_diff[cur_group_name][i] = new Array();

					
					inter_groups[cur_group_name][i] = new Array();
					
					largest_dim[cur_group_name] = 0;
					
					var cur_dim_hulls = cur_group_hulls[i];
							
					for (var j=0; j<cur_dim_hulls.length; j++)
					{	

						
						path_diff[cur_group_name][i][j] = new Array();
						
						var cur_hull = cur_dim_hulls[j];
						
						for (var k=0; k<cur_hull.length; k++)
						{
							path_diff[cur_group_name][i][j][k] = [cur_hull[k][0], cur_hull[k][1]];
						}
					}					
				}
			}
			
			else if (valid_groups.length > 1)
			{				
				paths = new Array();
				

				for (var i=0; i<valid_groups.length; i++)
				{
					paths[i] = new Array();
					
					var cur_group_hulls = hulls[valid_groups[i]];
					
					for (var j=0; j<n_dims; j++)
					{
						paths[i][j] = new Array();
						
						var cur_dim_hulls = cur_group_hulls[j];
						
						for (var l=0; l<cur_dim_hulls.length; l++)
						{						
							paths[i][j][l] = new Array();
							
							var cur_hull = cur_dim_hulls[l];
							
							for (var k=0; k<cur_hull.length; k++)
							{
								paths[i][j][l][k] = new Object;
								paths[i][j][l][k].X = cur_hull[k][0];
								paths[i][j][l][k].Y = cur_hull[k][1];
							}

						}
					}
				}
				
				
				
				
				
				

				for (var i=0; i<valid_groups.length; i++)
				{
					var subject = valid_groups[i];
					
					var cur_overlap_groups = overlap_groups[subject];
					
					
					inter_groups[subject] = new Array();

					
					var cur_diff = new Array();
					
					var add_inter_hulls = new Array();
					
					var minus_ratio = new Array();
					
					
					

					
					var cur_group_paths = paths[i];
					
					var pass = false;
					
					for (var j=0; j<n_dims; j++)
					{

						
						var cur_dim_paths = cur_group_paths[j];
						
						cur_diff[j] = new Array();
						
						inter_groups[subject][j] = new Array();
						
						
						for (var l=0; l<cur_dim_paths.length; l++)
						{
					
							
							var cur_path = cur_dim_paths[l];
								
							cur_diff[j][l] = new Array();
									
							for (var k=0; k<cur_path.length; k++)
							{
								cur_diff[j][l][k] = new Object;
								cur_diff[j][l][k].X = cur_path[k].X;
								cur_diff[j][l][k].Y = cur_path[k].Y;
								
				
							}
						
						}
						
						minus_ratio[j] = 0;
					}
					
					
					path_diff[subject] = new Array();
					path_inter[subject] = new Array();
					areas_ratio[subject] = new Array();
					

					for (var j=0; j<valid_groups.length; j++)
					{
						var cur_valid_group = valid_groups[j];
						
						
						
						if (cur_overlap_groups.indexOf(cur_valid_group) != -1)
						{						
							var clip = cur_valid_group;
								
							
							for (var k=0; k<n_dims; k++)
							{
					
								
								var cpr_inter = new ClipperLib.Clipper();
								cpr_inter.AddPaths(paths[i][k], ClipperLib.PolyType.ptSubject, true);
								cpr_inter.AddPaths(paths[j][k], ClipperLib.PolyType.ptClip, true);
								var subject_fillType = ClipperLib.PolyFillType.pftNonZero;
								var clip_fillType = ClipperLib.PolyFillType.pftNonZero;
								var cur_inter = new ClipperLib.Paths();
								cpr_inter.Execute(ClipperLib.ClipType.ctIntersection, cur_inter, subject_fillType, clip_fillType);

								if (cur_inter.length != 0)
								{
					
									
									inter_groups[subject][k][inter_groups[subject][k].length] = cur_valid_group;
									
							
									var cpr = new ClipperLib.Clipper();
									
									cpr.AddPaths(cur_diff[k], ClipperLib.PolyType.ptSubject, true);
									cpr.AddPaths(paths[j][k], ClipperLib.PolyType.ptClip, true);
									
									var subject_fillType = ClipperLib.PolyFillType.pftNonZero;
									var clip_fillType = ClipperLib.PolyFillType.pftNonZero;
							
									cpr.Execute(ClipperLib.ClipType.ctDifference, cur_diff[k], subject_fillType, clip_fillType);
								}
								
								else
								{
									var subject_hulls = hulls[valid_groups[i]][k];
									
									var clip_hulls = hulls[valid_groups[j]][k];
									
									var inter_check = new Array();
									
				
									
									for (var l=0; l<subject_hulls.length; l++)
									{
										for (var m=0; m<clip_hulls.length; m++)
										{
											var subject_hull = subject_hulls[l];
											
											var clip_hull = clip_hulls[m];
											
											var subject_area = Math.abs(d3.polygonArea(subject_hull));
											
											var clip_area = Math.abs(d3.polygonArea(clip_hull));
											
											if (subject_area > clip_area)
											{
												var cur_tf;
												
												
												
												for (var o=0; o<clip_hull.length; o++)
												{
													cur_tf = pointInPolygon(subject_hull, clip_hull[o]);
													
													if (!cur_tf)
														break;
												}
												
												if (cur_tf)
												{
													inter_groups[subject][k][inter_groups[subject][k].length] = cur_valid_group;
													
													add_inter_hulls[add_inter_hulls.length] = [cur_valid_group, k, m];
													
													minus_ratio[k] +=  Math.abs(d3.polygonArea(clip_hull)) / areas[subject][k];
													
				
												}
											}
											
											else if (subject_area < clip_area)
											{
												var cur_tf;
												
												for (var o=0; o<subject_hull.length; o++)
												{
													cur_tf = pointInPolygon(clip_hull, subject_hull[o]);
													
													if (!cur_tf)								
														break;
												}
												
												if (cur_tf)
												{
													inter_groups[subject][k][inter_groups[subject][k].length] = cur_valid_group;
													
													inter_check[inter_check.length] = l;
												}
											}
										}
										
			
									}
									
									if (inter_check.length == subject_hulls.length)
									{
										cur_diff[k] = new Array();
										
							
									}
									
									else if (inter_check.length > 0)
									{
										cur_diff[k] = new Array();
										
							
										
										var count = 0;
										
										for (var l=0; l<subject_hulls.length; l++)
										{
											if (!inter_check.includes(l))
											{
												cur_diff[k][count] = new Array();
						
												
												var subject_hull = subject_hulls[l];
												
												for (var m=0; m<subject_hull.length; m++)
												{
													
													cur_diff[k][count][m] = new Object;
													cur_diff[k][count][m].X = subject_hull[m][0];
													cur_diff[k][count][m].Y = subject_hull[m][1];
												}
												
												count++;
											}
											
											else
											{
												add_inter_hulls[add_inter_hulls.length] = [subject, k, l];
											}
										}
										
										
									}
									
									
								}
							

							}
						}						
					}
					
					
					
					path_diff_dom[subject] = new Array();
					path_inter_dom[subject] = new Array();
					row_sizes[subject] = Number.MIN_VALUE;
					
					
					
					for (var j=0; j<n_dims; j++)
					{
						path_diff[subject][j] = new Array();
						path_inter[subject][j] = new Array();
						
						areas_ratio[subject][j] = 0;
						
						var cur_dim_diff = cur_diff[j];
						
						var cur_dim_len = cur_dim_diff.length;
						
						if (cur_dim_len == 0)
						{							

					
							var cur_dim_hulls = hulls[subject][j];
							
							for (var l=0; l<cur_dim_hulls.length; l++)
							{
								path_inter[subject][j][l] = new Array();
								
								var cur_hull = cur_dim_hulls[l];
								
								for (var k=0; k<cur_hull.length; k++)
								{
									path_inter[subject][j][l][k] = [cur_hull[k][0], cur_hull[k][1]];
								}

							}
						}
						
						else
						{	
							var areas_diff = 0;
							
							for (var k=0; k<cur_dim_len; k++)
							{
								path_diff[subject][j][k] = new Array();
								
								var cur_path = cur_dim_diff[k];

								for (var l=0; l<cur_path.length; l++)
								{
									path_diff[subject][j][k][l] = [cur_path[l].X, cur_path[l].Y];
								}
								
								

								var cur_area = Math.abs(d3.polygonArea(path_diff[subject][j][k]));
								

								
								areas_diff += cur_area;	
							}
							
							areas_ratio[subject][j] = areas_diff / areas[subject][j];
							
							if (areas_ratio[subject][j] > 1)
							{
								console.log("larger than 1")
								console.log(subject);
								console.log(j);
								
								areas_ratio[subject][j] = 1;
							}
							
							var round_area = Math.round(areas_ratio[subject][j]*100);
							

							if (inter_groups[subject][j].length == 0)
							{
								areas_ratio[subject][j] = 1;
								
								path_inter[subject][j] = new Array();
								
			
							}
							
							else
							{	
								if (areas_ratio[subject][j] == 1)
								{
									areas_ratio[subject][j] = 0.99
								}
								
								var cur_union = new ClipperLib.Paths();					
								
								var first_group = -1; 
								
								var first = true;
								
								for (var k=0; k<valid_groups.length; k++)
								{
									var cur_valid_group = valid_groups[k];
									
									if (cur_overlap_groups.indexOf(cur_valid_group) != -1)
									{						
										var clip = cur_valid_group;
											
										if (first_group == -1)
										{
											first_group = k;
											
											continue;
										}
										
										
										var cpr = new ClipperLib.Clipper();
											
										cpr.AddPaths(paths[k][j], ClipperLib.PolyType.ptClip, true);
										
										var subject_fillType = ClipperLib.PolyFillType.pftNonZero;
										var clip_fillType = ClipperLib.PolyFillType.pftNonZero;
										
										
										if (first)
										{
											cpr.AddPaths(paths[first_group][j], ClipperLib.PolyType.ptSubject, true);
										}
										
										else
										{
											cpr.AddPaths(cur_union, ClipperLib.PolyType.ptSubject, true);
										}
										
										cpr.Execute(ClipperLib.ClipType.ctUnion, cur_union, subject_fillType, clip_fillType);
										
										
										if (first)
										{
											first = false;
										}
									}						
								}
								
								
								var cpr = new ClipperLib.Clipper();
								
								cpr.AddPaths(paths[i][j], ClipperLib.PolyType.ptSubject, true);
								
								
								if (first)
								{
									cpr.AddPaths(paths[first_group][j], ClipperLib.PolyType.ptClip, true);
								}
								
								else
								{
									cpr.AddPaths(cur_union, ClipperLib.PolyType.ptClip, true);
								}
															
								var subject_fillType = ClipperLib.PolyFillType.pftNonZero;
								var clip_fillType = ClipperLib.PolyFillType.pftNonZero;
								
								var cur_inter = new ClipperLib.Paths();
								
								cpr.Execute(ClipperLib.ClipType.ctIntersection, cur_inter, subject_fillType, clip_fillType);
								
								
								var cur_inter_len = cur_inter.length;
								
								if (cur_inter_len != 0)
								{
									for (var k=0; k<cur_inter_len; k++)
									{
										path_inter[subject][j][k] = new Array();
										
										var cur_path = cur_inter[k];
										
										for (var l=0; l<cur_path.length; l++)
										{
											path_inter[subject][j][k][l] = [cur_path[l].X, cur_path[l].Y];
										}
									}
								}
							
							}
	
						}

						
						if (inter_groups[subject][j].length != 0)
						{
						
							for (var k=0; k<add_inter_hulls.length; k++)
							{
								
								
								var cur_add = add_inter_hulls[k];
								
								if (cur_add[1] == j)
								{
									console.log(cur_add);
									
									var cur_hull = hulls[cur_add[0]][j][cur_add[2]];
									
									var cur_len = path_inter[subject][j].length;
									
									path_inter[subject][j][cur_len] = new Array();
									
									for(var l=0; l<cur_hull.length; l++)
									{
										path_inter[subject][j][cur_len][l] = [cur_hull[l][0], cur_hull[l][1]];
									}
								}
							}
							
							areas_ratio[subject][j] -= minus_ratio[j];
							
						}	
							
						
						
						
	
						
						
					}	


					
				}
				
				

				
				
				
				
				for (var i=0; i<valid_groups.length; i++)
				{
					var largest_ratio = -1;
					
					for (var j=0; j<n_dims; j++)
					{
						if (areas_ratio[valid_groups[i]][j] > largest_ratio)
						{
							largest_ratio = areas_ratio[valid_groups[i]][j];
							largest_dim[valid_groups[i]] = j;
						}
					}
				}
				
			}
			
			path_diff_dom = new Object();
			path_inter_dom = new Object();
			
			
			for (var i=0; i<cur_groups.length; i++)
			{
				path_diff_dom[cur_groups[i]] = new Array();
				path_inter_dom[cur_groups[i]] = new Array();
				
				
				
				for (var j=0; j<n_dims; j++)
				{

					
					var cur_dom = dom_arr[j] * (11/10);
									
					var cur_one = d3.scaleLinear()
									.domain([-cur_dom, cur_dom])
									.range([-1, 1]);
					
					var mean_x = hulls_mean[cur_groups[i]][j][0];
					var mean_y = hulls_mean[cur_groups[i]][j][1];
					
					
					
					path_diff_dom[cur_groups[i]][j] = new Array();
														
					var cur_dim_diff = path_diff[cur_groups[i]][j];
									
					for (var l=0; l<cur_dim_diff.length; l++)
					{
						var cur_hull = cur_dim_diff[l];	

						var cur_len = cur_hull.length;
						
						if (cur_len > 2)
						{
					
							path_diff_dom[cur_groups[i]][j][l] = new Array();
																							
							for (var k=0; k<cur_hull.length; k++)
							{
								var cur_point = cur_hull[k];
								
								var cur_x = cur_one(cur_point[0] - mean_x);
								
								var cur_y = cur_one(-(cur_point[1] - mean_y));
								
								path_diff_dom[cur_groups[i]][j][l][k] = [cur_x, cur_y];
								
								if (Math.abs(cur_x) > row_sizes[cur_groups[i]])
								{
									row_sizes[cur_groups[i]] = Math.abs(cur_x);
								}

								if (Math.abs(cur_y) > row_sizes[cur_groups[i]])
								{
									row_sizes[cur_groups[i]] = Math.abs(cur_y);
								}														
							}
						}
					}
					
					
					
					path_inter_dom[cur_groups[i]][j] = new Array();
					
					var cur_dim_inter = path_inter[cur_groups[i]][j];
					
					for (var l=0; l<cur_dim_inter.length; l++)
					{
						var cur_hull = cur_dim_inter[l];	

						var cur_len = cur_hull.length;
						
						if (cur_len > 2)
						{
					
							path_inter_dom[cur_groups[i]][j][l] = new Array();
																							
							for (var k=0; k<cur_hull.length; k++)
							{
								var cur_point = cur_hull[k];
								
								var cur_x = cur_one(cur_point[0] - mean_x);
								
								var cur_y = cur_one(-(cur_point[1] - mean_y));
								
								path_inter_dom[cur_groups[i]][j][l][k] = [cur_x, cur_y];
								
								if (Math.abs(cur_x) > row_sizes[cur_groups[i]])
								{
									row_sizes[cur_groups[i]] = Math.abs(cur_x);
								}

								if (Math.abs(cur_y) > row_sizes[cur_groups[i]])
								{
									row_sizes[cur_groups[i]] = Math.abs(cur_y);
								}														
							}
						}
					}
				}
			}
		}
		

		
	
        function calculate_groups()
		{
			
			console.log("calculate_groups");
			
			
			
			if (intersect_tf)
			{
				for (var i=0; i<new_groups.length; i++)
                {                
                    var cur_group_name = new_groups[i];
                    
                    var cur_members = cur_group_name.split("_");
					
					if (cur_members.length!=1)
					{
						var intersect_ids = cell_ids[cur_members[0]];
						
						for (var j=1; j<cur_members.length; j++)
						{
							intersect_ids = intersect(intersect_ids, cell_ids[cur_members[j]]);
						}
						
						cell_ids[cur_group_name] = intersect_ids;
					}
                }
			}
			
		
            
            var valid_groups = new Array();
            
            for (var i=0; i<new_groups.length; i++)
            {
                 var cur_group_name = new_groups[i];
				 
				 var cur_members = cur_group_name.split("_");
                
                if (cell_ids[cur_group_name].length > 2 && cur_members.length!=1)
                {
                    valid_groups[valid_groups.length] = cur_group_name;
                }
            }
            
            
            if (valid_groups.length > 0)
            {
            
                valid_groups_test = valid_groups.length;
                
                var density_string;
				
				
				
				if (lasso_gene == "")
				{
				
					density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
					  + rds_name + "_" + nrow + "_" + n_dims + "_" + valid_groups.length + "_" + density_th + "_";
												
					for (var i=0; i<valid_groups.length; i++)
					{
						var cur_cell_ids = cell_ids[valid_groups[i]];
						
						if (i!=0)
						{
							density_string += " ";
						}
						
						density_string += cur_cell_ids.length;
						
						for (var j=0; j<cur_cell_ids.length; j++)
						{
							density_string = density_string + " " + cur_cell_ids[j];
						}
						
						for (var j=0; j<nrow-cur_cell_ids.length; j++)
						{
							density_string = density_string + " " + 0;
						}
						
					}
                }
				
				else
				{
					density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
					  + rds_name + "_" + nrow + "_" + n_dims + "_" + temp_cell_ids.length + "_" + density_th + "_";
												
					for (var i=0; i<temp_cell_ids.length; i++)
					{
						var cur_cell_ids = temp_cell_ids[i];
						
						if (i!=0)
						{
							density_string += " ";
						}
						
						density_string += cur_cell_ids.length;
						
						for (var j=0; j<cur_cell_ids.length; j++)
						{
							density_string = density_string + " " + cur_cell_ids[j];
						}
						
						for (var j=0; j<nrow-cur_cell_ids.length; j++)
						{
							density_string = density_string + " " + 0;
						}
						
					}
				}

                  
                console.time("density.py time:");	
                            
                $.ajax({
                    async: true,
                
                    url: "density.py",
                    type: 'POST',
                    
                    contentTpye: 'application/json',
                    dataType: 'json',
                
                    data: {'fd_ld': density_string},
                    
                    success: function(response){
                        
                        var endTime2 = new Date().getTime();
                        
                        console.timeEnd("density.py time:");
                        
                        console.log("density.py finish");
                        

                        
                        var filtered_ids_result = response["filtered_ids"];
                           
    
                        

                        for (var i=0; i<valid_groups.length; i++)
                        {
                            var cur_group_name = valid_groups[i];
                            
                            
                         
                            
                            filtered_ids[cur_group_name] = new Array();
							
							
							if (lasso_gene == "")
							{
								filtered_ids[cur_group_name][0] = new Array();
								
								var cur_cell_ids = cell_ids[cur_group_name];
							
								var cur_ids_len = cur_cell_ids.length;
								
								var temp_arr = new Array();
								
								for (var j=0; j<cur_ids_len; j++)
								{
									temp_arr[j] = cur_cell_ids[j];
								}
								
								
								for (var k=0; k<n_dims; k++)
								{                                                                                     																	
									for (var l=0; l<cur_ids_len; l++)
									{
										var cur_id = filtered_ids_result[i*n_dims*nrow + k*nrow + l];
										
										if (cur_id == -1 && temp_arr[l] != -1) 
										{
											temp_arr[l] = -1;
										}
									}
								}
								
								
								
								
								var fc = 0;
								
								for (var j=0; j<cur_ids_len; j++)
								{
									var cur_id = temp_arr[j];
									
									if (temp_arr[j] != -1)
									{
										filtered_ids[cur_group_name][0][fc] = cur_id;
										
										fc++;
									}
								}
							}
							
							else
							{
								for (var m=0; m<temp_cell_ids.length; m++)
								{
									filtered_ids[cur_group_name][m] = new Array();
								
									var cur_cell_ids = temp_cell_ids[m];
								
									var cur_ids_len = cur_cell_ids.length;
									
									var temp_arr = new Array();
									
									for (var j=0; j<cur_ids_len; j++)
									{
										temp_arr[j] = cur_cell_ids[j];
									}
									
									
									for (var k=0; k<n_dims; k++)
									{                                                                                     																	
										for (var l=0; l<cur_ids_len; l++)
										{
											var cur_id = filtered_ids_result[m*n_dims*nrow + k*nrow + l];
											
											if (cur_id == -1 && temp_arr[l] != -1) 
											{
												temp_arr[l] = -1;
											}
										}
									}
									
									
									
									
									var fc = 0;
									
									for (var j=0; j<cur_ids_len; j++)
									{
										var cur_id = temp_arr[j];
										
										if (temp_arr[j] != -1)
										{
											filtered_ids[cur_group_name][m][fc] = cur_id;
											
											fc++;
										}
									}
								}
							}
                            
                            
                            
            
			
                            
                            
                            var cur_ids = cell_ids[cur_group_name];
				
								
							sorted_indices[cur_group_name] = new Array();
							
							var cur_indices = sorted_indices[cur_group_name];
							
							for (var j=0; j<nrow; j++)
							{
								if (cur_ids.indexOf(j) == -1)
								{						
									cur_indices[cur_indices.length] = j;
								}
							}
							
							for (var j=0; j<cur_ids.length; j++)
							{
								cur_indices[cur_indices.length] = cur_ids[j];
							}
							
							
							
							
							reverse_sorted_indices[cur_group_name] = new Array();
												
							var cur_reverse_indices = reverse_sorted_indices[cur_group_name];
							
							for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
							cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
							
							
							

							ex_colors[cur_group_name] = new Array();
							var cur_color = ex_colors[cur_group_name];
							
							for (var j=0; j<(nrow-cur_ids.length); j++)
							{
								cur_color[cur_color.length] = [226, 226, 226];
							}
							
							for (var j=0; j<cur_ids.length; j++)
							{
								cur_color[cur_color.length] = [0, 0, 255];
							}
						
							
							
							console.log("The number of final selected hulls: " + final_selected.length);
							

							
							
							hulls[cur_group_name] = new Array();
						
							areas[cur_group_name] = new Array();
							
							hulls_mean[cur_group_name] = new Array();
						
							var cur_hulls = filtered_ids[cur_group_name];
							
							for (var j=0; j<n_dims; j++)
							{														
								areas[cur_group_name][j] = 0;

								hulls[cur_group_name][j] = new Array();
								
								var cur_dom = dom_arr[j] * (11/10);
									
								var cur_x2 = d3.scaleLinear()
												.domain([-cur_dom, cur_dom])
												.range([0, ep_size]);
												
		
								
								var sum_x = 0;
								var sum_y = 0;
								
								var cur_hulls_len = 0;
						
								for (var l=0; l<cur_hulls.length; l++)
								{
									var cur_cells = cur_hulls[l];
									
										
									var cur_len = cur_cells.length;
									
									
									if (cur_len > 2)
									{
										var points = new Array();
															
										for (var k=0; k<cur_len; k++)
										{
											var cur_id_dim = dimensions[cur_cells[k]];
											
											points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
										} 
													
										var cur_hull = d3.polygonHull(points);
										
										hulls[cur_group_name][j][l] = cur_hull;										
													
										areas[cur_group_name][j] += Math.abs(d3.polygonArea(cur_hull));		

										for (var k=0; k<cur_hull.length; k++)
										{
											var cur_point = cur_hull[k];
											
											sum_x += cur_point[0];
											sum_y += cur_point[1];
											
										}
										
										cur_hulls_len += cur_hull.length;
									}
				
								}
								
								if (cur_hulls_len != 0)
									hulls_mean[cur_group_name][j] = [sum_x/cur_hulls_len, sum_y/cur_hulls_len];
								else
									hulls_mean[cur_group_name][j] = new Array();
									
							}
							
							
                        }
                        
           
						
						calculate_overlap();
						

						
                        if (intersect_tf)
                        {
                            all_genes_done();
							
							
							for (var i=0; i<markers_on.length; i++)
							{
								draw_overlap_hulls(markers_on[i]);
							}
                        }
                        
                        else
                        {
                            var cur_group_name = valid_groups[0];
							
							
							if (cur_group_name in deg_others)
                            {
                                delete deg_others[cur_group_name];
                            }
                            
                            
                            if (markers_ani.indexOf(cur_group_name)!=-1)
                            {
                                new_marker_ani = cur_group_name;
                                cur_marker_ani = cur_group_name;
                                
                                calculate_animation();
                                
                                console.log("ani again");
                                
                            }
                            
                            var lasso_gene_id = "#" + cur_group_name;
                            
                          
                            
                            var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                            
                     
            
                            selected = new Array();
                            
                            final_selected = new Array();
                            
                            selected_density = new Array();
                            
                            
           
                            ccm = new Array();

							
							ccm[0] = cur_group_name;
                            
                            draw_markers_plots();
                            
                            
                 
                            
                            lasso_temp = new Array();
                        

                            
                            all_genes_done();
                            
                            
                            var cur_members = cur_group_name.split("_");
                    
                            for (var i=0; i<cur_members.length; i++)
                            {
                                d3.select('#lasso_window' + cur_members[i]).remove();
                            }
                            
                            d3.select('#inputs_window').remove();
                            
                            lasso_gene = "";
                            
                            
                            filtering_on = false;
                            density_on = false;
                            
                            intersect_tf = true;
							
							d3.select("#plot_size_slider").style('display', 'block');
							d3.select("#stop_plot_size_change").style('display', 'none');
                                
                        }
                    }
                });
            }    
                     
            else
            {
       
                for (var i=0; i<new_groups.length; i++)
                {
                    var cur_group_name = new_groups[i];
                    
                    var cur_members = cur_group_name.split("_");
					
					if (cur_members.length!=1)
					{
               
						hulls[cur_group_name] = new Array();

						areas[cur_group_name] = new Array();
						
						hulls_mean[cur_group_name] = new Array();
						
						sorted_indices[cur_group_name] = new Array();
						reverse_sorted_indices[cur_group_name] = new Array();
						
						ex_colors[cur_group_name] = new Array();
						var cur_color = ex_colors[cur_group_name];
						
						
						
						for (var j=0; j<nrow; j++)
						{
							cur_color[j] = [226, 226, 226];
						}
						
						for (var j=0; j<n_dims; j++)
						{						
							hulls[cur_group_name][j] = new Array();
							
							areas[cur_group_name][j] = 0;

							hulls_mean[cur_group_name][j] = new Array();							
						}
						
		
                    }

                    
                    
                }
				
				calculate_overlap();
				
				
                
                if (intersect_tf)
                {
                    all_genes_done();
					
					for (var i=0; i<markers_on.length; i++)
					{
						draw_overlap_hulls(markers_on[i]);
					}
                }
                
                else
                {
                    if (lasso_gene in deg_others)
                    {
                        delete deg_others[lasso_gene];
                    }
                    
                    
                    if (markers_ani.indexOf(lasso_gene)!=-1)
                    {
                        new_marker_ani = lasso_gene;
                        cur_marker_ani = lasso_gene;
                        
                        calculate_animation();
                        
                        console.log("ani again");
                        
                    }
                    
                    var lasso_gene_id = "#" + lasso_gene;
                    
                   
                    

                    
                    
                    selected = new Array();
                    
                    final_selected = new Array();
                    
                    selected_density = new Array();
                    
                    
   
                    ccm = new Array();
                    

					ccm[0] = new_groups[0];
                    
                    draw_markers_plots();
                    
                 
                    
                    
                    
                    lasso_temp = new Array();
                

                    
                    all_genes_done();
                    
            
                    for (var i=0; i<members.length; i++)
                    {
                        d3.select('#lasso_window' + members[i]).remove();
                    }
                    
                    d3.select('#inputs_window').remove();
                    
                    lasso_gene = "";
                    
                    
                    filtering_on = false;
                    density_on = false;
                
					d3.select("#plot_size_slider").style('display', 'block');
					d3.select("#stop_plot_size_change").style('display', 'none');
                }
  
            }
	
		}
		
		

		 
	
		function cell_filtering () {
	
			
			
				
			
			var members = lasso_gene.split("_")
			var morg = true;
			
			if (members.length==1)
				morg = true;
			else
				morg = false;
			
			
			
			var lasso_gene_id = '#' + lasso_gene;
			
			
			
			nrow = dimensions.length;
			
			dec = new Array();
			sorted_dec = new Array();
			
			density_indices = new Array();
			
			
			filtering_size = ep_size * (2/3);

			
			
			if (morg)
			{
				var cur_bounding = d3.select(lasso_gene_id)["_groups"][0][0].getBoundingClientRect();
				
				
				histo_ex = new Array();
				var histo_ex_max = ex_maxs[lasso_gene];
				
				var cur_gene = expressions[lasso_gene];
				
				for (var i=0; i<nrow; i++)
				{
					
					var cur_ex = Number(cur_gene[i+1]);
					
					histo_ex[histo_ex.length] = cur_ex;

				}
				
				var histGenerator = d3.histogram()
				.domain([0, histo_ex_max])
				.thresholds(num_bins);
				
				bins = histGenerator(histo_ex);
			
				
				
				bins_ids = new Array();
				
				for (var i=0; i<bins.length; i++)
				{
					bins_ids[i] = new Array();
				}
				
				bins_range = bins[0].x1 - bins[0].x0;
			
				
				for (var i=0; i<nrow; i++)
				{			
					var bin_id = Math.floor(histo_ex[i] / bins_range);
					
					var cur_bin = bins_ids[bin_id];
					
					cur_bin[cur_bin.length] = i;
			
				}
				
				
				
				var slider_height = Number(d3.select('#slider')["_groups"][0][0].style.height.replace("px", ""));
				
				var lasso_window_w = filtering_size + hist_margin.left + hist_margin.right;
				
				var lasso_window_h = filtering_size + filtering_size/2 + hist_margin.top + hist_margin.bottom + slider_height + 50;
				
				d3.select('body')
					.append('div')
	
					.attr("id", "lasso_window" + lasso_gene)
					.style('width', lasso_window_w )
					.style('height', lasso_window_h)
					.style('position', 'absolute')
					.style('left', cur_bounding.left + 'px')
					.style('top', $(document).scrollTop() + cur_bounding.top + cur_bounding.height + 'px')
					.style('padding', '10px 10px 10px 10px')
					.style('display', 'block')
 
					.style('background-color', '#e2e2e2')
					.raise();
				

				
				
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr('class', 'row')
					.attr("id", "mep"+lasso_gene)
					.style('padding-left', '10px')
					.style('padding-right', '20px');
					
				var cur_mep_name = "#mep" + lasso_gene;
				
				
				var mep_svg = d3.select(cur_mep_name)
				.append("svg")		
				.attr("id", "mep_svg" + lasso_gene)
				.attr("width", filtering_size)
				.attr("height", filtering_size)
				.style("background-color", "white")
				.style("margin", "0 auto")


		
				

				mep_svg.append("text")
				.attr("x", (filtering_size / 2)) 
				.attr("y", legend_size/2+10)
				.attr("text-anchor", "middle")  					 
				.style("font-size", font_size_str)  
				.text(lasso_gene)
				
				

				
				
				
				var cur_xy = new Array();
							
				var cur_indices = sorted_indices[lasso_gene];
				
				
				
				
				for (var j=0; j<nrow; j++)
				{
					var cur_index = dimensions[cur_indices[j]];
					
					cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
				}
				
				
				var cur_dom = dom_arr[dim_id] * (11/10);
										
				var cur_x_filtering = d3.scaleLinear()
										.domain([-cur_dom, cur_dom])
										.range([0, filtering_size]);
				
				
				
				var mep_dots = mep_svg.append('g')
				.attr("id", "mep_dots" + lasso_gene)
				
				var mep_dots_data = mep_dots.selectAll()								
				.data(cur_xy).enter()
				.append("circle")
				.attr("id", function(d, i) {return i;})
				.attr("cx", function(d) {return cur_x_filtering(d[0])})
				.attr("cy", function(d) {return cur_x_filtering(-d[1])})			
				.attr("r", ep_cell_size)
				
			
			
				mep_dots_data.data(ex_colors[lasso_gene])
				.attr("fill", function(d) {
				return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
				
				
				
				
				var mep_dots_id = "#mep_dots" + lasso_gene;
				
				
				
				
				var lasso_start = function() {
					
					if (density_on)
						lasso.items()				
				};
				
				
				var lasso_draw = function() {

				};

				var lasso_end = function() {
					

					if (density_on)
					{
						
						
						

						
						
						lasso_temp = lasso.selectedItems();
						
						selected = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
						
						
	
						
					
						var temp_id = 0;
								
						var cur_final_legnth = final_selected.length;
							
						var first = true;
					
						for (var j=0; j<selected.length; j++)
						{
							var cur_density_id = selected[j];
    
                            var offset = nrow-dec.length;
                                  
                            
                           
                            if (cur_density_id >= offset)
                            {
                                if (first)
								{
									final_selected[cur_final_legnth] = new Array();
									
									temp_id = selected_density.length;
									
									first = false; 
								}
								

								
								final_selected[cur_final_legnth][final_selected[cur_final_legnth].length] = dec[density_indices[cur_density_id-offset]];
								
								selected_density[selected_density.length] = cur_density_id;
                            }
                            
							
                
						}
						
						
						
						var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
							
			
						for (var j=temp_id; j<selected_density.length; j++)
						{
			
							cur_lasso_dots[selected_density[j]].setAttribute("class", "selected");
						}
						
						console.log("final_selected");
						console.log(final_selected);
						
						console.log("selected_density");
						console.log(selected_density);
						
					}
					

				};
				
				
				

				
				var lasso = d3.lasso()
				.closePathSelect(true)
				.closePathDistance(100)
				.items(mep_dots_data)					
				.targetArea(mep_svg)
				.on("start",lasso_start)
				.on("draw",lasso_draw)
				.on("end",lasso_end);
			
				mep_svg.call(lasso);
					
		

				var histogram_w = filtering_size + hist_margin.left + hist_margin.right;
				var histogram_h = filtering_size/2 + hist_margin.top + hist_margin.bottom;
					
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("class", "row")
					.attr("id", "histogram")
					.style('width',  histogram_w)
					.style('height', histogram_h)	
	
			
					.style('display', 'block')

					.raise();
                    
				

                
				var svg_hist = d3.select('#histogram')
					.append("svg")
                        .attr("id", "histogram_svg")
						.attr("width", filtering_size + hist_margin.left + hist_margin.right)
						.attr("height", filtering_size/2 + hist_margin.top + hist_margin.bottom)
                        .style('display', 'block')
                        .style("margin", "0 auto")
					.append("g")
						.attr("transform",
							"translate(" + hist_margin.left + "," + hist_margin.top + ")");
							
				var hist_x = d3.scaleLinear()
					.domain([0, histo_ex_max])
					.range([0, filtering_size]);
				
				svg_hist.append("g")
					.attr("transform", "translate(0," + filtering_size/2 + ")")
					.call(d3.axisBottom(hist_x));
					
				var hist_y = d3.scaleLinear()
					.range([filtering_size/2, 0]);
					
				hist_y.domain([0, d3.max(bins, function(d) {return d.length;})]);
				
				svg_hist.append("g")
					.attr("id", "hist_y")
					.call(d3.axisLeft(hist_y));
				
				
				svg_hist.selectAll("rect")
					.data(bins)
					.enter()
					.append("rect")
						.attr("x", 1)
						.attr("transform", function(d) { return "translate(" + hist_x(d.x0) + "," + hist_y(d.length) + ")"; })
						.attr("width", function(d) { return hist_x(d.x1) - hist_x(d.x0) -1 ; })
						.attr("height", function(d) { return filtering_size/2 - hist_y(d.length); })
						.style("fill", "#69b3a2")

				
				
				hist_th = histo_ex_max;
				
				svg_hist.append("rect")
					.attr("id", "selection")
					.attr("transform", "translate(" + hist_x(hist_th) + ",0)")
					.attr("width", hist_x(histo_ex_max - hist_th))
					.attr("height", filtering_size/2)
					.style("fill", "rgba(0, 0, 255, 0.3)");
					
				var slider_padding = hist_margin.left + 10 + "px 10px 10px 10px";
					
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("class", "row")
					.attr("id", "selection_slider")

					.style('width',  histogram_w)
					.style('height', slider_height)
					

					.style('padding-bottom', '10px')
					.style('display', 'block')
      								
					.raise();
				
				
		
				var slider_left = hist_margin.left  + "px";

				var slider_width = filtering_size*(bins.length/(bins.length-1)) + "px";
				
				
				var slider_margin_left = (hist_margin.left + d3.select("#histogram_svg")._groups[0][0].getBoundingClientRect().x - d3.select("#histogram")._groups[0][0].getBoundingClientRect().x) + "px";
				
                console.log(slider_margin_left);
                
				var th_id;
                
				d3.select('#selection_slider')
   
					.append("input")								
                    .attr("id", "silderid")
					.attr("type", "range")
				
					.attr("value", histo_ex_max)
					.attr("min", 0)
					.attr("max", histo_ex_max)
			
					.attr("step", bins[0].x1 - bins[0].x0)
		
		
                    .style("width", filtering_size + "px")
		
                    .style('display', 'block')
         
					.on("change", function() { 

						if (!density_on)
						{
							var cur_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
						
							for (var i=0; i<sorted_dec.length; i++)
							{
								
							
								cur_dots[sorted_dec[i]].setAttribute("class", "");
							
								
							}
							
							
							
							dec = new Array();
							sorted_dec = new Array();
							
							
			
							
							hist_th = this.value;										
							th_id = hist_th / bins_range;
							
							
							var cur_reverse = reverse_sorted_indices[lasso_gene];
							
							for (var i=0; i<bins_ids.length; i++)
							{
								if (i >= th_id)
								{
									var cur_bin = bins_ids[i];
									
									for (var j=0; j<cur_bin.length; j++)
									{
										var cur_id = cur_bin[j];
										
										dec[dec.length] = cur_id;
										
										
										
										
										var sorted_id = cur_reverse[cur_id];
										
										
										
										cur_dots[sorted_id].setAttribute("class", "selected");
										
										
										
										sorted_dec[sorted_dec.length] = sorted_id;
									}
								}						
							}
							
							
						

							
							d3.select("#selection")
								.attr("transform", "translate(" + hist_x(hist_th) + ",0)")
								.attr("width", hist_x(histo_ex_max - hist_th));
						}
						
					});
					

				
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("id", "set_center")

					.attr("id", "inputs")
					
				
				
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "density_plot")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Density Plot")
					.style("margin", "0 auto")
				
					.on("click", function() {
						
						if (dec.length > 2)
						{
							if (density_on)
							{
								if (final_selected.length > 0)
								{
								
									lasso_temp = new Array();
									
									
									

									var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
										
									for (var j=0; j<selected_density.length; j++)
									{
						
										cur_lasso_dots[selected_density[j]].setAttribute("class", "");
									}
									
									selected_density = new Array();
									
									
									selected = new Array();
									
									fianl_selected = new Array();
									
									sorted_fianl_selected = new Array();
									

								}
								
								
								
								
								var cur_xy_dp = new Array();
							
								var cur_indices_dp = sorted_indices[lasso_gene];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices_dp[j]];
									
									cur_xy_dp[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								
								var cur_dom = dom_arr[dim_id] * (11/10);
										
								var cur_x_filtering = d3.scaleLinear()
														.domain([-cur_dom, cur_dom])
														.range([0, filtering_size]);

								
								d3.select(mep_dots_id)
								.selectAll('circle')
								.data(cur_xy_dp)
								.attr("cx", function(d) {return cur_x_filtering(d[0])})
								.attr("cy", function(d) {return cur_x_filtering(-d[1])})
								
						
							
								
								
								d3.select(mep_dots_id)
									.selectAll('circle')
									.data(ex_colors[lasso_gene])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
									
								


								var cur_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];

								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									
									 cur_dots[sorted_dec[i]].setAttribute("class", "selected");
								
									
								}
								
								
								
								
								
								document.getElementById("selection_slider").disabled = false;
								d3.select("#legend").remove();
									
								density_on = false;
								
								
								d3.select('#density_plot').attr("value", "Density Plot");
								d3.select('#lasso_cancel').style('display', 'none');
								d3.select('#done').style('display', 'none');
							}
							
							else
							{
								final_selected = new Array();
									
								selected_density = new Array();
								
								
								d3.select('body')									
									.append('div')											
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')
									.style('top', $(document).scrollTop() + height/2 + 'px')		
									.style('display', 'block')
									.raise();
								
                                
								d3.select('#density_plot').attr("value", "Return to Expression Threshold Selection");
								d3.select('#lasso_cancel').style('display', 'block');
								d3.select('#done').style('display', 'block');
								
								           
                                
                                var dec_num = dec.length;
                                
                                var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                                  + rds_name + "_" + nrow + "_" + n_dims + "_" + dim_id + "_" + dec_num;
                                  
                                  
                                for (var i=0; i<dec_num; i++)
								{
									
                                    density_string = density_string + " " + dec[i];     
								}
                                  
                                 
      
                                  
                                console.time("density_plot.py time:");	
                                            
                                $.ajax({
                                    async: true,
                                
                                    url: "density_plot.py",
                                    type: 'POST',
                                    
                                    contentTpye: 'application/json',
                                    dataType: 'json',
                                
                                    data: {'fd_ld': density_string},
                                    
                                    success: function(response){
                                        
                                        var endTime2 = new Date().getTime();
                                        
                                        console.timeEnd("density_plot.py time:");
                                        
                                        console.log("density_plot.py finish");
                                        
                                       
                              
                                        
                                        var density_values = response["density"];
                                        
                                        
           
							
										density_indices = new Array();
									
										
										
										for (var j = 0; j < dec_num; ++j) density_indices[j] = j;
										density_indices.sort(function (a, b) { return density_values[a] < density_values[b] ? -1 : density_values[a] > density_values[b] ? 1 : 0; });
									
                                    
                                     
              
										
										var cur_xy_dp = new Array();
                                        
                                        var ori_count = 0;
					
										for (var i=0; i<nrow; i++)
										{
											var cur_index;
                                            
                                            if (i < (nrow-dec_num))
                                            {
                                                var ori_id = dec.indexOf(ori_count);
                                                
                                                while(ori_id != -1)
                                                {
                                                    ori_count++;
                                                    
                                                    ori_id = dec.indexOf(ori_count);
                                                }
                                                
                                                cur_index = dimensions[ori_count];
                                                
                                                ori_count++;
                                           
                                            }
                                            
                                            else
                                            {
                                          
                                                cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                            }
                                            
                                            cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            
                                            
                                            
                      
										}
										
										
										
                                        
                                        
                                        var density_min = Number.MAX_VALUE;
                                        var density_max = Number.MIN_VALUE;
                                        
                                        for (var i=0; i<dec_num; i++)
                                        {
                                            var cur_density = density_values[i];
                                            
                                            if (cur_density < density_min)
                                                density_min = cur_density;
                                            
                                            if (cur_density > density_max)
                                                density_max = cur_density;
                                        }
                                        
                   
                                        var density_range = (density_max - density_min) / 4;
                                                         var color_scale = d3.scaleLinear()
                                                            .domain([density_min, density_min+density_range, density_min+2*density_range, density_min+3*density_range, density_max])
                                                                                                .range(["#2166AC", "#92C5DE", "#F7F7F7", "#F4A582", "#B2182B"]);
                                        
                                        density_colors = new Array();
                                        
                                        
                                        for (var i=0; i<nrow; i++)
                                        {
                                            if (i < (nrow-dec_num))
                                            {
                                    
                                                density_colors[i] = "#E2E2E2";
                                            }
                                            
                                            else
                                            {
                                  
                                                density_colors[i] = color_scale(density_values[density_indices[i - (nrow-dec_num)]]);
                                            }
                    
                                        }
                                       
                                        
                                        
                                        var cur_circle = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
			
										for (var i=0; i<sorted_dec.length; i++)
										{
											
											
											cur_circle[sorted_dec[i]].setAttribute("class", "");
										
											
										}
                                        
                                        
										var cur_dom = dom_arr[dim_id] * (11/10);
										
										var cur_x_filtering = d3.scaleLinear()
																.domain([-cur_dom, cur_dom])
																.range([0, filtering_size]);
										
                                        
										
										d3.select(mep_dots_id)
										.selectAll('circle')
										.data(cur_xy_dp)
										.attr("cx", function(d) {return cur_x_filtering(d[0])})
										.attr("cy", function(d) {return cur_x_filtering(-d[1])})	
										
										

										
										
										d3.select(mep_dots_id)
											.selectAll('circle')
											.data(density_colors)
											.attr("fill", function(d) {
											return d});
															
						
                                        
                                        
                      
                        
                                        mep_svg.append("defs")
                                            .append("linearGradient")
                                            .attr("id", "legend-density")
                                            .attr("x1", "0%").attr("y1", "0%")
                                            .attr("x2", "100%").attr("y2", "0%")
                                            .selectAll("stop") 
                                            .data([
                           
                                                
                                                {offset: "0%", color: "#2166AC"},
                                                {offset: "25%", color: "#92C5DE"},
                                                {offset: "50%", color: "#F7F7F7"},
                                                {offset: "75%", color: "#F4A582"},
                                                {offset: "100%", color: "#B2182B"}
                                             
                                              ])
                                            .enter().append("stop")
                                            .attr("offset", function(d) { return d.offset; })
                                            .attr("stop-color", function(d) { return d.color; });
                                   
                                     
                                        var cur_legend_bounding = d3.select("#lasso_window"+lasso_gene)["_groups"][0][0].getBoundingClientRect();
                                        
                                        
                      
                                        var legned_div_w = cur_legend_bounding.width;
                                        var legned_div_h = font_size*5;
                                        
                                        var legendWidth = legned_div_w-2;
                                        var legendHeight = font_size;
                                        
                                        
                   
                                        var legendsvg = d3.select('body')
                                            .append('div')
                                            .attr("id", "legend")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .style('position', 'absolute')
                                                                   .style('left', cur_legend_bounding.left + 'px')
                                            .style('top', $(document).scrollTop() + cur_legend_bounding.top - legned_div_h + 'px')
                                 
                                            .style('display', 'block')
                                            .style('background-color', '#e2e2e2')
                                            .raise()
                                            
                                            .append("svg")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .append("g")
                                            .attr("class", "legendWrapper")
                                            .attr("transform", "translate(" + (legned_div_w/2) + "," + legned_div_h/2 + ")");
                                            
                                         
                
                                        

                                        var tri_size = font_size * 0.7;
                                        
                                        var tri_scale = d3.scaleLinear()
                                            .domain([0, 1])
                                            .range([-legendWidth/2, legendWidth/2]);
                                                
                                        var legend_scale = d3.scaleLinear()
                                             .domain([0, legendWidth])
                                             .range([0, 1]);
                                        
									
                                        legendsvg
                                            .append("rect")
                                            .attr("class", "legendRect")
                                            .attr("x", -legendWidth/2)
                                            .attr("y", 0) 
                                                    
                                            .attr("width", legendWidth)
                                            .attr("height", font_size)
                                            .style("fill", "url(#legend-density)")
                                            .on("click", function() 
                                            {                  
                                                var dim = this.getBoundingClientRect();
                                                var x = d3.event.pageX - dim.left;
                                         
                                                density_th = legend_scale(x);
                                                console.log("density_th: " + density_th);
                                                
                                              
                                                var cur_offset = tri_scale(density_th);
                                                
                                                d3.select("#triangle")
                                                .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0");
                                                                          });
                                            
                                        
                                        var cur_offset = tri_scale(density_th);
                                        
                                        legendsvg
                                            .append("path")  
                                            .attr("id", "triangle")
                 
                                            .attr("x", 0)
                                            .attr("y", -tri_size)
                                            .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0")
                                                                .attr("fill", "Black");




                                        legendsvg.append("text")
                                            .attr("class", "legendTitle")
                                            .attr("x", 0)
          
                                            .attr("y", -font_size-tri_size)
                                            .style("text-anchor", "middle")
                                            .style("font-size", font_size*0.8+"px")  
                                            .text("Normalized local density");
                                            
                                        
                                             
                                        
                     
                                        var xScale = d3.scaleLinear()
                                             .range([-legendWidth/2, legendWidth/2])
											 .domain([0.0, 1.0]);
                             
                                        
                                        
                       
                                              
                                        var xAxis = d3.axisBottom(xScale)                                 
                                              .ticks(5);                                
                                 

                      
                                        legendsvg.append("g")
                                            .attr("class", "axis")
                                            .attr("transform", "translate(0," + font_size + ")")
                                            .style("font-size", font_size*0.5+"px")  
                                            .call(xAxis);
                                        
                                        
                                 
														
										document.getElementById("selection_slider").disabled = true;

														
										density_on = true;	
										
										
										d3.select(".loader").remove();
                                    }
                                });							
							}
						}
						
						else
						{
							alert("Please select cells first.")
						}
					})
				
				
				

				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "lasso_cancel")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Lasso Cancel")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						if (final_selected.length > 0)
						{
						
							lasso_temp.classed("selected",false);
						
						
						
							lasso_temp = new Array();
							
							
							
							
							
							
		
						
							
							var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
								
							for (var j=0; j<selected_density.length; j++)
							{
				
								cur_lasso_dots[selected_density[j]].setAttribute("class", "");
							}
							
							
						
							
							selected = new Array();
							
							
							final_selected = new Array();
							
							selected_density = new Array();
							
							
						
							
							

							alert("Cancellation Complete.");
						}
						
						else
						{
							alert("No selection.")
						}
					
					});
				
				

				
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "done")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Done")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						

                        if (density_on)
						{
						
							d3.select('body')									
								.append('div')											
								.attr('class', 'loader')
								.style('position', 'absolute')
								.style('left', width/2 + 'px')
								.style('top', $(document).scrollTop() + height/2 + 'px')		
								.style('display', 'block')
								.raise();
						

							console.log("The number of final hulls: " + final_selected.length);
							
			
							
							lasso_temp = new Array();
							
							
                            
                            cell_ids[lasso_gene] = new Array();
							
							temp_cell_ids = new Array();
							
							if (final_selected.length > 0)
							{						
								for (var i=0; i<final_selected.length; i++)
								{								
									temp_cell_ids[i] = new Array();
									
									for (var j=0; j<final_selected[i].length; j++)
									{
										cell_ids[lasso_gene][cell_ids[lasso_gene].length] = final_selected[i][j];
										
										temp_cell_ids[i][j] = final_selected[i][j];
									}
								}
							}
							
							else
							{
								temp_cell_ids[0] = new Array();
								
								for (var i=0; i<dec.length; i++)
								{								
									cell_ids[lasso_gene][cell_ids[lasso_gene].length] = dec[i];
									
									temp_cell_ids[0][i] = dec[i];
									
								}
							}
							
					
							
							
							final_selected = new Array();
							
							selected_density = new Array();
							
							
						
							
							density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
							  + rds_name + "_" + nrow + "_" + n_dims + "_" + temp_cell_ids.length + "_" + density_th + "_";
														
							for (var i=0; i<temp_cell_ids.length; i++)
							{
								var cur_cell_ids = temp_cell_ids[i];
								
								if (i!=0)
								{
									density_string += " ";
								}
								
								density_string += cur_cell_ids.length;
								
								for (var j=0; j<cur_cell_ids.length; j++)
								{
									density_string = density_string + " " + cur_cell_ids[j];
								}
								
								for (var j=0; j<nrow-cur_cell_ids.length; j++)
								{
									density_string = density_string + " " + 0;
								}
								
							}
                                
                          
               
                            console.time("density.py time:");	
                                        
                            $.ajax({
                                async: true,
                            
                                url: "density.py",
                                type: 'POST',
                                
                                contentTpye: 'application/json',
                                dataType: 'json',
                            
                                data: {'fd_ld': density_string},
                                
                                success: function(response){
                                    
                                    var endTime2 = new Date().getTime();
                                    
                                    console.timeEnd("density.py time:");
                                    
                                    console.log("density.py finish");
									
									
									var filtered_ids_result = response["filtered_ids"];
									
									filtered_ids[lasso_gene] = new Array();
									
				
                                    
									for (var m=0; m<temp_cell_ids.length; m++)
									{
										filtered_ids[lasso_gene][m] = new Array();
									
										var cur_cell_ids = temp_cell_ids[m];
									
										var cur_ids_len = cur_cell_ids.length;
										
										var temp_arr = new Array();
										
										for (var j=0; j<cur_ids_len; j++)
										{
											temp_arr[j] = cur_cell_ids[j];
										}
										
										
										for (var k=0; k<n_dims; k++)
										{                                                                                     																	
											for (var l=0; l<cur_ids_len; l++)
											{
												var cur_id = filtered_ids_result[m*n_dims*nrow + k*nrow + l];
												
												if (cur_id == -1 && temp_arr[l] != -1) 
												{
													temp_arr[l] = -1;
												}
											}
										}
										
										
										
										
										var fc = 0;
										
										for (var j=0; j<cur_ids_len; j++)
										{
											var cur_id = temp_arr[j];
											
											if (temp_arr[j] != -1)
											{
												filtered_ids[lasso_gene][m][fc] = cur_id;
												
												fc++;
											}
										}
									}

									
									
	
                                    
                                    selected = new Array();
									final_selected = new Array();
									selected_density = new Array();
											
									
									
									
							
									hulls[lasso_gene] = new Array();
									areas[lasso_gene] = new Array();
									areas_marker[lasso_gene] = new Array();

									hulls_dom[lasso_gene] = new Array();
									row_sizes[lasso_gene] = Number.MIN_VALUE;
									hulls_mean[lasso_gene] = new Array();
									
									var cur_hulls = filtered_ids[lasso_gene];
							
									for (var j=0; j<n_dims; j++)
									{														
										areas[lasso_gene][j] = 0;
										areas_marker[lasso_gene][j] = 0;

										hulls[lasso_gene][j] = new Array();
										
										var cur_dom = dom_arr[j] * (11/10);
											
										var cur_x2 = d3.scaleLinear()
														.domain([-cur_dom, cur_dom])
														.range([0, ep_size]);
								

										
										
										var sum_x = 0;
										var sum_y = 0;
										
										var cur_hulls_len = 0;
										
										for (var l=0; l<cur_hulls.length; l++)
										{
											var cur_cells = cur_hulls[l];
											
												
											var cur_len = cur_cells.length;
											
											
											if (cur_len > 2)
											{
												var points = new Array();
																	
												for (var k=0; k<cur_len; k++)
												{
													var cur_id_dim = dimensions[cur_cells[k]];
													
													points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
												} 
															
												var cur_hull = d3.polygonHull(points);
												
												hulls[lasso_gene][j][l] = cur_hull;										
															
												areas[lasso_gene][j] += Math.abs(d3.polygonArea(cur_hull));
												
												var scaled_hull = new Array();
													
												for (var k=0; k<cur_hull.length; k++)
												{
													scaled_hull[k] = [cur_x2(cur_hull[k][0]), cur_x2(-cur_hull[k][1])];
												}
												
												areas_marker[lasso_gene][j] += Math.abs(d3.polygonArea(scaled_hull));
												

												for (var k=0; k<cur_hull.length; k++)
												{
													var cur_point = cur_hull[k];
													
													sum_x += cur_point[0];
													sum_y += cur_point[1];
													
												}
												
												cur_hulls_len += cur_hull.length;
											}

										
										}
										
										var mean_x;
										var mean_y;
										
										if (cur_hulls_len != 0)
										{
											mean_x = sum_x / cur_hulls_len;
											mean_y = sum_y / cur_hulls_len;
											
											hulls_mean[lasso_gene][j] = [mean_x, mean_y];
										}
										else
											hulls_mean[lasso_gene][j] = new Array();
										
										
										hulls_dom[lasso_gene][j] = new Array();
										
										var cur_dim_hulls = hulls[lasso_gene][j];
										
										for (var l=0; l<cur_dim_hulls.length; l++)
										{
											var cur_hull = cur_dim_hulls[l];	

											var cur_len = cur_hull.length;
											
											if (cur_len > 2)
											{
										
												hulls_dom[lasso_gene][j][l] = new Array();
												
												var cur_one = d3.scaleLinear()
																.domain([-cur_dom, cur_dom])
																.range([-1, 1]);
												
												for (var k=0; k<cur_hull.length; k++)
												{
													var cur_point = cur_hull[k];
													
													var cur_x = cur_one(cur_point[0] - mean_x);
													
													var cur_y = cur_one(-(cur_point[1] - mean_y));
													
													hulls_dom[lasso_gene][j][l][k] = [cur_x, cur_y];
													
													if (Math.abs(cur_x) > row_sizes[lasso_gene])
													{
														row_sizes[lasso_gene] = Math.abs(cur_x);
													}

													if (Math.abs(cur_y) > row_sizes[lasso_gene])
													{
														row_sizes[lasso_gene] = Math.abs(cur_y);
													}														
												}
											}
										}
										
									}
									

									if (cur_groups.indexOf(lasso_gene) != -1)
									{
										calculate_overlap();
									}
	
									
									if (lasso_gene in deg_others)
									{
										delete deg_others[lasso_gene];
									}
									
									
									if (markers_ani.indexOf(lasso_gene)!=-1)
									{
										new_marker_ani = lasso_gene;
										cur_marker_ani = lasso_gene;
										
										calculate_animation();
										
										console.log("ani again");
										
									}
									
									
					
									
									
									ccm = new Array();
									
									ccm[0] = lasso_gene;
									
									draw_markers_plots();
									
									
							
	
									
									
									all_genes_done();
									
								
								
								
									d3.select("#legend").remove();
                                    
									d3.select('#lasso_window' + lasso_gene).remove();
									
									
									
									
									lasso_gene = "";
									
									
									filtering_on = false;
									density_on = false;
									
									d3.select("#plot_size_slider").style('display', 'block');
									d3.select("#stop_plot_size_change").style('display', 'none');
                                }
                            });
                            

						}
						
						else
						{
							alert("Please click this button after performing Lasso Selection on Density Plot.")
						}
					});
				
				
				
				
				
				
			
				
				var slider_margin_left = (hist_margin.left + d3.select("#histogram_svg")._groups[0][0].getBoundingClientRect().x - d3.select("#histogram")._groups[0][0].getBoundingClientRect().x) + "px";
                d3.select('#silderid')
				.style("margin-left", slider_margin_left)	
                
                console.log("end slider margin left: " + slider_margin_left);
					

			}
			
			else
			{
				
				
				
				histo_ex = new Object;								
				bins = new Object;
				bins_ids = new Object;
				bins_range = new Object;
				hist_th = new Object;

				histo_ex_max = new Object;
				decs = new Object;
				sorted_decs = new Object;
				
				
				
				
				var slider_height = Number(d3.select('#slider')["_groups"][0][0].style.height.replace("px", ""));
					
				
				var lasso_window_w = filtering_size + hist_margin.left + hist_margin.right;
				var lasso_window_h = filtering_size + filtering_size/2 + hist_margin.top + hist_margin.bottom + slider_height + 50;
				
				
				
				
				for (var k=0; k<members.length; k++)
				{
					
					var cur_member = members[k];
					var cur_id = "#" + cur_member;
					
					
					
					decs[cur_member] = new Array();
					sorted_decs[cur_member] = new Array();
					
					var cur_bounding = d3.select(cur_id)["_groups"][0][0].getBoundingClientRect();
					
					
					
					
					
					
					
					
					histo_ex[cur_member] = new Array();
					
					
					
					var cur_histo_ex = histo_ex[cur_member];
					
					histo_ex_max[cur_member] = ex_maxs[cur_member];
				
					var cur_gene = expressions[cur_member];
					
					for (var i=0; i<nrow; i++)
					{
						
						var cur_ex = Number(cur_gene[i+1]);
						
						cur_histo_ex[cur_histo_ex.length] = cur_ex;		
					}
					
					var histGenerator = d3.histogram()
					.domain([0, histo_ex_max[cur_member]])
					.thresholds(num_bins);
					
					bins[cur_member] = histGenerator(cur_histo_ex);
					
					
					
					
					bins_ids[cur_member] = new Array();
					
					for (var i=0; i<bins[cur_member].length; i++)
					{
						bins_ids[cur_member][i] = new Array();
					}
					
					bins_range[cur_member] = bins[cur_member][0].x1 - bins[cur_member][0].x0;
				
					
					for (var i=0; i<nrow; i++)
					{
						var bin_id = Math.floor(histo_ex[cur_member][i] / bins_range[cur_member]);
						
						var cur_bin = bins_ids[cur_member][bin_id];
						
				
						cur_bin[cur_bin.length] = i;
						
					}
					
			
					
					
					var cur_left = cur_bounding.left - ((lasso_window_w - cur_bounding.width) / 2);
					
					
					
					d3.select('body')
					.append('div')

					.attr("id", "lasso_window" + cur_member)
					.style('width', lasso_window_w)
					.style('height', lasso_window_h)
					.style('position', 'absolute')
	
				
					.style('left', cur_left + 'px')
					.style('top', $(document).scrollTop() + cur_bounding.top + cur_bounding.height + 'px')
					.style('padding', '10px 10px 10px 10px')
					.style('display', 'block')
					.style('background-color', '#e2e2e2')
					.raise();
					

						
				
					

					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr('class', 'row')
						.attr("id", "mep"+cur_member)
						.style('padding-left', '10px')
						.style('padding-right', '20px');
						
					var cur_mep_name = "#mep" + cur_member;
					
					
					var mep_svg = d3.select(cur_mep_name)
					.append("svg")		
					.attr("id", "mep_svg" + cur_member)
					.attr("width", filtering_size)
					.attr("height", filtering_size)
					.style("background-color", "white")
					.style("margin", "0 auto")


			
					

					mep_svg.append("text")
					.attr("x", (filtering_size / 2)) 
					.attr("y", legend_size/2+10)
					.attr("text-anchor", "middle")  					 
					.style("font-size", font_size_str)  
					.text(cur_member)
					
					
					
					
					
					var cur_xy = new Array();
							
					var cur_indices = sorted_indices[cur_member];
					
					
					
					
					for (var j=0; j<nrow; j++)
					{
						var cur_index = dimensions[cur_indices[j]];
						
						cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
					}
					
					
			
					
					var cur_dom = dom_arr[dim_id] * (11/10);
										
					var cur_x_filtering = d3.scaleLinear()
											.domain([-cur_dom, cur_dom])
											.range([0, filtering_size]);
				
					
					var mep_dots = mep_svg.append('g')
					.attr("id", "mep_dots" + cur_member)
					
					var mep_dots_data = mep_dots.selectAll()								
					.data(cur_xy).enter()
					.append("circle")
					.attr("id", function(d, i) {return i;})
					.attr("cx", function(d) {return cur_x_filtering(d[0])})
					.attr("cy", function(d) {return cur_x_filtering(-d[1])})			
					.attr("r", ep_cell_size)
					
				
				
					mep_dots_data.data(ex_colors[cur_member])
					.attr("fill", function(d) {
					return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
					
					
					
					
					
					
					var mep_dots_id = "#mep_dots" + cur_member;
				
				
					
			
					
						
					var histogram_w = filtering_size + hist_margin.left + hist_margin.right;
					var histogram_h = filtering_size/2 + hist_margin.top + hist_margin.bottom;
						
		
					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr("class", "row")
						.attr("id", "histogram" + cur_member)
						.style('width',  histogram_w)
						.style('height', histogram_h)	

						.style('padding-left', '10px')
						.style('padding-right', '20px')
						.style('display', 'block')
						.raise();
					
					
					var cur_his_name = "#histogram" + cur_member;
					
					var svg_hist = d3.select(cur_his_name)
						.append("svg")
							.attr("width", filtering_size + hist_margin.left + hist_margin.right)
							.attr("height", filtering_size/2 + hist_margin.top + hist_margin.bottom)
						.append("g")
							.attr("transform",
								"translate(" + hist_margin.left + "," + hist_margin.top + ")");
								
					var hist_x = d3.scaleLinear()
						.domain([0, histo_ex_max[cur_member]])
						.range([0, filtering_size]);
						
					hist_x_test = hist_x;
					
					svg_hist.append("g")
						.attr("transform", "translate(0," + filtering_size/2 + ")")
						.call(d3.axisBottom(hist_x));
						
					var hist_y = d3.scaleLinear()
						.range([filtering_size/2, 0]);
						
					hist_y.domain([0, d3.max(bins[cur_member], function(d) {return d.length;})]);
					
					svg_hist.append("g")
						.attr("id", "hist_y")
						.call(d3.axisLeft(hist_y));
					
					
					svg_hist.selectAll("rect")
						.data(bins[cur_member])
						.enter()
						.append("rect")
							.attr("x", 1)
							.attr("transform", function(d) { return "translate(" + hist_x(d.x0) + "," + hist_y(d.length) + ")"; })
							.attr("width", function(d) { return hist_x(d.x1) - hist_x(d.x0) -1 ; })
							.attr("height", function(d) { return filtering_size/2 - hist_y(d.length); })
							.style("fill", "#69b3a2")
			
					
					hist_th[cur_member] = histo_ex_max[cur_member];
					
					svg_hist.append("rect")
						.attr("id", "selection" + cur_member)
						.attr("transform", "translate(" + hist_x(hist_th[cur_member]) + ",0)")
						.attr("width", hist_x(histo_ex_max[cur_member] - hist_th[cur_member]))
						.attr("height", filtering_size/2)
						.style("fill", "rgba(0, 0, 255, 0.3)");
						
					var slider_padding = hist_margin.left + 10 + "px 10px 10px 10px";
						

					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr("class", "row")
						.attr("id", "selection_slider" + cur_member)
			
						.style('width',  histogram_w)
						.style('height', slider_height)
						
						.style('padding-left', '10px')
						.style('padding-right', '20px')
						.style('padding-bottom', '10px')
						.style('display', 'block')									
						.raise();
					
					
			
					var slider_left = hist_margin.left  + "px";

					var slider_width = filtering_size*(bins[cur_member].length/(bins[cur_member].length-1)) + "px";
					
					
					var cur_slider_name = "#selection_slider" + cur_member;
					
					
					
					var cur_selection = "#selection" + cur_member;
					
					
					
					d3.select(cur_slider_name)
		
						.append("input")
						.attr("id", "slider" + cur_member)
	
						.attr("type", "range")
						
						.attr("value", histo_ex_max[cur_member])
						.attr("min", 0)
						.attr("max", histo_ex_max[cur_member])
	
						.attr("step", bins[cur_member][0].x1 - bins[cur_member][0].x0)
			
						.style("position", "absolute")
			
						.style("left", slider_left)

						.style("width", slider_width)
				
						.style("margin-bottom", "30px")
		
						.on("change", function() { 
							
							if (!density_on)
							{
							
							
								var gene = this.id.replace("slider", "");
								
								
								var cur_mep_id = "#mep_dots" + gene;
								
								
								
								
								
								var cur_dots = d3.select(cur_mep_id).selectAll('circle')["_groups"][0];
								
								
								for (var i=0; i<sorted_decs[gene].length; i++)
								{
									
									cur_dots[sorted_decs[gene][i]].setAttribute("class", "");
								}
								
								
								decs[gene] = new Array();
								sorted_decs[gene] = new Array();
								
								
			

							
								hist_th[gene] = this.value;										
								var th_id = hist_th[gene] / bins_range[gene];
								
								
								
								var cur_reverse = reverse_sorted_indices[gene];
								
								for (var i=0; i<bins_ids[gene].length; i++)
								{
									if (i >= th_id)
									{
			
										var cur_bin = bins_ids[gene][i];
			
										for (var j=0; j<cur_bin.length; j++)
										{
											
											var cur_id = cur_bin[j];
											
											decs[gene][decs[gene].length] = cur_id;
											
											
											var sorted_id = cur_reverse[cur_id];
											
											
											cur_dots[sorted_id].setAttribute("class", "selected");
											
											sorted_decs[gene][sorted_decs[gene].length] = sorted_id;
											
										}
									}						
								}
								
								
								var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									cur_lasso_dots[sorted_dec[i]].setAttribute("class", "");
								}
								
								
								dec = new Array();
								sorted_dec = new Array();
								
								var first_gene = members[0];
								var first_dec = decs[first_gene];
								
								
								for (var i=0; i<first_dec.length; i++)
								{
									dec[i] = first_dec[i];
								}
								
								
								for (var i=1; i<members.length; i++)
								{
									var next_gene = members[i];
									var next_dec = decs[next_gene];
									
									
									
									
									dec = intersect(dec, next_dec);
									
								}
								
								
								
								if (hulls[lasso_gene].length > 0)
								{
								
								
									var lasso_reverse = reverse_sorted_indices[lasso_gene];
									
									
									for (var i=0; i<dec.length; i++)
									{
										var cur_id = lasso_reverse[dec[i]];
										
										sorted_dec[i] = cur_id;
										
										
										
										cur_lasso_dots[cur_id].setAttribute("class", "selected");
									}
								}
								
								else
								{
									for (var i=0; i<dec.length; i++)
									{
										var cur_id = dec[i];
										
										sorted_dec[i] = cur_id;
										
										cur_lasso_dots[cur_id].setAttribute("class", "selected");
										
									}
								}
								

								
								var cur_hist_x = d3.scaleLinear()
									.domain([0, histo_ex_max[gene]])
									.range([0, filtering_size]);

								
								d3.select("#selection" + gene)
									.attr("transform", "translate(" + cur_hist_x(hist_th[gene]) + ",0)")
									.attr("width", cur_hist_x(histo_ex_max[gene] - hist_th[gene]));

								
							}
						});
					
				}
				
	
			
				
				var lasso_bounding = d3.select(lasso_gene_id)["_groups"][0][0].getBoundingClientRect();
				
				d3.select('body')
					.append('div')

					.attr("id", "inputs_window")
					
					.style('width', ep_size + "px")
					
					.style('position', 'absolute')
					.style("margin", "0 auto")
					
					
	
				
					.style('left', lasso_bounding.left + 'px')

					.style('top', $(document).scrollTop() + lasso_bounding.top + lasso_bounding.height + font_size*2 + 'px')
					.style('display', 'block')
					.style('background-color', '#e2e2e2')
					.raise()
					.append('div')
					.attr("id", "set_center")
					.append('ol')

					.attr("id", "inputs")
					
					.style('position', 'absolute')
					.style("margin", "0 auto")
	

				d3.select('#inputs')
				
					.append("input")
					.attr("id", "density_plot")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Density Plot")
					.style("margin", "0 auto")
					.on("click", function() {
						
						if (dec.length > 2)
						{
						
							if (density_on)
							{
					
								
								
								if (final_selected.length > 0)
								{
								
									lasso_temp = new Array();
									
									var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
									for (var j=0; j<selected_density.length; j++)
									{
						
										cur_lasso_dots[selected_density[j]].setAttribute("class", "");
										
										
									}
									
									
									selected = new Array();
									
									final_selected = new Array();
									
									selected_density = new Array();

								}
								
								
								
								
								var cur_xy_dp = new Array();
							
								var cur_indices_dp = sorted_indices[lasso_gene];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices_dp[j]];
									
									cur_xy_dp[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								var cur_dom = dom_arr[dim_id] * (11/10);
										
								var cur_x2 = d3.scaleLinear()
												.domain([-cur_dom, cur_dom])
												.range([0, ep_size]);
									

								
								d3.select(lasso_gene_id).select("#mep_dots")
								.selectAll('circle')
								.data(cur_xy_dp)
								.attr("cx", function(d) {return cur_x2(d[0])})
								.attr("cy", function(d) {return cur_x2(-d[1])})
								
						
							
								
								
								d3.select(lasso_gene_id).select("#mep_dots")
									.selectAll('circle')
									.data(ex_colors[lasso_gene])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
								
					
								

								var cur_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									
									cur_dots[sorted_dec[i]].setAttribute("class", "selected");
								
									
								}
						
								
								d3.select("#legend").remove();
								
								for (var i=0; i<members.length; i++)
									document.getElementById("selection_slider" + members[i]).disabled = false;
								
									
								density_on = false;
								
								d3.select('#density_plot').attr("value", "Density Plot");
								d3.select('#lasso_cancel').style('display', 'none');
								d3.select('#done').style('display', 'none');
							}
							
							else
							{
								final_selected = new Array();
									
								selected_density = new Array();
								
								
								d3.select('body')									
									.append('div')											
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')
									.style('top', $(document).scrollTop() + height/2 + 'px')		
									.style('display', 'block')
									.raise()
								
								d3.select('#density_plot').attr("value", "Return to Expression Threshold Selection");
								d3.select('#lasso_cancel').style('display', 'block')
								d3.select('#done').style('display', 'block')
								
								
								// 201125 density_plot group
                                
                                var dec_num = dec.length;
                                
                                var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                                  + rds_name + "_" + nrow + "_" + n_dims + "_" + dim_id + "_" + dec_num;
                                  
                                  
                                for (var i=0; i<dec_num; i++)
								{
									
                                    density_string = density_string + " " + dec[i];     
								}
                                  
                                 
 
                                  
                                console.time("density_plot.py time:");	
                                            
                                $.ajax({
                                    async: true,
                                
                                    url: "density_plot.py",
                                    type: 'POST',
                                    
                                    contentTpye: 'application/json',
                                    dataType: 'json',
                                
                                    data: {'fd_ld': density_string},
                                    
                                    success: function(response){
                                        
                                        var endTime2 = new Date().getTime();
                                        
                                        console.timeEnd("density_plot.py time:");
                                        
                                        console.log("density_plot.py finish");
                                        
                                 
                                       
                                        
                                        var density_values = response["density"];
                                        
                                        
           
							
										density_indices = new Array();
									
										
										
										for (var j = 0; j < dec_num; ++j) density_indices[j] = j;
										density_indices.sort(function (a, b) { return density_values[a] < density_values[b] ? -1 : density_values[a] > density_values[b] ? 1 : 0; });
									
              
										
										var cur_xy_dp = new Array();
					
										var ori_count = 0;
					
										for (var i=0; i<nrow; i++)
										{
											var cur_index;
                                            
                                            if (i < (nrow-dec_num))
                                            {
                                                var ori_id = dec.indexOf(ori_count);
                                                
                                                while(ori_id != -1)
                                                {
                                                    ori_count++;
                                                    
                                                    ori_id = dec.indexOf(ori_count);
                                                }
                                                
                                                cur_index = dimensions[ori_count];
                                                
                                                ori_count++;
               
                                            }
                                            
                                            else
                                            {
                                          
                                                cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                               }
                                            
                                            cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            
                                            
                                          
										}
										
										
										
                                        
                                        
                                        var density_min = Number.MAX_VALUE;
                                        var density_max = Number.MIN_VALUE;
                                        
                                        for (var i=0; i<dec_num; i++)
                                        {
                                            var cur_density = density_values[i];
                                            
                                            if (cur_density < density_min)
                                                density_min = cur_density;
                                            
                                            if (cur_density > density_max)
                                                density_max = cur_density;
                                        }
                                        
                 
                                        var density_range = (density_max - density_min) / 4;
                                        
                                            var color_scale = d3.scaleLinear()
                                                            .domain([density_min, density_min+density_range, density_min+2*density_range, density_min+3*density_range, density_max])
                                                                                        .range(["#2166AC", "#92C5DE", "#F7F7F7", "#F4A582", "#B2182B"]);

                                        
                                        
                                        density_colors = new Array();
                                        
                                        
                                        for (var i=0; i<nrow; i++)
                                        {
                                            if (i < (nrow-dec_num))
                                            {
              
                                                density_colors[i] = "#E2E2E2";
                                            }
                                            
                                            else
                                            {
                                  
                                                density_colors[i] = color_scale(density_values[density_indices[i - (nrow-dec_num)]]);
                                            }
                    
                                        }
                                       
                                        
                                               var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
			
										for (var i=0; i<sorted_dec.length; i++)
										{
											
											
											cur_circle[sorted_dec[i]].setAttribute("class", "");
										
											
										}
                                        
                                        
                                        
										
										
                                        
                                        var cur_dom = dom_arr[dim_id] * (11/10);
										
										var cur_x2 = d3.scaleLinear()
														.domain([-cur_dom, cur_dom])
														.range([0, ep_size]);
										
										
										d3.select(lasso_gene_id).select("#mep_dots")
										.selectAll('circle')
										.data(cur_xy_dp)
										.attr("cx", function(d) {return cur_x2(d[0])})
										.attr("cy", function(d) {return cur_x2(-d[1])})	
                                        
                                        d3.select(lasso_gene_id).select("#mep_dots")
                                        .selectAll('circle')
                                        .data(density_colors)
                                        .attr("fill", function(d) {
                                        return d});
                                        
                                        
                                        
                                        
                     
                                        d3.select("#"+lasso_gene).append("defs")
                                            .append("linearGradient")
                                            .attr("id", "legend-density")
                                            .attr("x1", "0%").attr("y1", "0%")
                                            .attr("x2", "100%").attr("y2", "0%")
                                            .selectAll("stop") 
                                            .data([
                          
                                                
                                                {offset: "0%", color: "#2166AC"},
                                                {offset: "25%", color: "#92C5DE"},
                                                {offset: "50%", color: "#F7F7F7"},
                                                {offset: "75%", color: "#F4A582"},
                                                {offset: "100%", color: "#B2182B"}

                                             
                                              ])
                                            .enter().append("stop")
                                            .attr("offset", function(d) { return d.offset; })
                                            .attr("stop-color", function(d) { return d.color; });
                                   
                                   
                                        var legned_div_w = ep_size;
                                        var legned_div_h = font_size*5;
                                        
                                        var legendWidth = legned_div_w - 2;
                                        var legendHeight = font_size;

                                        var cur_legend_bounding = d3.select("#"+lasso_gene)["_groups"][0][0].getBoundingClientRect();
                              
                                        var legendsvg = d3.select('body')
                                            .append('div')
                                            .attr("id", "legend")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .style('position', 'absolute')
                                                .style('left', cur_legend_bounding.left + 'px')
                                            .style('top', $(document).scrollTop() + cur_legend_bounding.top - legned_div_h + 'px')
                                                     .style('display', 'block')
                                            .style('background-color', '#e2e2e2')
                                            .raise()
                                            
                                            .append("svg")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .append("g")
                                            .attr("class", "legendWrapper")
                                            .attr("transform", "translate(" + legned_div_w/2 + "," + legned_div_h/2 + ")");
                                            
                                         
                                  
                                         
                                        
                                        var tri_size = font_size * 0.7;
                                        
                                        var tri_scale = d3.scaleLinear()
                                            .domain([0, 1])
                                            .range([-legendWidth/2, legendWidth/2]);
                                        
                                        
                                        var legend_scale = d3.scaleLinear()
                                             .domain([0, legendWidth])
                                             .range([0, 1]);
                              
                                        legendsvg
                                            .append("rect")
                                            .attr("class", "legendRect")
                                            .attr("x", -legendWidth/2)
                                            .attr("y", 0) 
                                                    
                                            .attr("width", legendWidth)
                                            .attr("height", font_size)
                                            .style("fill", "url(#legend-density)")
                                            .on("click", function() 
                                            {                  
                                                var dim = this.getBoundingClientRect();
                                                var x = d3.event.pageX - dim.left;
                            
                                                
                                                density_th = legend_scale(x);
                                                console.log("density_th: " + density_th);
                                                
                                                
                                                var cur_offset = tri_scale(density_th);
                                                
                                                d3.select("#triangle")
                                                .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0");
                                              
                                            });
                             
                                            
                                            
                                        var cur_offset = tri_scale(density_th);
                                        
                                        legendsvg
                                            .append("path")  
                                            .attr("id", "triangle")
                        
                                            .attr("x", 0)
                                            .attr("y", -tri_size)
                                            .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0")
                                              .attr("fill", "Black");

    
                                            
                             
                                        legendsvg.append("text")
                                            .attr("class", "legendTitle")
                                            .attr("x", 0)
                             
                                            .attr("y", -font_size-tri_size)
                                            .style("text-anchor", "middle")
                                            .style("font-size", font_size*0.8+"px")  
                                            .text("Normalized local density");

                    
                                        var xScale = d3.scaleLinear()
                                             .range([-legendWidth/2, legendWidth/2])
											 .domain([0.0, 1.0]);
                  
                                              
                                        var xAxis = d3.axisBottom(xScale)                                 
                                              .ticks(5);                                      
                                 

                                        legendsvg.append("g")
                                            .attr("class", "axis")
                                            .attr("transform", "translate(0," + font_size + ")")
                                            .style("font-size", font_size*0.5+"px")  
                                            .call(xAxis);
                                        
                                       
                                        
                	
                                        
                                        for (var i=0; i<members.length; i++)
											document.getElementById("selection_slider" + members[i]).disabled = true;

														
										density_on = true;	
										
										
										var lasso_start = function() {
					
											if (density_on)
												lasso.items()				
										};
										
										
										var lasso_draw = function() {

										};
										
										
						
										
										var lasso_end = function() {
											

											if (density_on)
											{
											
												
												lasso_temp = lasso.selectedItems();
												
												
												selected = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
												
										
											
												var temp_id = 0;
												
												var cur_final_legnth = final_selected.length;
													
												var first = true;
											
												for (var j=0; j<selected.length; j++)
												{
													var cur_density_id = selected[j];
													
													var offset = nrow-dec.length;
												  

								   
													if (cur_density_id >= offset)
													{
														if (first)
														{
															final_selected[cur_final_legnth] = new Array();
															
															temp_id = selected_density.length;
															
															first = false; 
														}
														
														final_selected[cur_final_legnth][final_selected[cur_final_legnth].length] = dec[density_indices[cur_density_id-offset]];
														
											
														
														selected_density[selected_density.length] = cur_density_id;
													}
													
										 
												}
												
												
												var lasso_gene_id = "#" + lasso_gene;
												var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
													
						
												for (var j=temp_id; j<selected_density.length; j++)
												{
									
													cur_lasso_dots[selected_density[j]].setAttribute("class", "selected");
												}
					
											}
											
											
											
											

										};
										
										
										var svg_name = '#' + lasso_gene;

										
										var lasso = d3.lasso()
										.closePathSelect(true)
										.closePathDistance(100)
				
										.items(d3.select(svg_name).select("#mep_dots").selectAll("circle"))
		
										.targetArea(d3.select(svg_name))

										.on("start",lasso_start)
										.on("draw",lasso_draw)
										.on("end",lasso_end);	
										
							
										d3.select(svg_name).call(lasso);
										
										
										
										
										d3.select(".loader").remove();
                                    }
                                });
								
                                
                                
                                
                              
								
							}
						}
						
						else
						{
							alert("Please select cells first.");
						}
					})
				
	
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "lasso_cancel")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Lasso Cancel")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						if (final_selected.length > 0)
						{
						
							lasso_temp.classed("selected",false);
						
						
						
							lasso_temp = new Array();
							
							
							
							
							
							
						
							
							var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
							for (var j=0; j<selected_density.length; j++)
							{
				
								cur_lasso_dots[selected_density[j]].setAttribute("class", "");
							}
							
							
							final_selected = new Array();
							
							selected_density = new Array();
							
							
							selected = new Array();
							
							
		

							alert("Cancellation Complete.");
						}
						
						else
						{
							alert("No selection.")
						}
					
					});
				

					
				d3.select('#inputs')
				.append("input")
				.attr("id", "done")
				.attr("class", "texts")
				.attr("type", "button")
				.attr("value", "Done")
				.style('display', 'none')
				.style("margin", "0 auto")
				.on("click", function() {
					
					

                    if (density_on)
					{
					
						d3.select('body')									
							.append('div')											
							.attr('class', 'loader')
							.style('position', 'absolute')
							.style('left', width/2 + 'px')
							.style('top', $(document).scrollTop() + height/2 + 'px')		
							.style('display', 'block')
							.raise();
					
					
                        console.log("The number of final selected hulls: " + final_selected.length);
							
			
							
                        lasso_temp = new Array();
                        
                        cell_ids[lasso_gene] = new Array();
						
						temp_cell_ids = new Array();
						
						if (final_selected.length > 0)
						{						
							for (var i=0; i<final_selected.length; i++)
							{								
								temp_cell_ids[i] = new Array();
								
								for (var j=0; j<final_selected[i].length; j++)
								{
									cell_ids[lasso_gene][cell_ids[lasso_gene].length] = final_selected[i][j];
									
									temp_cell_ids[i][j] = final_selected[i][j];
								}
							}
						}
						
						else
						{
							temp_cell_ids[0] = new Array();
							
							for (var i=0; i<dec.length; i++)
							{								
								cell_ids[lasso_gene][cell_ids[lasso_gene].length] = dec[i];
								
								temp_cell_ids[0][i] = dec[i];
								
							}
						}
						
						
						console.log("temp_cell_ids");
						console.log(temp_cell_ids);
						
	
						
						
						
						var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
						for (var j=0; j<selected_density.length; j++)
						{
			
							cur_lasso_dots[selected_density[j]].setAttribute("class", "");
						}
						
						
						final_selected = new Array();
						
						selected_density = new Array();
						
						
						
						intersect_tf = false;
                        
                        new_groups[0] = lasso_gene;
                        
                        
                        d3.select("#legend").remove();
						
						calculate_groups();
						
                        
                        
                        
                        
                        
		
					}
					
					else
					{
						alert("Please click this button after performing Lasso Selection on Density Plot.");
					}
					
				});
			}	
		}		
		
		
		

		function all_genes_done ()
		{
			
			
			
			
			
			total = new Array();
			for (var i=0; i<n_dims; i++)
			{
				total[i] = 0;
			}
			
			
			
			
			if (cur_groups.length > 0)
			{
				for (var i=0; i<cur_groups.length; i++)
				{
					for (var j=0; j<n_dims; j++)
					{
						
						
		
						total[j] += areas_ratio[cur_groups[i]][j];
					}
				}
			}
			
			

			
			
			
			var total_size = cur_groups.length + total_markers.length;
			
			if (total_size != 0)
			{
				for (var i=0; i<n_dims; i++)
				{
					total[i] /= total_size;
				}
			}
			

			
			var largest_ratio = -1;
			
			for (var i=0; i<n_dims; i++)
			{
				if (total[i] > largest_ratio)
				{
					largest_ratio = total[i];
					largest_dim["Total"] = i;
				}	
			}
			
			
			
			
			
			heatmap_data = new Array();
			
			

			
			
			var ratio_arr = new Array();
			
			for (var i=fd_num; i<=ld_num; i++)
			{
				var cur_cn = total[i-fd_num];
				
				if (cur_cn != 1)
				{
					ratio_arr[ratio_arr.length] = cur_cn;
				}
			}

			var colorDomain = d3.extent(ratio_arr, function(d){return d;});
			var colorScale = d3.scaleLinear()
				.domain(colorDomain)

                .range(["#e39a24", "#fbfca4"]);
			
			for (var i=fd_num; i<=ld_num; i++)
			{
				var cur_id = heatmap_data.length;
				var cur_cn = total[i-fd_num];
				
				heatmap_data[cur_id] = new Object;
				heatmap_data[cur_id].dim = String(i);
				heatmap_data[cur_id].gene = "Total";
				
				if (cur_cn == 1)
				{

                    heatmap_data[cur_id].color = "white"; 
					
				}
				
				else
					heatmap_data[cur_id].color = colorScale(cur_cn);
				
				heatmap_data[cur_id].circles = cur_cn;

			}
			

			
			
		
			

			
			
			for (var i=0; i<cur_markers.length; i++)
			{
		
				
				var ratio_arr = new Array();
			
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_cn = areas_marker[cur_markers[i]][j-fd_num];
					
					ratio_arr[ratio_arr.length] = cur_cn;

				}
				
   
                
				var colorDomain = d3.extent(ratio_arr, function(d){return d;});
				var colorScale = d3.scaleLinear()
					.domain(colorDomain)
                    .range(["#c2e0f2", "#2c8ec7"]);
				
				
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_id2 = heatmap_data.length;
					
	
					
					var cur_area = areas_marker[cur_markers[i]][j-fd_num];
					
					heatmap_data[cur_id2] = new Object;
					heatmap_data[cur_id2].dim = String(j);
					heatmap_data[cur_id2].gene = cur_markers[i];
					
					
					
					heatmap_data[cur_id2].color = colorScale(cur_area);
				
					heatmap_data[cur_id2].circles = cur_area;
					
					

					
					
				}
				

			
			}
			
			
			for (var i=0; i<cur_groups.length; i++)
			{
		
				
				
				var ratio_arr = new Array();
			
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_cn = areas_ratio[cur_groups[i]][j-fd_num];
					
					if (cur_cn != 1)
					{
						ratio_arr[ratio_arr.length] = cur_cn;
					}
				}
				

                
				var colorDomain = d3.extent(ratio_arr, function(d){return d;});
				var colorScale = d3.scaleLinear()
					.domain(colorDomain)

                    .range(["#e39a24", "#fbfca4"]);
					
		
				
				
				
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_id3 = heatmap_data.length;
					

					var cur_area = areas_ratio[cur_groups[i]][j-fd_num];
					
					heatmap_data[cur_id3] = new Object;
					heatmap_data[cur_id3].dim = String(j);
					heatmap_data[cur_id3].gene = cur_groups[i];
					
					if (cur_area == 1)
					{

                        heatmap_data[cur_id3].color = "white"; 
					}
					
					else
						heatmap_data[cur_id3].color = colorScale(cur_area);
					
					heatmap_data[cur_id3].circles = cur_area;
					
	
				}
		
			}
			
			
		
			console.log("all_genes_done finish");
			
			draw_heatmap();
		}
		
		
		$(document).ready(function(){
			$("#add_total_button").click(function(){
				
				if (rds_exist)
				{
					var added_total_markers = document.getElementById("added_markers").value; 
					var atml = added_total_markers.split(" ");
					  
					  
					var si = atml.indexOf("");
					while (si!=-1)
					{
						atml.splice(si, 1);
						si = atml.indexOf("");
					}
					
					atml = Array.from(new Set(atml));
					
					
					var valid_markers = new Array();
					
					for (var i=0; i<atml.length; i++)
					{
						if (markers.indexOf(atml[i]) != -1)
						{
							valid_markers[valid_markers.length] = atml[i];
							
							var ti = total_markers.indexOf(atml[i]);
							
							if (ti==-1)
								total_markers[total_markers.length] = atml[i];
						
						}
					}
					
					if (valid_markers.length > 0)
					{
						all_genes_done();
					}
					
					else
					{
						alert("Please enter correct markers.");
					}
					
					
					
					
					
				}
				
				else
				{
					alert("Please add marekrs first.");
				}
			});
		});
		
		
		
		$(document).ready(function(){
			$("#remove_total_button").click(function(){
				
				if (rds_exist)
				{
					var removed_total_markers = document.getElementById("added_markers").value; 
					var rtml = removed_total_markers.split(" ");
					  
					  
					var si = rtml.indexOf("");
					while (si!=-1)
					{
						rtml.splice(si, 1);
						si = rtml.indexOf("");
					}
					
					rtml = Array.from(new Set(rtml));
					
					
					var r_count = 0;
					
					for (var i=0; i<rtml.length; i++)
					{
						
						var ri = total_markers.indexOf(rtml[i]);
						
						if ( ri != -1)
						{
							
							
							total_markers.splice(ri, 1);
							
							r_count++;
						
						}
					}
					
					if (r_count > 0)
					{
						all_genes_done();
					}
					
					else
					{
						alert("Please enter correct markers.");
					}
					
					
					
					
					
				}
				
				else
				{
					alert("Please add marekrs first.");
				}
			});
		});
		
		
		
		

		$(document).ready(function(){
			$("#remove_groups_button").click(function(){
				
				
				if (rds_exist)
				{
				
					var removed_groups = document.getElementById("added_markers").value; 
					var removed_groups_list = removed_groups.split(" ");
				  
				  
					var si = removed_groups_list.indexOf("");
					while (si!=-1)
					{
						removed_groups_list.splice(si, 1);
						si = removed_groups_list.indexOf("");
					}
					

					removed_groups_list = Array.from(new Set(removed_groups_list));
					
					
                    rem = new Array();
                    
                    for (var i=0; i<removed_groups_list.length; i++)
                    {
                        var cur_group_name = removed_groups_list[i];
                        

                            var ci = cur_groups.indexOf(cur_group_name);
                            
                            if (ci!=-1)
                            {
                                cur_groups.splice(ci, 1);
                                
                                var oi = markers_on.indexOf(cur_group_name);
                                if (oi!=-1)
                                {
                                    markers_on.splice(oi, 1);
                        
                                    
                                    rem[rem.length] = cur_group_name;
                                    

                                }
   				
                            }
       
                    }
                    
                    y_length = 1 + cur_groups.length + cur_markers.length;
                        
                    var cur_height = y_length*unit_height;
                    var half_height = height/2;
                    
                    if (cur_height > half_height)
                    {
                        rec_height = half_height/y_length;
                    }
                    else
                        rec_height = unit_height;
                    
					
					if (cur_groups.length > 0)
					{
						calculate_overlap();
					}
					

                    
                    draw_markers_plots();

                    all_genes_done();	
                    
                    

				}
				
				
			
				else
				{
					alert("Please add markers first.");
				}
			});
		});
		 
		 
		 
		 
		



		



		 $(document).ready(function(){
			$("#add_groups_button").click(function(){

				
				if (rds_exist)
				{
					
				
				
					console.log("Add group strart");
					
					d3.select('body')
					.append('div')
					.attr('class', 'loader')
					.style('position', 'absolute')
					.style('left', width/2 + 'px')		
					
					.style('top', $(document).scrollTop() + height/2 + 'px')
			

					console.log("Add group end");
			
					var run_time = new Date().getTime();
			
					
					
					
					added_groups = document.getElementById("added_markers").value;
          
					added_groups_list = added_groups.split(" ");
				  
				  
					var si = added_groups_list.indexOf("");
					while (si!=-1)
					{
						added_groups_list.splice(si, 1);
						si = added_groups_list.indexOf("");
					}
					
					added_groups_list = Array.from(new Set(added_groups_list));
                    
                    
                    
                   
                    
                    for (var i=0; i<added_groups_list.length; i++)
                    {
                        var cur_group_name = added_groups_list[i];
                        
                        if (cur_group_name.indexOf("_") != -1)
                        {
                           
                            
                            var cur_group_markers = cur_group_name.split("_");
                            
                            var valid_marker_check = 0;
                            
                            for (var j=0; j<cur_group_markers.length; j++)
                            {
                                if (markers.indexOf(cur_group_markers[j])!=-1)
                                {
                                    valid_marker_check++;
                                }
                            }
                            
                            if (valid_marker_check == cur_group_markers.length)
                            {
                                if (groups.indexOf(cur_group_name) == -1 )
                                {

                                    new_groups[new_groups.length] = cur_group_name;
                                    
                                   
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                    
                                    groups[groups.length] = cur_group_name;
                
                                }
                                
                                else if (cur_groups.indexOf(cur_group_name) == -1)
                                {
                                    old_groups[old_groups.length] = cur_group_name;
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                }
       
                                
                            }
                        }
						
						else
						{  
                            if (markers.indexOf(cur_group_name)!=-1)
                            {
                                if (groups.indexOf(cur_group_name) == -1 )
                                {

                                    new_groups[new_groups.length] = cur_group_name;
                                    
                                   
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                    
                                    groups[groups.length] = cur_group_name;
                                    
                 
                                    
                                }
                                
                                else if (cur_groups.indexOf(cur_group_name) == -1)
                                {
                                    old_groups[old_groups.length] = cur_group_name;
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                }
       
                                if (cur_markers.indexOf(cur_group_name) != -1)
								{
									rem = new Array();
					

					
									var ci = cur_markers.indexOf(cur_group_name);
									if (ci!=-1)
									{
										cur_markers.splice(ci, 1);
										
										var oi = markers_on.indexOf(cur_group_name);
										if (oi!=-1)
										{
											markers_on.splice(oi, 1);											
											
											rem[rem.length] = cur_group_name;
										}
									}
									
							
									console.log("remove_button - rem");
									console.log(rem);
								
									draw_markers_plots();
								}
                            }
						}
                    }
                    
		
				
					if (new_groups.length>0 || old_groups.length>0)
					{								
						y_length = 1 + cur_groups.length + cur_markers.length;
						
						
						var cur_height = y_length*unit_height;
						var half_height = height/2;
						
						if (cur_height > half_height)
						{
							rec_height = half_height/y_length;
						}
						else
							rec_height = unit_height;
						
						
						

								
						
						
						
						
		
						if (new_groups.length>0)
						{			
							if (groups.length == 1)
							{
								overlap_groups[groups[0]] = new Array();
							}
							
							else
							{
								for (var j=0; j<new_groups.length; j++)
								{
									var cur_new_group = new_groups[j];
									
									overlap_groups[cur_new_group] = new Array();
								}
								
								
								for (var j=0; j<new_groups.length; j++)
								{
									var cur_new_group = new_groups[j];
			
																	
									
									for (var i=0; i<groups.length; i++)
									{
										var cur_group = groups[i];
										
										if (cur_new_group != cur_group)
										{
										
											overlap_groups[cur_group][overlap_groups[cur_group].length] = cur_new_group;
											
											overlap_groups[cur_new_group][overlap_groups[cur_new_group].length] = cur_group;
										}
								
									}
								}
							}
                            
							
							calculate_groups();
							
							
						}
						
						else
						{
							all_genes_done();
						}
					}
					else
					{
						alert ("Please enter correct markers in the correct form (markerA_markerB markerC_markerD_markerE).")
						
						d3.select('.loader').remove();
					}
				}
				
				
				
				else
				{
					alert("Please add markers first.");
				}
				 
			}); 
		});



		 $(document).ready(function(){
			$("#remove_button").click(function(){
				
				if (rds_exist)
				{
				
					var removed_markers = document.getElementById("added_markers").value; 
					var removed_markers_list = removed_markers.split(" ");
				  
				  
					var si = removed_markers_list.indexOf("");
					while (si!=-1)
					{
						removed_markers_list.splice(si, 1);
						si = removed_markers_list.indexOf("");
					}
					
					removed_markers_list = Array.from(new Set(removed_markers_list));
					
					
					
					var rmc = 0;
					rem = new Array();
					
					for (var i=0; i<removed_markers_list.length; i++)
					{
						
						
						var ci = cur_markers.indexOf(removed_markers_list[i]);
						if (ci!=-1)
						{
							cur_markers.splice(ci, 1);
							
							var oi = markers_on.indexOf(removed_markers_list[i]);
							if (oi!=-1)
							{
								markers_on.splice(oi, 1);
								
								rmc++;
								
								rem[rem.length] = removed_markers_list[i];
							}
						}
						
						
						
					}
					
					
					y_length = 1 + cur_groups.length + cur_markers.length;
				
					var cur_height = y_length*unit_height;
					var half_height = height/2;
					
					if (cur_height > half_height)
					{
						rec_height = half_height/y_length;
					}
					else
						rec_height = unit_height;
					
					
					

					
			
					console.log("remove_button - rem");
					console.log(rem);
				
					draw_markers_plots();
							
					all_genes_done();
				}
				
				
				else
				{
					alert("Please add markers first.");
				}
				
			});
		 });





		$(document).ready(function(){
			$("#add_button").click(function(){

				if (first_add)
				{
				
					var today = new Date();   

                    var hours = ('0' + today.getHours()).slice(-2); 
                    var minutes = ('0' + today.getMinutes()).slice(-2);
                    var seconds = ('0' + today.getSeconds()).slice(-2); 

                    timeString = hours + ':' + minutes  + ':' + seconds;

                    console.log(timeString);
					
					
					rds_name = d3.select('#rds')["_groups"][0][0].value;
					rds_name_only = rds_name.replace('.rds', '')
					
					
					
					var rds_path = "../rscripts/" + rds_name;
					
					
					$.ajax({
						async: false,
						type: "POST",
						url: "../rscripts/rds_check.r",					
						data: rds_name,					 
						contentType: "application/json" ,

						success: function(response){
						

							if (response=="true")
							{
								rds_exist = true;
							}
							else
							{
								alert("The file you entered does not exist in the server.");
							}
						}
					});
					
					
					if ((document.getElementById("fd").value != "") && (document.getElementById("ld").value != ""))
					{
						rds_exist = true;
					}
					
					else
					{
						rds_exist = false;
					}
		
				}
				
				
				if (rds_exist)
				{
				
				
					d3.select('body')
						.append('div')
						.attr('class', 'loader')
						.style('position', 'absolute')
						.style('left', width/2 + 'px')
						
						.style('top', $(document).scrollTop() + height/2 + 'px')
						
			
					var run_time = new Date().getTime();
			
					
					if (first_add)
					{					
						d3.select("#card_heatmap").style("display", "block");	
                        d3.select("#card_cluster_plot").style("display", "block");	
						d3.select("#card_meps").style("display", "block");	
						d3.select("#card_plot_size").style("display", "block");	
						d3.select("#card_animation").style("display", "block");	
						
						
						state = 0;
						
						n_dims = Number(document.getElementById("ld").value) - Number(document.getElementById("fd").value) + 1;
						
						markers = new Array();
						cur_markers = new Array();
						
						groups = new Array();
						
						cur_groups = new Array();
					
						
						markers_on = new Array();
						
						selected_dim = "empty";
						
						
						
						
						
						expressions = new Object;
						circles = new Object;
						
						
						ndots = 100;
						
						
						
					
						
						svg_width = smaller/4;
						
						dom = 60; 
							
						
							
							
						point_color = [0, 0, 255];
						base_color = [226, 226, 226];
						
						dr_y = 25;
						
						mpn = 0;
						
						selected = new Array();
						
						max_ep = 9;
						
						dim_id = -1;
						

						
						
                        new_groups = new Array();
                        old_groups = new Array();
						
						group_name = "";
						
					
						
						eps = 2.0; 
						
				
						
						minPts = 0.04; 
						
						groups_params = new Object;
						
						heatmap_circles = new Object;
						

						heatmap_circles_x = new Object;
						
						
						ortho_size = 60;
						
						
						
						margin_size = font_size*2;
						hct = smaller * 0.001;
					
						heatmap_margin = {top: margin_size, right: margin_size, bottom: margin_size, left: margin_size*7};
						
						outer_width = d3.select('.outer')["_groups"][0][0].getBoundingClientRect().width;
						
						heatmap_width = outer_width - heatmap_margin.left - heatmap_margin.right;
						
						

						
						unit_height = height * 0.05;
						rec_height = unit_height;
						
						if ((unit_height * n_dims) > heatmap_width)
						{
							rec_width = heatmap_width / n_dims;
						}
						else
						{
							rec_width = unit_height;
							heatmap_width = rec_width * n_dims;
						}
						
			


						
						
						clustering_width = d3.select('#clustering')["_groups"][0][0].getBoundingClientRect().width;
							
						legend_size = width*0.015;	

						
						if (clustering_width > width*0.5)
						{
							plot_size = smaller*0.5;
							clustering_width = plot_size + legend_size;
						}
						else						
							plot_size = clustering_width - legend_size;
						
						
						ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
						ep_cell_size = ep_size*0.002;
						
						cell_size = smaller * 0.001;

					
						
						
						lasso_gene = "";
						
						
						deg_others = new Object;
						
						
						am = new Array();
						rem = new Array();
						dcm = new Array();
						ccm = new Array();
						rsm = new Array();
						
					
						
						ex_colors = new Object;
						
						lasso_temp = new Array();
						
					
						develop = "";
						
						num_bins = 19;
						
	
                        hist_margin = {top: 10, right: 10, bottom: margin_size, left: margin_size*1.5};
						
						
						areas = new Object;
						areas_marker = new Object;
						
						heatmap_groups = new Object;
								
						heatmap_genes = new Object;
						
						genes_stride = 1;
						
						
						
						cell_ids = new Object;
						filtered_ids = new Object;
						
						fd_num = Number(document.getElementById("fd").value);
						ld_num = Number(document.getElementById("ld").value);
						
						total_markers = new Array();
						
						ex_maxs = new Object;
                        ex_mins = new Object;
						
						
						filtering_on = false;
						density_on = false;
						
						
						markers_ani = new Array();
						cur_marker_ani = "";
						new_marker_ani = "";
						old_marker_ani = "";
						
						sorted_final_selected = new Array();
						final_selected = new Array();
						selected = new Array();
						
						hulls = new Object;
	
						
						line = d3.line().curve(d3.curveLinearClosed);
						
						intersect_tf = true;
						
						sorted_indices = new Object;
						reverse_sorted_indices = new Object;
						
						largest_dim = new Object;
						
						
						selected_cp = new Array();
						lasso_cp = new Array();
						
						cp_window_tf = false;
                        
                
						density_th = 0.1;
						
						dom_arr = new Array();
						
						overlap_groups = new Object;
						areas_ratio = new Object;
						inter_groups = new Object;
						
						path_diff = new Object;
						path_inter = new Object;
						
						group_colors = new Object;
						cur_color_id = 2;
						
						hulls_mean = new Object;
						
						path_diff_dom = new Object;
						path_inter_dom = new Object;
						hulls_dom = new Object;
						
						row_sizes = new Object;
			
						d3.select("#vsb")
							.append("text")
							.attr("id", "stop_plot_size_change")
							.attr("text-anchor", "middle")
							.style("font-size", font_size_str)
							.style("display", "none")
							.text("Please turn off cell filtering mode to change plot size.");
                            
                        labels = new Array();
                        
        
                        var gt_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
                        + document.getElementById("ld").value + "/gt.csv";
            
                        var req = new XMLHttpRequest();
                        req.open("GET", gt_path, false); 
                        req.send(null);

                        var lines = req.responseText.split('\n');
                        
                        gt = new Array();
                        
                        for (var i=0; i<lines.length-2; i++)
                        {               
                            gt[i] = Number(lines[i+1].split("\r")[0])																								
                                                                    
                        }
                        
         
                        
                        
                        var pca_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
                        + document.getElementById("ld").value + "/pca.csv";
                    
                        var req_pca = new XMLHttpRequest();
                        req_pca.open("GET", pca_path, false); 
                        req_pca.send(null);

                        var pca_lines = req_pca.responseText.split('\n');
                        
                        
                        
                        pca = new Array();
                        
                        for (var i=0; i<pca_lines.length-2; i++)
                        {
                            
                            pca[i] = pca_lines[i+1].split(",");																								
                            												
                        }
                        
                        first_update_clu = true;
							
						
		
					}
					
                    

					
					
					added_markers = document.getElementById("added_markers").value; 
					added_markers_list = added_markers.split(" ");
				  
				  
					var si = added_markers_list.indexOf("");
					while (si!=-1)
					{
						added_markers_list.splice(si, 1);
						si = added_markers_list.indexOf("");
					}
					
					added_markers_list = Array.from(new Set(added_markers_list));
					
					
					for (var i=(added_markers_list.length-1); i>=0; i--)
                    {                      
                        if (added_markers_list[i].indexOf("_") != -1)
                        {
                            added_markers_list.splice(i, 1); 
                        }
                    }
					
					
					if (added_markers_list.length > 0)
						add_degs();
					
					else
					{
						alert("Please enter markers.");
						
						d3.select('.loader').remove();
					}
				
				}

				
			}); 
		}); 

		

        function draw_gt_cluster_plot()
		{
			d3.select("#card_cluster_plot").style("display", "block")
			
			if (!first_plots)
			{
				d3.select("#clustering").select("svg").remove();	
			}
			
			else
			{
				first_plots = false;
			}

			
			var cur_clustering = new Array();

			for (var i=0; i<nrow; i++)
			{
				
				
				cur_clustering[i] = new Array();
				
				cur_clustering[i][0] = Number(dimensions[i][1+2*dim_id]);
				cur_clustering[i][1] = Number(dimensions[i][1+2*dim_id+1]);

                cur_clustering[i][2] = Number(gt[i]);
				cur_clustering[i][3] = i;
			}
			
		
			
			cur_clustering.sort(function (a,b){ return a[2] - b[2] });
			
			
			
			
			
			
			
			var svg_clustering = d3.select("#clustering")	
			.append("svg")
			.attr("width", clustering_width)
			.attr("height", clustering_width)



			var legend_str = 'translate(' + legend_size + ',0)';
			var g = svg_clustering.append('g')
			.attr('transform', legend_str);


			var legend_font_size = (font_size*2)/3 + "px";
			var legend_trans = 'translate(' + smaller*0.007 + ',' + smaller*0.007 + ')';
			var colorLegendG = svg_clustering.append('g')
			.attr('transform', legend_trans)
			.style("font-size", legend_font_size);


			const colorScale = d3.scaleOrdinal()
			
			.range(d3_category437);

			
			var legend_circle_size = smaller * 0.002;
			const colorLegend = d3.legendColor()
			.scale(colorScale)
			.shape('circle')
			.shapeRadius(legend_circle_size);

			
			var cur_dom = dom_arr[dim_id] * (11/10);
										
			var cur_x = d3.scaleLinear()
							.domain([-cur_dom, cur_dom])
							.range([0, plot_size]);
			
			
			var dots = g.selectAll("circle")
			.data(cur_clustering).enter()
			.append("circle")
			.attr("id", function(d, i) {return d[3];})
			.attr("cx", function(d) {return cur_x(d[0])})
			.attr("cy", function(d) {return cur_x(-d[1])})
			.attr("r", cell_size)
			.attr("fill", function(d) {
			return colorScale(d[2])})
			

			colorLegendG.call(colorLegend)
			.selectAll('.cell text')
			.attr('dy', '0.005em');
			
			
			
			
		}

        

        function draw_updated_cluster_plot()
		{
			d3.select("#updated_cluster_plot").style("display", "block")
			
			if (!first_update_clu)
			{
				d3.select("#updated_clustering").select("svg").remove();	
			}
			
			else
			{
				first_update_clu = false;
			}

			
			var cur_clustering = new Array();

			for (var i=0; i<nrow; i++)
			{
				
				
				cur_clustering[i] = new Array();
				
				cur_clustering[i][0] = Number(dimensions[i][1+2*dim_id]);
				cur_clustering[i][1] = Number(dimensions[i][1+2*dim_id+1]);

                cur_clustering[i][2] = Number(labels[i]);
				cur_clustering[i][3] = i;
			}
			
		
			
			cur_clustering.sort(function (a,b){ return a[2] - b[2] });
			
			
			
			
			
			
			
			var svg_clustering = d3.select("#updated_clustering")	
			.append("svg")
			.attr("width", clustering_width)
			.attr("height", clustering_width)



			var legend_str = 'translate(' + legend_size + ',0)';
			var g = svg_clustering.append('g')
			.attr('transform', legend_str);


			var legend_font_size = (font_size*2)/3 + "px";
			var legend_trans = 'translate(' + smaller*0.007 + ',' + smaller*0.007 + ')';
			var colorLegendG = svg_clustering.append('g')
			.attr('transform', legend_trans)
			.style("font-size", legend_font_size);


			const colorScale = d3.scaleOrdinal()
			
			.range(d3_category437);

			
			var legend_circle_size = smaller * 0.002;
			const colorLegend = d3.legendColor()
			.scale(colorScale)
			.shape('circle')
			.shapeRadius(legend_circle_size);

			
			var cur_dom = dom_arr[dim_id] * (11/10);
										
			var cur_x = d3.scaleLinear()
							.domain([-cur_dom, cur_dom])
							.range([0, plot_size]);
			
			
			var dots = g.selectAll("circle")
			.data(cur_clustering).enter()
			.append("circle")
			.attr("id", function(d, i) {return d[3];})
			.attr("cx", function(d) {return cur_x(d[0])})
			.attr("cy", function(d) {return cur_x(-d[1])})
			.attr("r", cell_size)
			.attr("fill", function(d) {
			return colorScale(d[2])})
			

			colorLegendG.call(colorLegend)
			.selectAll('.cell text')
			.attr('dy', '0.005em');
			
			
			
			
		}
        
        
        
        
        const kNearestNeighbors = (data, labels, point, k = 3) => {
        const kNearest = data
            .map((el, i) => ({
              dist: Math.hypot(...Object.keys(el).map(key => point[key] - el[key])),
              label: labels[i]
            }))
            .sort((a, b) => a.dist - b.dist)
            .slice(0, k);

        return kNearest.reduce(
            (acc, { label }, i) => {
              acc.classCounts[label] =
                Object.keys(acc.classCounts).indexOf(label) !== -1
                  ? acc.classCounts[label] + 1
                  : 1;
              if (acc.classCounts[label] > acc.topClassCount) {
                acc.topClassCount = acc.classCounts[label];
                acc.topClass = label;
              }
              return acc;
            },
            {
              classCounts: {},
              topClass: kNearest[0].label,
              topClassCount: 0
            }
          ).topClass;
        };
            
			
        $(document).ready(function(){
			$("#save_labels_button").click(function(){
                
                d3.select('body')
                    .append('div')
                    .attr('class', 'loader')
                    .style('position', 'absolute')
                    .style('left', width/2 + 'px')
                    
                    .style('top', $(document).scrollTop() + height/2 + 'px')
            
                
                labels = new Array();
  
                pos_in_hulls = new Array();
                labels_in_hulls = new Array();
                
                var k = 3;
                
                for (var i=0; i<cur_groups.length; i++)
                {
                    var cur_group = cur_groups[i];
                    var filtered_ids_group = filtered_ids[cur_group];                   
                    
      
                    
                    for (var j=0; j<filtered_ids_group.length; j++)
                    {
                        var cur_ids = filtered_ids[cur_group][j];
                        var cur_ids_len = cur_ids.length;
           
                        for (var k=0; k<cur_ids_len; k++)
                        {
                            var cur_id = cur_ids[k];
                            
                            labels[cur_id] = i;
                            labels_in_hulls[labels_in_hulls.length] = i;
                            
               
                            
                            pos_in_hulls[pos_in_hulls.length] = pca[cur_id].slice(0, dim_id+2).map(e => {return Number(e);});
                            
                          
                        }
       
                    }
                }
                
                for (var i=0; i<dimensions.length; i++)
                {
                    var cur_label = labels[i];
        
                    if (typeof cur_label == "undefined")
                    {
                             
                        var cur_point = pca[i].slice(0, dim_id+document.getElementById("fd").value).map(e => {return Number(e);});
                        
                        labels[i] = kNearestNeighbors(pos_in_hulls, labels_in_hulls, cur_point, k);
                        
                       
                    }
                }
                

                  
                var metrics_string = fd_num + "_" + ld_num + "_" 
				  + rds_name + "_" + (dim_id+fd_num) + "_" + timeString + "_" + d3.select('#participant')["_groups"][0][0].value + "_" + labels[0];
                
                var labels_len = labels.length;
                
                
                for (var i=1; i<labels_len; i++)
                {   
                    metrics_string = metrics_string + " " + labels[i];                    
                }
            
												

                
                console.log("metrics.py start");
                            
                $.ajax({
                    async: true,
                
                    url: "metrics.py",
                    type: 'POST',
                    
                    contentTpye: 'application/json',
                    dataType: 'json',
                
                    data: {'metrics_string': metrics_string},
                    
                    success: function(response){
                
                

                        
                        
                        draw_updated_cluster_plot();
                        
                        console.log("metrics.py finish");
                        
                        d3.select('.loader').remove();
                    }
                });
                

                
                
            }); 
		});     



			 
		</script>
    </body>
</html>
