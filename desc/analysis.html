<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- <meta charset="utf-8" /> -->
        <!-- <meta http-equiv="X-UA-Compatible" content="IE=edge" /> -->
        <!-- <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> -->
        <!-- <meta name="description" content="" /> -->
        <!-- <meta name="author" content="" /> -->
        <!-- <title>Charts - SB Admin</title> -->
        <!-- <link href="css/styles.css" rel="stylesheet" /> -->
        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js" crossorigin="anonymous"></script> -->
		
		<link rel="shortcut icon" href="#">
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <!-- <meta name="description" content="" /> -->
        <!-- <meta name="author" content="" /> -->
        <title>DESC</title>
		<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
        <!-- <link href="css/styles.css" rel="stylesheet" /> -->
        <!-- <link href="https://cdn.datatables.net/1.10.20/css/dataTables.bootstrap4.min.css" rel="stylesheet" crossorigin="anonymous" /> -->
        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/js/all.min.js" crossorigin="anonymous"></script> -->
		<script src = "https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.1/Rx.min.js"></script>
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js" charset="utf-8"></script> -->
		 <link rel="stylesheet" href="d3-context-menu.css" />
		 <link href="css/styles.css" rel="stylesheet" />
		
		
		<style>
			body {
			  margin: 0;
			}

			

			.lasso path {
				stroke: rgb(80,80,80);
				stroke-width:2px;
			}

			.lasso .drawn {
				fill-opacity:.05 ;
			}

			.lasso .loop_close {
				fill:none;
				stroke-dasharray: 4,4;
			}

			.lasso .origin {
				fill:#3399FF;
				fill-opacity:.5;
			}

			.not_possible {
				fill: rgb(200,200,200);
			}

			.possible {
				fill: #EC888C;
			}

			.selected {
				fill: green;
			}
			
			.jb-large { font-size: large; }
			.jb-x-large { font-size: x-large; }
			.jb-xx-large { font-size: xx-large; }
			
			.texts { font-size: 15; }
			
			
			
			
			#playlist-wrapper ul li{
				height: 50px;
				overflow-y: hidden;
				overflow: auto;
				white-space: nowrap;
			}

			#playlist-wrapper{
				height: 150px;
				width:150px;
				overflow-y: hidden;
				overflow: auto;
				white-space: nowrap;
			}
			
			.outer {
			  display: flex; /* displays flex-items (children) inline */
			  overflow-x: auto;
			}
			
			input[type=range]::-webkit-slider-thumb { 
				-webkit-appearance: none; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
			
			}
				
			.slider::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 25px;
				height: 25px;
				border-radius: 50%;
				background: #4CAF50;
				cursor: pointer;
				
			}
			.slider {
				margin-top: 30px;
				margin-bottom: 30px;
				-webkit-appearance: none;
				width: 100%;
				height: 15px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			.loader {
			  border: 16px solid #f3f3f3; /* Light grey */
			  border-top: 16px solid #3498db; /* Blue */
			  border-radius: 50%;
			  width: 120px;
			  height: 120px;
			  animation: spin 2s linear infinite;
			}


			@keyframes spin {
			  0% { transform: rotate(0deg); }
			  100% { transform: rotate(360deg); }
			}
			
			
			
			input[type=range][orient=vertical]::-webkit-slider-thumb {
				<!-- -webkit-appearance: none; -->
				<!-- appearance: none; -->
				<!-- width: 25px; -->
				<!-- height: 25px; -->
				<!-- border-radius: 50%; -->
				<!-- background: #4CAF50; -->
				<!-- cursor: pointer; -->
				
				-webkit-appearance: slider-vertical; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
				
			}
			
			
			
			
			
			input[type=range][orient=vertical]
			{
				
				-webkit-appearance: slider-vertical;
				width: 8px;
				height: 175px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			
			.slider_vertical::-webkit-slider-thumb {
				<!-- -webkit-appearance: slider-vertical; -->
				<!-- appearance: none; -->
				<!-- width: 25px; -->
				<!-- height: 25px; -->
				<!-- border-radius: 50%; -->
				<!-- background: #4CAF50; -->
				<!-- cursor: pointer; -->
				
				
				-webkit-appearance: none; 
				background: #ffffff; 
				cursor: pointer; 
				border: 1px solid #000000; 
				height: 36px; 
				width: 16px; 
		
				box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; 
				border-radius: 3px; 
				
			}
			.slider_vertical {
			
			
				-webkit-transform: rotate(270deg);
				-moz-transform: rotate(270deg);
				-o-transform: rotate(270deg);
				-ms-transform: rotate(270deg);
				transform: rotate(270deg)
				
				<!-- margin-top: 30px; -->
				<!-- margin-bottom: 30px; -->
				margin-left: 30px;
				margin-right: 30px;
				-webkit-appearance: none;
				width: 175px;
				height: 8px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
			}
			
			
			.slider_hist {
			  -webkit-appearance: none;
		
			  outline: none;
		
			}

			.slider_hist:hover {
			  opacity: 1;
			}

			.slider_hist::-webkit-slider-thumb {
			  -webkit-appearance: none;
			  appearance: none;
		
			  cursor: pointer;
			}

			.slider_hist::-moz-range-thumb {
		
			  cursor: pointer;
			}
			
			input {
			  box-sizing: border-box;
			}

			.progress {
				position:relative;
				width:400px;
				border: 1px solid #ddd;
				padding: 1px;
				border-radius: 3px;
			}
			.bar {
				background-color: #B4F5B4; 
				width:0%;
				height:20px; 
				border-radius: 3px;
			}
			.percent { 
				position:absolute; 
				display:inline-block; 
				top:3px; 
				left:48%; 
			}
			#set_center {
				display:flex;
				justify-content: center;
				align-items: center;
			}

			
		</style>
    </head>
    <body class="sb-nav-fixed">
        <nav class="sb-topnav navbar navbar-expand navbar-dark bg-dark">
            <!-- Navbar Brand-->
            <a class="navbar-brand ps-3" href="index.html"> <img src="figures/logo2.png" style="max-width: 20%; height: auto;"> DESC</a>
            <!-- Sidebar Toggle-->
            <!-- <button class="btn btn-link btn-sm order-1 order-lg-0 me-4 me-lg-0" id="sidebarToggle" href="#!"><i class="fas fa-bars"></i></button> -->
            <!-- Navbar Search-->
            <!-- <form class="d-none d-md-inline-block form-inline ms-auto me-0 me-md-3 my-2 my-md-0"> -->
                <!-- <div class="input-group"> -->
                    <!-- <input class="form-control" type="text" placeholder="Search for..." aria-label="Search for..." aria-describedby="btnNavbarSearch" /> -->
                    <!-- <button class="btn btn-primary" id="btnNavbarSearch" type="button"><i class="fas fa-search"></i></button> -->
                <!-- </div> -->
            <!-- </form> -->
            <!-- Navbar-->
            <!-- <ul class="navbar-nav ms-auto ms-md-0 me-3 me-lg-4"> -->
                <!-- <li class="nav-item dropdown"> -->
                    <!-- <a class="nav-link dropdown-toggle" id="navbarDropdown" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false"><i class="fas fa-user fa-fw"></i></a> -->
                    <!-- <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="navbarDropdown"> -->
                        <!-- <li><a class="dropdown-item" href="#!">Settings</a></li> -->
                        <!-- <li><a class="dropdown-item" href="#!">Activity Log</a></li> -->
                        <!-- <li><hr class="dropdown-divider" /></li> -->
                        <!-- <li><a class="dropdown-item" href="#!">Logout</a></li> -->
                    <!-- </ul> -->
                <!-- </li> -->
            <!-- </ul> -->
        </nav>
        <div id="layoutSidenav">
            <div id="layoutSidenav_nav">
                <nav class="sb-sidenav accordion sb-sidenav-dark" id="sidenavAccordion">
                    <div class="sb-sidenav-menu">
                        <div class="nav">
                            <!-- <div class="sb-sidenav-menu-heading">Core</div> -->
                            <!-- <a class="nav-link" href="index.html"> -->
                                <!-- <div class="sb-nav-link-icon"><i class="fas fa-tachometer-alt"></i></div> -->
                                <!-- Dashboard -->
                            <!-- </a> -->
                            <!-- <div class="sb-sidenav-menu-heading">Interface</div> -->
                            <!-- <a class="nav-link collapsed" href="#" data-bs-toggle="collapse" data-bs-target="#collapseLayouts" aria-expanded="false" aria-controls="collapseLayouts"> -->
                                <!-- <div class="sb-nav-link-icon"><i class="fas fa-columns"></i></div> -->
                                <!-- Layouts -->
                                <!-- <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div> -->
                            <!-- </a> -->
                            <!-- <div class="collapse" id="collapseLayouts" aria-labelledby="headingOne" data-bs-parent="#sidenavAccordion"> -->
                                <!-- <nav class="sb-sidenav-menu-nested nav"> -->
                                    <!-- <a class="nav-link" href="layout-static.html">Static Navigation</a> -->
                                    <!-- <a class="nav-link" href="layout-sidenav-light.html">Light Sidenav</a> -->
                                <!-- </nav> -->
                            <!-- </div> -->
                            <!-- <a class="nav-link collapsed" href="#" data-bs-toggle="collapse" data-bs-target="#collapsePages" aria-expanded="false" aria-controls="collapsePages"> -->
                                <!-- <div class="sb-nav-link-icon"><i class="fas fa-book-open"></i></div> -->
                                <!-- Pages -->
                                <!-- <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div> -->
                            <!-- </a> -->
                            <!-- <div class="collapse" id="collapsePages" aria-labelledby="headingTwo" data-bs-parent="#sidenavAccordion"> -->
                                <!-- <nav class="sb-sidenav-menu-nested nav accordion" id="sidenavAccordionPages"> -->
                                    <!-- <a class="nav-link collapsed" href="#" data-bs-toggle="collapse" data-bs-target="#pagesCollapseAuth" aria-expanded="false" aria-controls="pagesCollapseAuth"> -->
                                        <!-- Authentication -->
                                        <!-- <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div> -->
                                    <!-- </a> -->
                                    <!-- <div class="collapse" id="pagesCollapseAuth" aria-labelledby="headingOne" data-bs-parent="#sidenavAccordionPages"> -->
                                        <!-- <nav class="sb-sidenav-menu-nested nav"> -->
                                            <!-- <a class="nav-link" href="login.html">Login</a> -->
                                            <!-- <a class="nav-link" href="register.html">Register</a> -->
                                            <!-- <a class="nav-link" href="password.html">Forgot Password</a> -->
                                        <!-- </nav> -->
                                    <!-- </div> -->
                                    <!-- <a class="nav-link collapsed" href="#" data-bs-toggle="collapse" data-bs-target="#pagesCollapseError" aria-expanded="false" aria-controls="pagesCollapseError"> -->
                                        <!-- Error -->
                                        <!-- <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div> -->
                                    <!-- </a> -->
                                    <!-- <div class="collapse" id="pagesCollapseError" aria-labelledby="headingOne" data-bs-parent="#sidenavAccordionPages"> -->
                                        <!-- <nav class="sb-sidenav-menu-nested nav"> -->
                                            <!-- <a class="nav-link" href="401.html">401 Page</a> -->
                                            <!-- <a class="nav-link" href="404.html">404 Page</a> -->
                                            <!-- <a class="nav-link" href="500.html">500 Page</a> -->
                                        <!-- </nav> -->
                                    <!-- </div> -->
                                <!-- </nav> -->
                            <!-- </div> -->
                            <!-- <div class="sb-sidenav-menu-heading">Addons</div> -->
                            <a class="nav-link" href="upload.html">
                                <div class="sb-nav-link-icon"><i class="fas fa-chart-area"></i></div>
                                File Upload
                            </a>
                            <a class="nav-link" href="analysis.html">
                                <div class="sb-nav-link-icon"><i class="fas fa-table"></i></div>
                                Analysis
                            </a>
                        </div>
                    </div>
                    <!-- <div class="sb-sidenav-footer"> -->
                        <!-- <div class="small">Logged in as:</div> -->
                        <!-- Start Bootstrap -->
                    <!-- </div> -->
                </nav>
            </div>
            <!-- <div id="layoutSidenav_content"> -->
                <!-- <main> -->
                    <!-- <div id="layoutSidenav"> -->
            
			<div id="layoutSidenav_content">
				<main>
					<div class="container-fluid">
						<!-- <h1 class="mt-4 texts">DESC</h1>		 -->
						<div class="row">		
							<div class="col-xl-6">
									<ol class="breadcrumb mb-4">
										<li class="texts">RDS file: <input id="rds" class="texts" type="text" size = "50" value="pbmc.rds"></li>
									</ol>
						
							</div>
							<div class="col-xl-6">
								<ol class="breadcrumb mb-4">	
									<li class="texts">The first dimension: <input id="fd" class="texts" type="number" min="2" max="49" style="margin-right: 10px" value="2"></li>
									<li class="texts">The last dimension: <input id="ld" class="texts" type="number" min="3" max="50" value="30"></li>
								</ol>
							</div>	
						</div>
						<div class="row">							
																				
							<!-- <div class="col-xl-3 col-md-6"> -->
								<!-- <ol class="breadcrumb mb-4"> -->
									<!-- <li class="texts">The last dimension: <input id="ld" class="texts" type="number" ></li> -->
								<!-- </ol> -->
							<!-- </div>	 -->
							<div class="col-xl-12">
								<ol class="breadcrumb mb-4">
									<div class="row">
										<input type = "text" id = "added_markers" class="texts" size = "100" style = "margin-right: 1px" value="GNLY NKG7"/>
									</div>
									<div class="row">
										<input id="add_button" class="texts" value="Add markers" type="button" style = "margin-right: 1px"/>
										<input id="remove_button" class="texts" value="Remove markers" type="button" style = "margin-right: 1px" />
										<input id="add_groups_button" class="texts" value="Add groups" type="button" style = "margin-right: 1px" />
										<input id="remove_groups_button" class="texts" value="Remove groups" type="button"  />
										<input id="add_total_button" class="texts" value="Add to Total" type="button"  />
										<input id="remove_total_button" class="texts" value="Remove from Total" type="button"  />
									</div>
									
								</ol>
							</div>
						
						</div>
							
							<!-- <div class="row">							 -->
								<!-- <div class="col-xl-6"> -->
									<!-- <ol class="breadcrumb mb-4">	 -->
										<!-- <input type = "text" id = "added_markers" size = "50" /> -->
										<!-- <input id="add_button" value="Add markers" type="button"/> -->
										<!-- <input id="remove_button" value="Remove markers" type="button"  /> -->
									<!-- </ol> -->
								<!-- </div> -->
								<!-- <div class="col-xl-6"> -->
									<!-- <ol class="breadcrumb mb-4">	 -->
										<!-- <input type = "text" id = "added_groups" size = "50"  /> -->
										<!-- <input id="add_groups_button" value="Add groups" type="button"  /> -->
										<!-- <input id="remove_groups_button" value="Remove groups" type="button"  /> -->
									<!-- </ol> -->
								<!-- </div>														 -->
							<!-- </div> -->
						
						
						<div class="card mb-4" style="block: none" id="card_heatmap">
							<div class="card-header texts">Hull Heatmap</div>
							<div class="card-body">
								<!-- <div id="playlist-wrapper"> -->
									<!-- <ul id="playlist">	 -->
								<div class="outer">
										<div id="heatmap"></div>
								</div>
									<!-- </ul> -->
								<!-- </div> -->
							</div>
						</div>
						
						
						
						
						
						<div class="row">
							<div class="col-xl-3" >								
								<div class="card mb-4" style="block: none" id="card_cluster_plot">
									<div class="card-header texts">Cluster Plot</div>
									<div class="card-body" >
										<div id="clustering"></div>									
									</div>
								</div>								
								<div class="card mb-4" style="block: none" id="card_animation">
									<div class="card-header texts">Dimensionality Animation</div>
									<div class="card-body">
										
										<!-- <div class="row"> -->
										<div id="set_center">
											<div id="time" class="texts"></div>
										</div>
										<!-- </div> -->
										<!-- <div class="row"> -->
										<div id="set_center">
											<style data="test" type="text/css"></style>
											<input id ="slider" class="slider" type="range"></input>
										</div>
										<!-- </div> -->
										<!-- <div class="row"> -->
										<div id="set_center">										
											<button id = "play" class="texts" style="float: left;">Play</button>
											<button id = "pause"class="texts" style="float: left;">Pause</button>
											<button id = "stop" class="texts" style="float: left;">Stop</button>
											<button id = "speed1x" class="texts" style="float: left;">1x</button>
											<button id = "speed2x" class="texts" style="float: left;">2x</button>
										</div>
										<!-- </div> -->
										<div id="set_center">
										<div id = "animation">
											
												<canvas id = "canvasID" ></canvas>
											
										</div>
										</div>
										
										<div id="set_center">
										<!-- <div class="row"> -->
											<div id="current_markers" class="texts"></div>
										<!-- </div> -->
										</div>
										
										<div id="set_center">
										<!-- <div class="row"> -->
											<input type='text' id='marker'  class="texts"/>
											
											<!-- <input type='button' value='Add markers' id='add' /> -->
											<!-- <input type='button' value='Remove markers' id='remove' /> -->
										<!-- </div> -->
										</div>
										
										<div id="set_center">
										<!-- <div class="row"> -->
											<!-- <input type='text' id='marker'  /> -->
											<input type='button' value='Add marker or group' id='add' class="texts" style="float: left;" />
											<input type='button' value='Remove marker or group' id='remove' class="texts" style="float: left;" />
										<!-- </div> -->
										</div>
									</div>
								</div>
							</div>
							<div class="col-xl-8" >
								<div class="card mb-4" style="block: none" id="card_meps">
									<div class="card-header texts">Marker Expression Plots</div>
									<div class="card-body">
										<div id="marker_plots"></div>
									</div>
								</div>
							</div>
							<div class="col-xl-1 texts" >
								<!-- <div class="row"> -->
									<!-- <input id="lasso_button" class = "texts" value="Lasso" type="button" /> -->
								<!-- </div> -->
								<!-- <div class="row"> -->
									<!-- <input id="lasso_reset" class = "texts" value="Lasso reset" type="button" style="margin-bottom: 5px;" /> -->
								<!-- </div> -->
								<!-- <div class="row"> -->
									<!-- <div id="plot_size_value" class = "texts" style="margin-bottom: 5px;"></div> -->
								<!-- </div> -->
								<div class="row">
									<div class="card mb-4" style="block: none" id="card_plot_size">
										<div class="card-header texts" id="plot_size_value" ></div>
										<div class="card-body" id = "vsb">
											<div class="row">
												<style data="test_vertical" type="text/css"></style>
												<!-- <input id="plot_size_slider" type="range" class="slider_vertical" value="5" min="1" max="10" /> -->
												<input id="plot_size_slider" type="range" class="slider_vertical" value="5" min="1" max="10" style="margin-top:0px;"/>
											</div>
										</div>
										<!-- <input id="plot_size_slider" type="range" orient="vertical" value="5" min="1" max="10"/> -->
										
										<!-- <input id="plot_size_slider" type="range" class="slider_vertical" value="5" min="1" max="10" style="position: relative; top: 100px;"/> -->
										<!-- <input id="plot_size_slider" type="range" class="slider_vertical" value="5" min="1" max="10" /> -->
									</div>
								</div>
							</div>
					
						</div>

						
					</div>
				</main>
			  
			</div>
		<!-- </div> -->
                <!-- </main> -->
                <!-- <footer class="py-4 bg-light mt-auto"> -->
                    <!-- <div class="container-fluid px-4"> -->
                        <!-- <div class="d-flex align-items-center justify-content-between small"> -->
                            <!-- <div class="text-muted">Copyright &copy; Your Website 2021</div> -->
                            <!-- <div> -->
                                <!-- <a href="#">Privacy Policy</a> -->
                                <!-- &middot; -->
                                <!-- <a href="#">Terms &amp; Conditions</a> -->
                            <!-- </div> -->
                        <!-- </div> -->
                    <!-- </div> -->
                <!-- </footer> -->
            <!-- </div> -->
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
        <script src="js/scripts.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js" crossorigin="anonymous"></script>
        <!-- <script src="assets/demo/chart-area-demo.js"></script> -->
        <!-- <script src="assets/demo/chart-bar-demo.js"></script> -->
        <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" crossorigin="anonymous"></script>
        <!-- <script src="js/datatables-simple-demo.js"></script> -->
		
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" crossorigin="anonymous"></script>
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.form/4.2.2/jquery.form.min.js"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
		
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
        <!-- <script src="js/scripts.js"></script> -->
        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js" crossorigin="anonymous"></script> -->
        <!-- <script src="assets/demo/chart-area-demo.js"></script> -->
        <!-- <script src="assets/demo/chart-bar-demo.js"></script> -->
        <script src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js" crossorigin="anonymous"></script>
        <script src="https://cdn.datatables.net/1.10.20/js/dataTables.bootstrap4.min.js" crossorigin="anonymous"></script>
        <!-- <script src="assets/demo/datatables-demo.js"></script> -->
		
		
		<script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js" charset="utf-8"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js" charset="utf-8"></script>
		<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script> -->
		<script src="https://d3js.org/d3.v5.min.js"></script>
		<script src="https://unpkg.com/d3-simple-slider"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>
		<script src="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js"></script>
		<script src="d3-lasso.min.js"></script>
		<script src="KMEANS.js"></script>
		<script src="DBSCAN.js"></script>
		<script src="papaparse.min.js"></script>
		<script src="https://darshit-shah.github.io/d3.floatingScale.js"></script>

		<link
		  rel="stylesheet"
		  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
		  integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
		  crossorigin="anonymous"
		/>
		
		<script>
			$(function() {
			// jquery progress bar μΈν
			var progressbar = $("#progressbar");
			var progressLabel = $(".progress-label");
			progressbar.progressbar({
				value: true,
				change: function() {
					progressLabel.text("Current Progress: " + progressbar.progressbar("value") + "%");
				},
				complete: function() {
					progressLabel.text("Complete!");
					$(".ui-dialog button").last().trigger("focus");
				}
			});
			
			$('form').ajaxForm({
				url: "1.php", 
				type: "POST", 
				beforeSubmit: function(arr, $form, options) {
				
					progressbar.progressbar( "value", 0 );
				},
				uploadProgress: function(event, position, total, percentComplete) {
		
					progressbar.progressbar( "value", percentComplete );
				},
				success: function(text, status, xhr, element) {
			
					progressbar.progressbar( "value", 100 );
				}
			});
			});

		</script>
	
	

		<script type="x-shader/x-vertex" id="vertexshader">

		  attribute float size;
		  uniform float pointSize;
		  uniform vec3 color;
		  uniform float alpha;
		  varying vec4 vColor;
		  varying vec2 myPosition;
		  varying float mySize;
		  uniform sampler2D vertices;
		  attribute float id;
		  uniform int tw;
		  uniform int th;
		  uniform float ratio;
		  uniform float interval;
		  uniform int cur_dim;
		  uniform int n_dims;
		  varying float x2;
		  varying float y2;
		  varying float id2;
		  uniform int nrow;
		  uniform int ndots;		
		  uniform sampler2D marker;
		  uniform int max_ncircles;
		  uniform vec3 total_ncircles;
		  uniform int mw;
		  uniform int mh;
		  uniform float cell_size;
		  uniform int mae;
          uniform sampler2D expression;
          uniform int eh;
          varying float exp;
		  void main() {
			
			vec4 pos3;
		   
			if (int(id) < nrow)
			{
				
				int v1 = th - 1 - int(id)/4;
				float v_final1 = float(v1)/float(th) + 1.0/(2.0*float(th));
				
				int u1 = int(id) - (int(id)/4)*4;
				int u2 = (n_dims*2*u1+cur_dim*2) / 4;
				float u_final1 = float(u2)/float(tw) + 1.0/(2.0*float(tw));
				
				int rgba = (n_dims*2*u1+cur_dim*2) - ((n_dims*2*u1+cur_dim*2)/4)*4;
				
	
				
	
				
				vec2 pos1, pos2;
				
				if (rgba==0)
				{			
					pos1 = texture2D(vertices, vec2(u_final1, v_final1)).rg;
					pos2 = texture2D(vertices, vec2(u_final1, v_final1)).ba;
					
					
				}
				else if (rgba==2)
				{	
					pos1 = texture2D(vertices, vec2(u_final1, v_final1)).ba;
					
					
					
					if (u2==(tw-1))
					{
						int v2 = th - 1 - (int(id)+1)/4;
						float v_final2 = float(v2)/float(th) + 1.0/(2.0*float(th));
						
						float u_final2 = 1.0/(2.0*float(tw));
						
						pos2 = texture2D(vertices, vec2(u_final2, v_final2)).rg;
					}
				
					else
					{	
						float u_final2 = float(u2+1)/float(tw) + 1.0/(2.0*float(tw));
						
						pos2 = texture2D(vertices, vec2(u_final2, v_final1)).rg;				
					}
				}
                
                
                
                int v = eh - 1 - int(id)/4;
                float v_final = float(v)/float(eh) + 1.0/(2.0*float(eh));
   
                int rgba_e = int(id) - (int(id)/4)*4;
                
           
                
                if (rgba_e==0)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).r;
                }
                else if (rgba_e==1)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).g;
                }
                else if (rgba_e==2)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).b;
                }
                else if (rgba_e==3)
                {
                    exp = texture2D(expression, vec2(0.5, v_final)).a;
                }
                
				

				float x = (pos1.x*ratio + pos2.x*(interval-ratio))/interval;
				float y = (pos1.y*ratio + pos2.y*(interval-ratio))/interval;
				

				
				
				// pos3 = vec4(x, y, 0.0, 1.0);
                pos3 = vec4(x, y, exp, 1.0);
				
				id2 = id;
	
				
				
				gl_PointSize = cell_size*2.0;
			}
			
	
			
			else if ((int(id) < (nrow+ndots)) && (mae==1))
			{	
				int cur_dot = int(id) - nrow;
				
				
				
				
				
				int u = cur_dot/2;
				float u_final = float(u)/float(mw) + 1.0/(2.0*float(mw));
				
				int u_rgba = cur_dot - (cur_dot/2)*2;
				
				
				
				
				
				
				int v_pre = mh - 1 - cur_dim;
				float v_final_pre = float(v_pre)/float(mh) + 1.0/(2.0*float(mh));
				
				int v_next = mh - 2 - cur_dim;
				float v_final_next = float(v_next)/float(mh) + 1.0/(2.0*float(mh));
				
				
				
				
				vec2 pos_pre, pos_next;
				
				
				if (u_rgba==0)
				{
					pos_pre = texture2D(marker, vec2(u_final, v_final_pre)).rg;
					pos_next = texture2D(marker, vec2(u_final, v_final_next)).rg;
				}
				
				else
				{
					pos_pre = texture2D(marker, vec2(u_final, v_final_pre)).ba;
					pos_next = texture2D(marker, vec2(u_final, v_final_next)).ba;
				}
				
				
				
				
				float x = (pos_pre.x*ratio + pos_next.x*(interval-ratio))/interval;
				float y = (pos_pre.y*ratio + pos_next.y*(interval-ratio))/interval;
				
				
				// pos3 = vec4(x, y, 0.0, 1.0);
                pos3 = vec4(x, y, 999.0, 1.0);
				
				
				
			 
				id2 = id;
		
				
			
				exp = 0.0;
				
				gl_PointSize = cell_size*3.0;
			}
			
			else
			{
				pos3 = vec4(0.0, 0.0, 0.0, 0.0);
                
                
                id2 = id;
                
                exp = 0.0;
			}
			
			
			vec4 mvPosition = modelViewMatrix * pos3;			
			mySize = size; 
			gl_Position = projectionMatrix * mvPosition;
			vColor = vec4(color, alpha);
			
			
			
		}
		</script>

		
		
		
		<script type="x-shader/x-fragment" id="fragmentshader">
		  varying vec4 vColor;
		  varying vec2 myPosition;
		  varying float mySize;
		  varying float x2;
		  varying float y2;
		  varying float id2;
		  uniform int th;
		  uniform int nrow;
		  uniform float e_max;
          uniform float e_min;
		  uniform int ew;
		  uniform int eh;
		  uniform sampler2D expression;
		  uniform int mae;
		  uniform int ndots;
          varying float exp;
		  
		  void main() {
			

		   
			float id3 = id2;
			
			
			
			vec4 point_color = vec4(0.0, 0.0, 1.0, 1.0);
			
			vec4 base_color = vec4(1.0, 1.0, 1.0, 1.0);
			
			if (int(id3) < nrow)
			{
				if (mae==1)
				{
				
					// int v = eh - 1 - int(id3)/4;
					// float v_final = float(v)/float(eh) + 1.0/(2.0*float(eh));
					
					
					
					// int rgba = int(id3) - (int(id3)/4)*4;
					
					
					
					// float exp;
					
					// if (rgba==0)
					// {
						// exp = texture2D(expression, vec2(0.5, v_final)).r;
					// }
					// else if (rgba==1)
					// {
						// exp = texture2D(expression, vec2(0.5, v_final)).g;
					// }
					// else if (rgba==2)
					// {
						// exp = texture2D(expression, vec2(0.5, v_final)).b;
					// }
					// else if (rgba==3)
					// {
						// exp = texture2D(expression, vec2(0.5, v_final)).a;
					// }
					
					
                    float ratio = (exp-e_min) / (e_max-e_min);
            
                    gl_FragColor = ratio*point_color + (1.0 - ratio)*base_color;
					
			
				}
				
				else
				{
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
				}
				
			}
			
			
			
			
			else if ((int(id3) < (nrow+ndots)) && (mae==1))
			{
				gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
			}
			
			else
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			


		  }
		</script>

		<script>

		var plot_data, gene_data, gene_data2, dataTex, tw, th, ratio, interval, cur_dim, n_dims, uniforms, 
			tex_data, nrow, ncol, test_data, id, expression, exTex, e_max, e_min, circle1, selected_genes, genes_th,
			gene_exp_no, cur_circles_num, circles_vnum, clusters_num, cw, clustersTex, clusters_num2, ctn,
			ex_bars, ex_bar1, ex_bar2, th_cells, rgbs, point_color, base_color, svg, sm_data2, ndots, max_ncircles,
			ncircles, smw, smh, smTex, ncirclesTex, ncw, sm_tex_data, nc, nci, nci_array, par_dim, cndc, xy, xyc, svg2,
			pdi, dims_check, smaller, start_dim, x, eps, minPts, pps, margin, x2, xy_json, jsonData, jsstring,
			xy_json2, max_eps, max_minPts, lassos, lasso0, lasso1, selected, selected2, cdata, max_iter, cpn, sdn,
			slider_change, first_pause, marker_count, can_list, can_data2, can_list2, max_markers, total_ncircles,
			marker_tex_data, mw, mh, markerTex, dom, rm_id, svg_width, marker_tex_data_temp, draw_time, draw_time2, 
			ani_time, ani_time2, marker_time, marker_time2, dr_y, added_markers_list, added_markers, markers, new_markers, markers_string,
			dims_cells_data, dbscan_data2, heatmap_genes, heatmap_groups, heatmap_data, csv_lines, groups, markers_on, selected_dim,
			cur_groups, cur_markers, old_markers, dbscan_data, clusterings, expressions, circles, mpn, dim_id, markers_ani,
			added_markers_ani, new_markers_ani, old_markers_ani, cur_markers_ani, fd_num, ld_num, animations, svg_expression, ep, console_test,
			ep_array, ep_svgs, ep_dots, ep_lassos, lasso_func, max_ep, lasso_gene, groups_markers, new_group, old_group, group_name, intersect,
			lasso_groups, groups_params, heatmap_circles, total_heatmap_circles, hc_scale_x, hc_scale_y, rec_size, cl, mp_ranges, others, canvas, gl, ext, svgs,
			others2, others2_index, menu_size, space_size, text_size, menu_width, menu_height, menu_svgs, test_console, added_degs,
			colorDomains, colorScales, renderer, scene, camera, rma_list, rec_width, rec_height, plot_size, ani_size, 
			ortho_size, font_size, margin_size, font_size_str, outer_width, heatmap_width, heatmap_circles_x, y_length, hct,
			tooltip, mouseover, mousemove, mouseleave, heatmap_margin, legend_size, clustering_width, cell_size, selected_index,
			selected_gene, slider_height, shs, state, deg_test, dcx, dcy, border_size, lasso_temp, ep_size, ep_cell_size, rds_name,
			rds_name_only, unit_height, deg_others, ew, eh, ex_tex_data, mae, am, rem, dcm, ccm, rsm, total_expressions, cl_test,
			ex_colors, lasso_test, develop, num_bins, hist_test, hist_margin, lasso_temp_test, hist_x_test, selected_ex, bins, bins_ids,
			bins_range, hist_th, area_test, areas, cat_test, dim_cells_results, genes_stride, cell_ids, dims_stride, selected_string_test,
			reponse_test, total_markers, histo_ex, ex_maxs, ex_mins, dec, filtering_on, density_on, density_colors, filtering_size, x_filtering, tml,
			final_selected, hulls, lines, line, svg_ani, path_ani, new_marker_ani, cur_marker_ani, old_marker_ani, intersect_tf, sorted_indices,
			reverse_sorted_indices, selected_density, density_indices, density_values, sorted_density_colors, smallest_dim, selected_cp,
			lasso_cp, cp_window_tf, filtered_ids, density_th, density_test, density_min_test, density_max_test, color_scale_test, legend_click_test,
            filtered_ids_test, density_string_test, ids_test, density_test, valid_groups_test, lasso_cells;
			
		var run_status = false;
		var ani_status = false;	
		var pause_status = true;
		var first_time = true;
		var first_add = true;
		var first_plots = true;
		var first_ani = true;
		var first_mp = true;
		var rds_exist = false;

		var t = 0;

		// 210827
	
		$(document).ready(function(){
			d3.select("#card_heatmap").style("display", "none");
			d3.select("#card_cluster_plot").style("display", "none");
			d3.select("#card_meps").style("display", "none");
			d3.select("#card_plot_size").style("display", "none");
			d3.select("#card_animation").style("display", "none");
		});
	
        $(document).ready(function(){
			$("#start").click(function(){
                
                // 201201 start 
                d3.select("#start")["_groups"][0][0].style.color = "red";

                console.time("Total time: ");
               
            });
        });
        
        
        $(document).ready(function(){
			$("#finish").click(function(){
                
                // 201201 start 
                
                
                console.timeEnd("Total time: ");
                
                d3.select("#finish")["_groups"][0][0].style.color = "red";
            });
        });
        
        
		
		function debounce(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) func.apply(context, args);
			};
		};
		
		
		// 210827
		
		$(function() {
			$range = $('#plot_size_slider');
			$display = $('#plot_size_value');

			document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;

			
			$range.on('change', debounce(function() {
				
				
				ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
				ep_cell_size = ep_size*0.002;
				
				x2 = d3.scaleLinear()
					.domain([-dom, dom])					
					.range([0, ep_size]);
				
				
				
				if (!first_mp)
				{
					rsm = new Array();
					
					
					
					
					for (var i=0; i<groups.length; i++)
					{
						rsm[rsm.length] = groups[i];
					}
					
					for (var i=0; i<markers.length; i++)
					{
						rsm[rsm.length] = markers[i];
					}
					
					draw_markers_plots();
				}
				
			
				document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;
			}, 250));
		});
		
		
		
		
		$(document).ready(function(){
			$("#lasso_reset").click(function(){
				
				if (rds_exist)
				{
				
					
					
					lasso_temp.classed("selected",false);
					
					
					
					lasso_temp = new Array();
					
					
					selected = new Array();
					
					
					
					
					var members = lasso_gene.split("_")
					var morg = true;
					
					if (members.length==1)
						morg = true;
					else
						morg = false;
					
					if (morg)
						d3.select('#lasso_window').remove();
					
					else
					{
						for (var i=0; i<members.length; i++)
						{
							d3.select("#lasso_window" + members[i]).remove();
						}
					}
					

					alert("Reset Complete.");
				}
				
				
				else
				{
					alert("Please add markers first.");
				}
			});
		});
		
		
		function add_degs ()
		{
				
			
			new_markers = new Array();
			old_markers = new Array();
			
			for (var i=0; i<added_markers_list.length; i++)
			{
				if (markers.indexOf(added_markers_list[i]) == -1 )
				{
					
					new_markers[new_markers.length] = added_markers_list[i];
				}
				
				else if (cur_markers.indexOf(added_markers_list[i]) == -1)
				{
					old_markers[old_markers.length] = added_markers_list[i];
				}
			}
			
			for (var i=0; i<old_markers.length; i++)
			{
				cur_markers[cur_markers.length] = old_markers[i];
			}

			
			
			if (new_markers.length > 0)
			{
				markers_string = "";
			
			
				for (var i=0; i<new_markers.length; i++)
				{
					if (i == new_markers.length-1)
					{
						markers_string += new_markers[i];
					}
					
					else
					{
						markers_string = markers_string + new_markers[i] + "_";
					}
					
					
				}
		
		
		


			  
				dims_cells_data = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
				  + rds_name + "_" + markers_string;
			 
												
										
				console.log ("dim_cells.r start");
										
				console.time("dims_cells.r time:");	
			  
				$.ajax({
				
					async: true,
					type: "POST",
				
					url: "../rscripts/dims_cells.r",
				
					data: dims_cells_data,
				
					contentType: "application/json" 
					,

					success: function(response){
						
						
						console.timeEnd("dims_cells.r time:");
						
						console.log("dims_cells.r finish")
						
						
						
						
						dim_cells_results = response;
						
						var split_dcr = dim_cells_results.split(",");
						 
						
						var result_markers = split_dcr[0];
						var data_markers = split_dcr[0].split("_")
						
						
					

						if (result_markers!="")
						{

					  
							for (var i=0; i<data_markers.length; i++)
							{		
								
								cur_markers[cur_markers.length] = data_markers[i];	
							}
							
							
							
							
		
							y_length = 1 + cur_groups.length + cur_markers.length;
							
							var cur_height = y_length*unit_height;
							var half_height = height/2;
							
							if (cur_height > half_height)
							{
								rec_height = half_height/y_length;
							}
							else
								rec_height = unit_height;
							
							
							
							hc_scale_y = d3.scaleLinear()
									.domain([-dom, dom])
									.range([0, rec_height]);
							
	

    
							for (var i=0; i<data_markers.length; i++)
							{		
								markers[markers.length] = data_markers[i];
								
							}
							
							
							

							if (first_add)
							{
								
								var dimensions_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
								+ document.getElementById("ld").value + "/dimensions.csv";
							
								var req_dim = new XMLHttpRequest();
								req_dim.open("GET", dimensions_path, false); 
								req_dim.send(null);

								var dim_lines = req_dim.responseText.split('\n');
								
								
								
								dimensions = new Array();
								for (var i=0; i<dim_lines.length-1; i++)
								{
									if (dim_lines[i+1] != "")
									{
										dimensions[i] = dim_lines[i+1].split(",");																								
									}												
								}
								
								nrow = dimensions.length;
								
								
								var largest = 0;
								for (var i=0; i<dimensions.length; i++)
								{
									for (var j=0; j<dimensions[0].length; j++)
									{
										var cur_v = Math.abs(Number(dimensions[i][j]));
										if (cur_v > largest)
										{
											
											largest = cur_v;
										}
									}
								}
								dom = largest + 10;
								
								x = d3.scaleLinear()
									.domain([-dom, dom])
									.range([0, plot_size]);

								hc_scale_x = d3.scaleLinear()
										.domain([-dom, dom])
										.range([0, rec_width]);
										
								hc_scale_y = d3.scaleLinear()
										.domain([-dom, dom])
										.range([0, rec_height]);
										
										
										
								
								
								
								x2 = d3.scaleLinear()
								.domain([-dom, dom])								
								.range([0, ep_size]);
								
								x4 = d3.scaleLinear()
								.domain([-dom, dom])
								.range([0, plot_size/2]);
								
								
								
								var clu_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
								+ document.getElementById("ld").value + "/clusterings.csv";
					
							
								var req_clu = new XMLHttpRequest();
								req_clu.open("GET", clu_path, false); 
								req_clu.send(null);

								var clu_lines = req_clu.responseText.split('\n');
								
								
								
								clusterings = new Array();
								for (var i=0; i<clu_lines.length-1; i++)
								{
									if (clu_lines[i+1] != "")
									{
										clusterings[i] = clu_lines[i+1].split(",");																								
									}												
								}
					
							}
 
  
  
                            var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
							  + rds_name + "_" + nrow + "_" + n_dims + "_" + data_markers.length + "_" + density_th + "_" + split_dcr[1];
							  
							console.time("density.py time:");	
					                    
                            $.ajax({
                                async: true,
                            
                                url: "density.py",
                                type: 'POST',
                                
                                contentTpye: 'application/json',
                                dataType: 'json',
                            
                                data: {'fd_ld': density_string},
                                
                                success: function(response){
                                    
                                    var endTime2 = new Date().getTime();
                                    
                                    console.timeEnd("density.py time:");
                                    
                                    console.log("density.py finish");
                                    
                                   
                                    
                                    var filtered_ids_result = response["filtered_ids"];
                                       
                                    
                                    var split_cell_ids = split_dcr[1].split(" ");
                                    
                                    
                                    
                                    for (var i=0; i<data_markers.length; i++)
                                    {
                                        var cur_marker_name = data_markers[i];
                                        
                                        
                                        
                                        
                                        
                                        var cell_num = Number(split_cell_ids[i*(1+nrow)]);
                                        
                                        cell_ids[cur_marker_name] = new Array();
                                        
                                        for (var j=0; j<cell_num; j++)
                                        {
                                            cell_ids[cur_marker_name][j] = Number(split_cell_ids[i*(1+nrow) + 1+j]);
                                        }
                                        
                                        
                                        
                                        filtered_ids[cur_marker_name] = new Array();
                                        
                                        
                                        
                                        for (var j=0; j<n_dims; j++)
                                        {                                                                                     
                                            filtered_ids[cur_marker_name][j] = new Array();
                                            
                                            var fc = 0;
                                            
                                            for (var k=0; k<nrow; k++)
                                            {
                                                var cur_id = filtered_ids_result[i*n_dims*nrow + j*nrow + k];
                                                
                                                if (cur_id != -1)  
                                                {
                                                    filtered_ids[cur_marker_name][j][fc] = cur_id;
                                                    
                                                    fc++;
                                                }
                                            }
                                        }
                                        
                                        
                                        
                                      
                                        
                                        
                                        if (!expressions.hasOwnProperty(cur_marker_name))
                                        {									
                                            var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
                                            + document.getElementById("ld").value + "/" + cur_marker_name + "_expression.csv";
                                
                                        
                                            var req_ex = new XMLHttpRequest();
                                            req_ex.open("GET", ex_path, false); 
                                            req_ex.send(null);

                                            expressions[cur_marker_name] = req_ex.responseText.split('\n');	
                                        }	
                                            
                                            
                                        if (!ex_colors.hasOwnProperty(cur_marker_name))	
                                        {	
                                            var cur_ex = expressions[cur_marker_name];
                                            
                                            var ex_max = Number.MIN_VALUE;
                                            var ex_min = Number.MAX_VALUE;
                                            
                                            var cur_ex_temp = new Array();
                    
                                            for (var j=0; j<nrow; j++)
                                            {		
                                                var cur_value = Number(cur_ex[j+1]);
                                                
                                                cur_ex_temp[j] = cur_value;
                                                
                                                if (cur_value > ex_max)
                                                {
                                                    ex_max = cur_value;
                                                }
                                                
                                                if (cur_value < ex_min)
                                                {
                                                    ex_min = cur_value;
                                                }
                                            }
                                            
                                            ex_maxs[cur_marker_name] = ex_max;
                                            ex_mins[cur_marker_name] = ex_min;
                                            
                                            
                                            sorted_indices[cur_marker_name] = new Array();
                                            
                                            var cur_indices = sorted_indices[cur_marker_name];
                                            
                                            for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
                                            cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
                                        
                                        
                                            
                                            reverse_sorted_indices[cur_marker_name] = new Array();
                                            
                                            var cur_reverse_indices = reverse_sorted_indices[cur_marker_name];
                                            
                                            for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
                                            cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
                                        
                                        
                                            ex_colors[cur_marker_name] = new Array();
                                            var cur_color = ex_colors[cur_marker_name];
                                            
                                            
                                            for (var j = 0; j < nrow; j++)
                                            {
                                                var ge = Number(cur_ex[cur_indices[j]+1]);
                                               
                                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                                
                                                cur_color[j] = new Array();
                                                
                                                
                                                
                                                for (var k = 0; k < 3; k++)
                                                {
                                                  
                                                   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
                                                }
                                               
                                            }

                                            
                                        }

                                        
                                        ///////////////////////////////////////////////////////////////////////////////////////////
                                        
                                        
                                        
                                        
            
                                      
                                        
                                        var cur_marker_ids = filtered_ids[cur_marker_name];
                                        
                                        hulls[cur_marker_name] = new Array();
                                        lines[cur_marker_name] = new Array();
                                        areas[cur_marker_name] = new Array();
                                        
                                    
                                        
                                        var cur_areas = new Array();
                                        
                                        var smallest_area = Number.MAX_VALUE;
                                        var largest_area = Number.MIN_VALUE;
                                        
                                        for (var j=0; j<n_dims; j++)
                                        {						
                                            var cur_dim_ids = cur_marker_ids[j];
                                            
                                            
                                            if (cur_dim_ids.length > 2)
                                            {
                                            
                                                var points = new Array();
                                                

                                                for (var k=0; k<cur_dim_ids.length; k++)
                                                {
                                                    var cur_id_dim = dimensions[cur_dim_ids[k]];
                                                    
                                                    points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
                                                }


                                                
                                             
                                                var cur_hull = d3.polygonHull(points);
                                                
                                                hulls[cur_marker_name][j] = cur_hull;
                                                
                                                var scaled_hull = new Array();
                                                    
                                                for (var k=0; k<cur_hull.length; k++)
                                                {
                                                    scaled_hull[k] = [x2(cur_hull[k][0]), x2(-cur_hull[k][1])];
                                                }
                                                
                                                                        
                                                lines[cur_marker_name][j] = line(scaled_hull);
                                                
                                                var cur_area = -d3.polygonArea(scaled_hull);
                                                
                                        
                                                                
                                                cur_areas[j] = cur_area;
                                                
                                            
                                                                                                    
                                                if (cur_area > largest_area)
                                                {
                                                    largest_area = cur_area;										
                                                }
                                                
                                            
                                                                                                                    
                                                if (cur_area < smallest_area)
                                                {
                                                    smallest_area = cur_area;
                                                    smallest_dim[cur_marker_name] = j;
                                                }
                                            }
                                            
                                            else
                                            {
                                                cur_areas[j] = 0;
                                                
                                                lines[cur_marker_name][j] = 0;
                                            }
                                        }
                                        
                                        
                                
     
                                        if (largest_area > 0)
                                        {
                                            for (var j=0; j<n_dims; j++)
                                            {									
                                             
                                                areas[cur_marker_name][j] = (cur_areas[j]-smallest_area) / (largest_area-smallest_area);
                                            }
                                        }	
                                        
                                        else
                                        {
                                            for (var j=0; j<n_dims; j++)
                                            {									
                                                areas[cur_marker_name][j] = 0;
                                            
                                            }
                                        }                        
                                    }
                                    
                            
                                            
                                            
                                            
                                    all_genes_done();
                            
                                    console.log("add_degs finish");
                                }
                            });
		
				
						}
						
						else
						{	
							if (old_markers.length > 0)
							{
								y_length = 1 + cur_groups.length + cur_markers.length;
							
								var cur_height = y_length*unit_height;
								var half_height = height/2;
								
								if (cur_height > half_height)
								{
									rec_height = half_height/y_length;
								}
								else
									rec_height = unit_height;
								
								
								
								hc_scale_y = d3.scaleLinear()
										.domain([-dom, dom])
										.range([0, rec_height]);
										
							
								
				
								all_genes_done();
								
								console.log("add_degs finish");
							}
							
							
							else
							{
								alert("The genes you entered are not in the data or the genes are differentially expressed in less than 3 cells.");
								
								d3.select('.loader').remove();
							}
						}
				
					}
				});

			}
			
			else
			{
				y_length = 1 + cur_groups.length + cur_markers.length;
						
				var cur_height = y_length*unit_height;
				var half_height = height/2;
				
				if (cur_height > half_height)
				{
					rec_height = half_height/y_length;
				}
				else
					rec_height = unit_height;
				
				
				
				hc_scale_y = d3.scaleLinear()
						.domain([-dom, dom])
						.range([0, rec_height]);
						
						
				
				
				all_genes_done();
				
				
				console.log("add_degs finish");
			}
	
			
			
			
			
		}
		
		
		
		
		
		function more()	
		{	
			console.log("more start")
			
			
			
			document.getElementById("more_button").remove();
			
			
			
			var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
			var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
			
			
			
			console.log("loader: more");
			
		
			d3.select('.d3-context-menu')
				.append('div')											
				.attr('class', 'loader')
				.style('position', 'absolute')
			
				.style('left', menu_loader_width)
				.style('top', menu_loader_height)
				.raise();
			
			
		
			
			
			
			var degs_string2 = "";
					
					
			for (var i=0; i<menu_size; i++)
			{
				var cur_index = others2_index + i;
				
				if (others2.length>cur_index)
				{
				
					if ((i == (menu_size-1)) || (cur_index == (others2.length-1)))
					{
						degs_string2 += others2[cur_index];
					}
					
					else
					{
						degs_string2 = degs_string2 + others2[cur_index] + "_";
					}
				}
				
			}
			
		
			var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
			"_" + rds_name + "_" + degs_string2;
			
			console.log(degs_string);
			
			console.time("degs.r time:");	
  
			$.ajax({
	
				async: true,
				type: "POST",
				url: "../rscripts/degs.r",
				data: degs_string,
				contentType: "application/json",
				

				success: function(response){


					console.timeEnd("degs.r time:");

					console.log("degs.r finish")

					for (var i=0; i<menu_size; i++)
					{
						var cur_index = others2_index + i;
						
						if (others2.length>cur_index)
						{
							
							var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
							+ document.getElementById("ld").value + "/" + others2[cur_index] + "_expression.csv";
				
						
							var req_ex = new XMLHttpRequest();
							req_ex.open("GET", ex_path, false); 
							req_ex.send(null);

							expressions[others2[cur_index]] = req_ex.responseText.split('\n');
							
							
							
							var cur_ex = expressions[others2[cur_index]];
									
							var ex_max = Number.MIN_VALUE;
                            var ex_min = Number.MAX_VALUE;
							
							var cur_ex_temp = new Array();
	
							for (var j=0; j<nrow; j++)
							{		
								var cur_value = Number(cur_ex[j+1]);
								
								cur_ex_temp[j] = cur_value;
								
								if (cur_value > ex_max)
								{
									ex_max = cur_value;
								}
                                
                                if (cur_value < ex_min)
								{
									ex_min = cur_value;
								}
							}
							
							ex_maxs[others2[cur_index]] = ex_max;
							ex_mins[others2[cur_index]] = ex_min;
							
							
							sorted_indices[others2[cur_index]] = new Array();
				
							var cur_indices = sorted_indices[others2[cur_index]];
							
							for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
							cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
						
						
							
							reverse_sorted_indices[others2[cur_index]] = new Array();
							
							var cur_reverse_indices = reverse_sorted_indices[others2[cur_index]];
							
							for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
							cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
						
						
						
							ex_colors[others2[cur_index]] = new Array();
							var cur_color = ex_colors[others2[cur_index]];
							
							
							for (var j = 0; j < nrow; j++)
							{
								var ge = Number(cur_ex[cur_indices[j]+1]);
                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                
                               
								cur_color[j] = new Array();
								
								for (var k = 0; k < 3; k++)
								{
								  
								   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
								}
							   
							}
							
							
							

							var cur_xy = new Array();
		
							var cur_indices = sorted_indices[others2[cur_index]];
							
							
							
							
							
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[cur_indices[j]];
								
								cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
		
        
        
        
							var deg_svg = d3.selectAll('.d3-context-menu')
								.append('svg')
								.attr("id", others2[cur_index] + "deg")
								.attr("width", plot_size/2)
								.attr("height", plot_size/2+text_size)
								.on("click", function() {
									var gene_string = this.textContent;
									var d3_id = '#' + gene_string + "deg";
									var border_str = border_size + "px solid #3b5998"
									
									var di = added_degs.indexOf(gene_string);
									if (di==-1)
									{	
										added_degs[added_degs.length] = gene_string;
										d3.select(d3_id).style("border", border_str);
									}
									else
									{
										added_degs.splice(di, 1);
										d3.select(d3_id).style("border", "none");
									}
								})
							
							
							menu_svgs[menu_svgs.length] = deg_svg;
							
							deg_svg.append("text")						
								.attr("x", (plot_size / 4))             								
								.attr("y", (text_size*2)/3)
								.attr("text-anchor", "middle")  														 
								.style("font-size", "10px")  
								.text(others2[cur_index])
							
							
							
							
							var mep_dots_data = deg_svg
							.selectAll()				
							.data(cur_xy).enter()
							.append("circle")
							.attr("id", function(d, i) {return i;})
							.attr("cx", function(d) {return x4(d[0])})
							.attr("cy", function(d) {return x4(-d[1])})			
							.attr("r", cell_size/2)
							
							
							mep_dots_data
								.data(ex_colors[others2[cur_index]])
								.attr("fill", function(d) {
								return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
							
							
							
						}
						
					}
					
					
					
					
					if (others2.length > (others2_index + menu_size) )
					{
						
						d3.selectAll('.d3-context-menu')
							.append("input")
							.attr("id", "more_button")
							.attr("type", "button")
							.attr("value", "More")
							.style("display", "block")
							.style("margin", "0 auto")
							.on("click", function() {
								more();
							})
							
							
						others2_index += menu_size;
						
						
						
						
						d3.select('.loader').remove();
					}
					
					else
					{
			
						
						d3.select('.loader').remove();
					}
				}
			});	
		}
		
		
	
		
		
		
		d3.contextMenu = function (menu, openCallback) {
			
			
			
			
			$(document).mouseup(function (e) { 
				if ($(e.target).closest(".d3-context-menu").length 
							=== 0) { 
					d3.select('.d3-context-menu').remove();
				} 
			}); 
			

			
			return function(data, index) {	
			
				// console.log("success!");
				d3.event.preventDefault();
				
				d3.select('.d3-context-menu').remove();
				
				
				console.log("loader: d3.contextMenu");
				d3.select('body')
					.append('div')
					.attr('class', 'loader')
					.style('position', 'absolute')
					.style('left', width/2 + 'px')		
			
					.style('top', $(document).scrollTop() + height/2 + 'px')
					
				
				
				
				
				menu_svgs = new Array();
				added_degs = new Array();
				
				menu_size = 16;
				space_size = 10;
				text_size = font_size;
				menu_width = plot_size*2 + space_size*(Math.sqrt(menu_size)-1) + 'px';
				menu_height = (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
				
				
				// console.log(text_size, font_size, menu_width, plot_size, menu_height);
				
				
					
				d3.select('body')
					.append('div')
					.attr('class', 'd3-context-menu')
					.style('width', menu_width)
					.style('height', menu_height)
					
				
				
				dcx = d3.event.pageX;
				dcy = d3.event.pageY;
				
			

			
				
				
				deg_test = this;
				cl_test = this;
				
				var cur_circle_id = this;
				
				
				
				selected_gene = this["parentNode"].textContent;
				selected_index = markers_on.indexOf(selected_gene);
				
				// console.log(selected_gene);
				// console.log(selected_index);
				
				
				var cur_id = "#" + selected_gene;
				
				var cur_bounding = d3.select(cur_id)["_groups"][0][0].getBoundingClientRect();
			
            
				
				var others_exist = false;
				
				if (selected_gene in deg_others)
				{
					if (typeof deg_others[selected_gene][dim_id] != "undefined")
					{		
						
						others_exist = true;
						
						others2 = new Array();
						
						for (var i=0; i<deg_others[selected_gene][dim_id].length; i++)
						{
							others2[i] = deg_others[selected_gene][dim_id][i];
						}
						
						
						
						var others2_string;
							
						if (others2.length==0)
						{
							others2_string = "No gene."
						}
						else
						{
							others2_string = "";
							
							for (var j=0; j<others2.length; j++)
							{
								if (j==(others2.length-1))
									others2_string = others2_string + others2[j];
								else
									others2_string = others2_string + others2[j] + " ";
							}
						}
										
						var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
						menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
						
						d3.selectAll('.d3-context-menu')
							.style("height", menu_height)
						
						
						
						var degs_width = plot_size*2 - 30 + 'px';
						
						var degs = d3.selectAll('.d3-context-menu')
						.append('ol')
						.attr('class', 'breadcrumb mb-4')
						
						
							.append('span')
						
							.html(others2_string)
							.style("display", "block")
							.style("width", degs_width)
							.style("word-wrap", "break-word")
							
						
						
						d3.selectAll('.d3-context-menu')
						.append("input")
						.attr("id", "add_degs_button")
						.attr("type", "button")
						.attr("value", "Add genes to the cirlce heatmap")
						.style("display", "block")
						.style("margin", "0 auto")
						.on("click", function() {
							
						
							
							
							var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
							var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
							
							console.log("loader: d3.contextMenu");
							
							d3.select('.d3-context-menu')
								.append('div')											
								.attr('class', 'loader')
								.style('position', 'absolute')
							
								.style('left', menu_loader_width)
								.style('top', menu_loader_height)
								.raise();
							
						
							
							added_markers_list = new Array();
							
							for (var i=0; i<added_degs.length; i++)
							{
								added_markers_list[i] = added_degs[i];
							}
							
							added_degs = new Array();
							
							add_degs();
						})
				
				
						for (var i=0; i<menu_size; i++)
						{
							
							if (others2.length>i)
							{
							
				
								
								var deg_svg = d3.selectAll('.d3-context-menu')
									.append('svg')
									.attr("id", others2[i]+"deg")
									.attr("width", plot_size/2)
									.attr("height", plot_size/2+text_size)
									.on("click", function() {
										var gene_string = this.textContent;
										var d3_id = '#' + gene_string + "deg";
										var border_str = border_size + "px solid #3b5998"
										
										var di = added_degs.indexOf(gene_string);
										if (di==-1)
										{	
											added_degs[added_degs.length] = gene_string;
											d3.select(d3_id).style("border", border_str);
										}
										else
										{
											added_degs.splice(di, 1);
											d3.select(d3_id).style("border", "none");
										}
									})
									
								menu_svgs[menu_svgs.length] = deg_svg;
								
								var small_font_size_str = (font_size*2)/3 + "px";
								deg_svg.append("text")
									.attr("x", (plot_size / 4))             								
									.attr("y", (text_size*2)/3)
									.attr("text-anchor", "middle")  														 
									.style("font-size", small_font_size_str)  
									.text(others2[i])
									
								
								// 201201
								
								var cur_xy = new Array();
							
								var cur_indices = sorted_indices[others2[i]];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices[j]];
									
									cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								
							
								
								
								
								var mep_dots_data = deg_svg
								.selectAll()				
								.data(cur_xy).enter()
								.append("circle")
								.attr("id", function(d, i) {return i;})
								.attr("cx", function(d) {return x4(d[0])})
								.attr("cy", function(d) {return x4(-d[1])})			
								.attr("r", cell_size/2)
								
								
								mep_dots_data
									.data(ex_colors[others2[i]])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
								
								
								
								
								
							}
							
						}
						
						if (others2.length > menu_size)
						{
							
							
							d3.selectAll('.d3-context-menu')
								.append("input")
								.attr("id", "more_button")
								.attr("type", "button")
								.attr("value", "More")
								.style("display", "block")
								.style("margin", "0 auto")
								.on("click", function() {
									more();
								})
						
						
							others2_index = menu_size;
							
							
							
							
							var range2 = cur_cirlce_id["parentNode"]["parentNode"].getBoundingClientRect();
				
							var menu_space = range2["x"]+range2["width"]-dcx + 10;
							
							d3.select('.d3-context-menu')
							
								.style('left', (dcx - 2 + menu_space) + 'px')
							
								.style('top', range2["y"] + 'px')
								.style('display', 'block');

				
							
							d3.select('.loader').remove();
						}
						
						
						else
						{

				
							var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
				
						
							var menu_space = range2["x"]+range2["width"]-dcx + 10;
							
							d3.select('.d3-context-menu')
									.style("position", "absolute")
									
									.style("left", cur_bounding.left + "px")
								
									.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
									.style('display', 'block')
									.raise()
									
								
					
							
							d3.select('.loader').remove();
						}
							
							
						
						// }
					}	
				}
				
				if (!others_exist)
				{
					
                    // 201201
                    
					// var cur_cell_ids = cell_ids[selected_gene];
                    var cur_cell_ids = filtered_ids[selected_gene][dim_id];
					
					
					var cell_ids_string = "";
					for (var i=0; i<cur_cell_ids.length; i++)
					{
						if (i==(cur_cell_ids.length-1))
							cell_ids_string = cell_ids_string + cur_cell_ids[i];
						else
							cell_ids_string = cell_ids_string + cur_cell_ids[i] + "_";
					}
					
					
					var gene_label = document.getElementById("fd").value + "," + document.getElementById("ld").value + 
					"," + rds_name + "," + dim_id + "," + selected_gene + "," + cell_ids_string;
					
					
					// console.log(gene_label);
					
					console.time("others.r time:");	
		  
					$.ajax({
						
						async: true,
						type: "POST",
						url: "../rscripts/others.r",
						data: gene_label,
						contentType: "application/json",
						

						success: function(response){


							console.timeEnd("others.r time:");

							console.log("others.r finish")
							
							
							
						
							
							
							others2 = response.split(" ");
							
							if (others2=="")
								others2 = new Array();
							
						
							if (!(selected_gene in deg_others))
							{
								deg_others[selected_gene] = new Array();		
							}
							
						
							deg_others[selected_gene][dim_id] = new Array();
							
												
							for (var j=0; j<others2.length; j++)
							{
								deg_others[selected_gene][dim_id][j] = others2[j];		
							}
							
							
							
							
							var others2_string;
							
							if (others2.length==0)
							{
								others2_string = "No gene."
							}
							else
							{
								others2_string = "";
								
								for (var j=0; j<others2.length; j++)
								{
									if (j==(others2.length-1))
										others2_string = others2_string + others2[j];
									else
										others2_string = others2_string + others2[j] + " ";
								}
							}
											
							var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
							menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
							
							d3.selectAll('.d3-context-menu')
								.style("height", menu_height)
							
							
							
							var degs_width = plot_size*2 - 30 + 'px';
							
							var degs = d3.selectAll('.d3-context-menu')
							.append('ol')
							.attr('class', 'breadcrumb mb-4')
							
							
								.append('span')
								
								.html(others2_string)
								.style("display", "block")
								.style("width", degs_width)
								.style("word-wrap", "break-word")
							
							
							if (others2.length!=0)
							{

								
								var degs_string2 = "";
									
									
								for (var i=0; i<menu_size; i++)
								{
									if (others2.length>i)
									{
									
										if ((i == (menu_size-1)) || (i == (others2.length-1)))
										{
											degs_string2 += others2[i];
										}
										
										else
										{
											degs_string2 = degs_string2 + others2[i] + "_";
										}
									}
									
								}
								
								
								
								var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
								"_" + rds_name + "_" + degs_string2;
								
								// console.log(degs_string);
								
								console.time("degs.r time:");	
					  
								$.ajax({
									
									async: true,
									type: "POST",
									url: "../rscripts/degs.r",
									data: degs_string,
									contentType: "application/json",
									

									success: function(response){


										console.timeEnd("degs.r time:");

										console.log("degs.r finish")

										d3.selectAll('.d3-context-menu')
										.append("input")
										.attr("id", "add_degs_button")
										.attr("type", "button")
										.attr("value", "Add genes to the cirlce heatmap")
										.style("display", "block")
										.style("margin", "0 auto")
										.on("click", function() {
											
											
											
											
											var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
											var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
											
											
											console.log("loader: d3.contextMenu");
											
											d3.select('.d3-context-menu')
												.append('div')											
												.attr('class', 'loader')
												.style('position', 'absolute')
											
												.style('left', menu_loader_width)
												.style('top', menu_loader_height)
												.raise();
											
										
											
											added_markers_list = new Array();
											
											for (var i=0; i<added_degs.length; i++)
											{
												added_markers_list[i] = added_degs[i];
											}
											
											added_degs = new Array();
											
											add_degs();
										})
								
								
										for (var i=0; i<menu_size; i++)
										{
											
											if (others2.length>i)
											{
												
												var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
												+ document.getElementById("ld").value + "/" + others2[i] + "_expression.csv";
									
											
												var req_ex = new XMLHttpRequest();
												req_ex.open("GET", ex_path, false); 
												req_ex.send(null);

												expressions[others2[i]] = req_ex.responseText.split('\n');
												
												
												
												
												
												var cur_ex = expressions[others2[i]];
									
												var ex_max = Number.MIN_VALUE;
                                                var ex_min = Number.MAX_VALUE;
												
												var cur_ex_temp = new Array();
						
												for (var j=0; j<nrow; j++)
												{		
													var cur_value = Number(cur_ex[j+1]);
													
													cur_ex_temp[j] = cur_value;
													
													if (cur_value > ex_max)
													{
														ex_max = cur_value;
													}
                                                    
                                                    if (cur_value < ex_min)
													{
														ex_min = cur_value;
													}
												}
												
												ex_maxs[others2[i]] = ex_max;
												ex_mins[others2[i]] = ex_min;
												
												
												sorted_indices[others2[i]] = new Array();
									
												var cur_indices = sorted_indices[others2[i]];
												
												for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
												cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
											
											
												
												reverse_sorted_indices[others2[i]] = new Array();
												
												var cur_reverse_indices = reverse_sorted_indices[others2[i]];
												
												for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
												cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
											
											
											
												ex_colors[others2[i]] = new Array();
												var cur_color = ex_colors[others2[i]];
												
												
												for (var j = 0; j < nrow; j++)
												{
													var ge = Number(cur_ex[cur_indices[j]+1]);                                                    
                                                    var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
                                                    
												   
													cur_color[j] = new Array();
													
													for (var k = 0; k < 3; k++)
													{
													  
													   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                                       cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
													}
												   
												}
												
												
									
											
												
												var deg_svg = d3.selectAll('.d3-context-menu')
													.append('svg')
													.attr("id", others2[i] + "deg")
													.attr("width", plot_size/2)
													.attr("height", plot_size/2+text_size)
													.on("click", function() {
														var gene_string = this.textContent;
														var d3_id = '#' + gene_string + "deg";
														var border_str = border_size + "px solid #3b5998"
														
														var di = added_degs.indexOf(gene_string);
														if (di==-1)
														{	
															added_degs[added_degs.length] = gene_string;
															d3.select(d3_id).style("border", border_str);
														}
														else
														{
															added_degs.splice(di, 1);
															d3.select(d3_id).style("border", "none");
														}
													})
													
												menu_svgs[menu_svgs.length] = deg_svg;
												
												var small_font_size_str = (font_size*2)/3 + "px";
												deg_svg.append("text")
													.attr("x", (plot_size / 4))             								
													.attr("y", (text_size*2)/3)
													.attr("text-anchor", "middle")  														 
													.style("font-size", small_font_size_str)  
													.text(others2[i])
												



												var cur_xy = new Array();
							
												var cur_indices = sorted_indices[others2[i]];
												
												
												
												
												
												for (var j=0; j<nrow; j++)
												{
													var cur_index = dimensions[cur_indices[j]];
													
													cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
												}
												
												
												
											
												
												
												
												var mep_dots_data = deg_svg
												.selectAll()				
												.data(cur_xy).enter()
												.append("circle")
												.attr("id", function(d, i) {return i;})
												.attr("cx", function(d) {return x4(d[0])})
												.attr("cy", function(d) {return x4(-d[1])})			
												.attr("r", cell_size/2)
												
												
												mep_dots_data
													.data(ex_colors[others2[i]])
													.attr("fill", function(d) {
													return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
												
												
												
												
											}
											
										}
										
										if (others2.length > menu_size)
										{
											
											d3.selectAll('.d3-context-menu')
												.append("input")
												.attr("id", "more_button")
												.attr("type", "button")
												.attr("value", "More")
												.style("display", "block")
												.style("margin", "0 auto")
												.on("click", function() {
													more();
												})
										
										
											others2_index = menu_size;
											
											
											
										
											var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
								
											var menu_space = range2["x"]+range2["width"]-dcx + 10;
											
											d3.select('.d3-context-menu')
												.style("position", "absolute")
												
												.style("left", cur_bounding.left + "px")
												
												.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
												.style('display', 'block')
												.raise()
												
											
									
											
											d3.select('.loader').remove();
										}
										
										
										else
										{
		
										
											var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
								
											
											var menu_space = range2["x"]+range2["width"]-dcx + 10;
											
											d3.select('.d3-context-menu')
												.style("position", "absolute")
												
												.style("left", cur_bounding.left + "px")
										
												.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
												.style('display', 'block')
												.raise()
												
											
											
											
											d3.select('.loader').remove();
										}
									}
								});
							}
							
							
				
							
							else
							{
							
								
								var range2 = cur_circle_id["parentNode"]["parentNode"].getBoundingClientRect();
					
							
								var menu_space = range2["x"]+range2["width"]-dcx + 10;
								
								
								d3.select('.d3-context-menu')
									.style("position", "absolute")
								
									.style("left", cur_bounding.left + "px")
									
									.style("top", $(document).scrollTop() + cur_bounding.top + cur_bounding.height + "px")
									.style('display', 'block')
									.raise()
									
									
								
								d3.select('.loader').remove();
							}
							
							
							
							
							
						}
					});
				}
				
				
			};
		};
		
        
        
        
        function remove_filtering_windows()
        {
            var cur_members = lasso_gene.split("_")
            var cur_morg = true;
            
            if (cur_members.length==1)
                cur_morg = true;
            else
                cur_morg = false;
            
            
            		
                
            var lasso_gene_id = "#" + lasso_gene;
            
            
            
            if (cur_morg)
                d3.select("#lasso_window" + lasso_gene).remove();
            else
            {
                
                if (density_on)
                {
                    
                    
                    if (final_selected.length > 0)
                    {
                        lasso_temp.classed("selected",false);
                    
                    
                    
                        lasso_temp = new Array();
                        
                        
                        
                        
                        var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                        
                        for (var j=0; j<selected_density.length; j++)
                        {
            
                            cur_lasso_dots[selected_density[j]].setAttribute("class", "");
                        }
                    }
                }
                
                else
                {
                
                    var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                
                    for (var i=0; i<sorted_dec.length; i++)
                    {
                        
                        
                        cur_circle[sorted_dec[i]].setAttribute("class", "");
                    
                        
                    }
                }
                
                var cur_xy_fo = new Array();
            
                var cur_indices_fo = sorted_indices[lasso_gene];
                
                
                
                
                for (var j=0; j<nrow; j++)
                {
                    var cur_index = dimensions[cur_indices_fo[j]];
                    
                    cur_xy_fo[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                }
                
                
                
            
                
                d3.select(lasso_gene_id)
                    .select("#mep_dots")
                    .selectAll('circle')								
                    .data(cur_xy_fo)															
                    .attr("cx", function(d) {return x2(d[0])})
                    .attr("cy", function(d) {return x2(-d[1])})			
                
                
                
                
                d3.select(lasso_gene_id)
                    .select("#mep_dots")
                    .selectAll('circle')
                    .data(ex_colors[lasso_gene])
                    .attr("fill", function(d) {
                    return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
                
                
            
                
                for (var j=0; j<cur_members.length; j++)
                    d3.select("#lasso_window" + cur_members[j]).remove();
                
                d3.select("#inputs_window").remove();
                
                
                
            }
            
            
            d3.select("#legend").remove();
            
            
            
            selected = new Array();
                
            final_selected = new Array();
            selected_density = new Array();
            
            density_on = false;
            filtering_on = false;
			
			d3.select("#plot_size_slider").style('display', 'block');
			d3.select("#stop_plot_size_change").style('display', 'none');
                
                
                
            
        }
		
		
		function draw_markers_plots()
		{
			d3.select("#card_meps").style("display", "block");
			d3.select("#card_plot_size").style("display", "block");
			
			console.log("draw_markers_plots start");
			
			if (first_mp)
				first_mp = false;
			
			
		
			
			var am_tf = false;
			var rem_tf = false;
			var dcm_tf = false;
			var ccm_tf = false;
			var rsm_tf = false;
			
			var mep_markers = new Array();
			
			if (am.length > 0)
			{
				am_tf = true;
				
				for (var i=0; i<am.length; i++)
					mep_markers[i] = am[i];
			}
			
			if (rem.length > 0)
			{
				
				
				rem_tf = true;
				
				for (var i=0; i<rem.length; i++)				
					mep_markers[i] = rem[i];
				
				
				
			}
			
			if (dcm.length > 0)
			{
				dcm_tf = true;
				
				for (var i=0; i<dcm.length; i++)
					mep_markers[i] = dcm[i];
			}
			
			if (ccm.length > 0)
			{
				ccm_tf = true;
				
				for (var i=0; i<ccm.length; i++)
					mep_markers[i] = ccm[i];
			}
			
			if (rsm.length > 0)
			{
				rsm_tf = true;
				
				for (var i=0; i<rsm.length; i++)
					mep_markers[i] = rsm[i];
			}
			
			
			
			if (am_tf)
			{
			
				for (var i=0; i<mep_markers.length; i++)
				{
					var members = mep_markers[i].split("_")
					var morg = true;
					
					if (members.length==1)
						morg = true;
					else
						morg = false;
					
				
					
					var mep_svg = d3.select("#marker_plots")
					.append("svg")		
					.attr("id", mep_markers[i])
					.attr("width", ep_size)
					.attr("height", ep_size+legend_size)


			
					

					mep_svg.append("text")
					.attr("x", (ep_size / 2)) 
					.attr("y", legend_size/2+10)
					.attr("text-anchor", "middle")  					 
					.style("font-size", font_size_str)  
					.text(mep_markers[i])
					.on("click", function(d) {
						lasso_gene = this.textContent;
						
						
						var cur_members = lasso_gene.split("_")
						var cur_morg = true;
						
						if (cur_members.length==1)
							cur_morg = true;
						else
							cur_morg = false;
						
						
						if (filtering_on)
						{		
							remove_filtering_windows();
							
                            d3.select("#plot_size_slider").style('display', 'block');
							d3.select("#stop_plot_size_change").style('display', 'none');
                            
							// var lasso_gene_id = "#" + lasso_gene;
							
							
							
							// if (cur_morg)
								// d3.select("#lasso_window" + lasso_gene).remove();
							// else
							// {
								
								// if (density_on)
								// {
									
									
									// if (final_selected.length > 0)
									// {
										// lasso_temp.classed("selected",false);
									
									
									
										// lasso_temp = new Array();
										
										
										
										
										// var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
										
										// for (var j=0; j<selected_density.length; j++)
										// {
							
											// cur_lasso_dots[selected_density[j]].setAttribute("class", "");
										// }
									// }
								// }
								
								// else
								// {
								
									// var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
									// for (var i=0; i<sorted_dec.length; i++)
									// {
										
										
										// cur_circle[sorted_dec[i]].setAttribute("class", "");
									
										
									// }
								// }
								
								// var cur_xy_fo = new Array();
							
								// var cur_indices_fo = sorted_indices[lasso_gene];
								
								
								
								
								// for (var j=0; j<nrow; j++)
								// {
									// var cur_index = dimensions[cur_indices_fo[j]];
									
									// cur_xy_fo[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								// }
								
								
								
							
								
								// d3.select(lasso_gene_id)
									// .select("#mep_dots")
									// .selectAll('circle')								
									// .data(cur_xy_fo)															
									// .attr("cx", function(d) {return x2(d[0])})
									// .attr("cy", function(d) {return x2(-d[1])})			
								
								
								
								
								// d3.select(lasso_gene_id)
									// .select("#mep_dots")
									// .selectAll('circle')
									// .data(ex_colors[lasso_gene])
									// .attr("fill", function(d) {
									// return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
								
								
							
								
								// for (var j=0; j<cur_members.length; j++)
									// d3.select("#lasso_window" + cur_members[j]).remove();
								
								// d3.select("#inputs_window").remove();
								
								
								
							// }
							
							
                            // d3.select("#legend").remove();
							
							
							
							// selected = new Array();
								
							// final_selected = new Array();
							// selected_density = new Array();
							
							// density_on = false;
							// filtering_on = false;
							
							
							
						}
						
						else
						{
							
							
							var filtering_start = true;
							
							
							if (!cur_morg)
							{
									
								for (var j=0; j<cur_members.length; j++)
								{
								
									
									if (!document.getElementById(cur_members[j]))
									{
									
										
										filtering_start = false;
										
										break;
									}
								}
							}
							
							
							
							if (filtering_start)
							{
					
								
								filtering_on = true;
								
								d3.select("#plot_size_slider").style('display', 'none');
								d3.select("#stop_plot_size_change").style('display', 'block');
								
								cell_filtering();
							}
							
							else
							{
						
								
								alert("Please add group member markers to Marker Expression Plots to perfoem Cell Filtering on this Group.");
							}
							
						}	
					})
					
					
					var cur_xy_am = new Array();
							
					var cur_indices_am = sorted_indices[mep_markers[i]];
					
					
					if (cur_indices_am.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[cur_indices_am[j]];
							
							cur_xy_am[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_am[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
				
					
					var mep_dots = mep_svg.append('g')
					.attr("id", "mep_dots")
					
					var mep_dots_data = mep_dots.selectAll()
		
					.data(cur_xy_am).enter()
					.append("circle")
					.attr("id", function(d, i) {return i;})
					.attr("cx", function(d) {return x2(d[0])})
					.attr("cy", function(d) {return x2(-d[1])})			
					.attr("r", ep_cell_size)
					
					
					mep_dots_data.data(ex_colors[mep_markers[i]])
						.attr("fill", function(d) {
						return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
					
					var menu = [];
					
					mep_svg.append("path")
							.attr("id", mep_markers[i] + "_path")
							
							.style("fill", "transparent")
							.style("stroke", "red")
							.style("stroke-width", ep_cell_size*2)
							.attr("d", lines[mep_markers[i]][dim_id])
							
							.on('contextmenu', d3.contextMenu(menu));
					
				

					if (!morg)
					{	
						var lasso_start = function() {
					
							if (density_on)
								lasso.items()				
						};
						
						
						var lasso_draw = function() {

						};
						
						
						
						
						var lasso_end = function() {
							// 210826

							if (density_on)
							{
								if (selected.length != 0)
								{
									lasso_temp.classed("selected",false);			
									lasso_temp = new Array();
									selected = new Array();
									
								}
								
								lasso_temp = lasso.selectedItems();
								
								
								selected = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
								
								
								final_selected = new Array();
								selected_density = new Array();
						
						
								// var cur_indices_lasso = density_indices;
							
							
								for (var j=0; j<selected.length; j++)
								{
									var cur_density_id = selected[j];
                                    
                                    var offset = nrow-dec.length;
                                  
                            
                                    // if (cur_density_id >= (nrow-dec.length))
                                    if (cur_density_id >= offset)
                                    {
                                        final_selected[final_selected.length] = dec[density_indices[cur_density_id-offset]];
                                        
                                        selected_density[selected_density.length] = cur_density_id;
                                    }
                                    
                                    
									// var cur_ori_id = cur_indices_lasso[cur_density_id];
									
									// var fi = dec.indexOf(cur_ori_id);
									
									// if (fi!=-1)
									// {
										// final_selected[final_selected.length] = cur_ori_id;
										
										// selected_density[selected_density.length] = cur_density_id;
									// }
								}
								
								
								var lasso_gene_id = "#" + lasso_gene;
								var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
									
								for (var j=0; j<selected_density.length; j++)
								{
					
									cur_lasso_dots[selected_density[j]].setAttribute("class", "selected");
								}
	
							}
							

						};
						
						
						

						
						var lasso = d3.lasso()
						.closePathSelect(true)
						.closePathDistance(100)
						.items(mep_dots_data)					
						.targetArea(mep_svg)
						.on("start",lasso_start)
						.on("draw",lasso_draw)
						.on("end",lasso_end);
					
						mep_svg.call(lasso);
						
					}
	
	
				}
				
			}	
			
			if (rem_tf)
			{
			
				
				console.log("rem_tf");
				console.log(rem_tf);
				
				
				for (var i=0; i<mep_markers.length; i++)
				{
				
					
					var svg_name = '#' + mep_markers[i];
					
					
					
					// console.log("mep_markers[i]");					
					// console.log(mep_markers[i]);
					
					// console.log("svg_name");					
					// console.log(svg_name);
					
					d3.select(svg_name).remove();
					
				}
			}
			
			
			
			if (dcm_tf)
			{
				if (filtering_on)
				{
                    remove_filtering_windows();
						
					d3.select("#plot_size_slider").style('display', 'block');
					d3.select("#stop_plot_size_change").style('display', 'none');	
                }
                    
                    
                for (var i=0; i<mep_markers.length; i++)
				{
					
					
					
                    
                    
                    var cur_xy_dcm = new Array();
							
					var cur_indices_dcm = sorted_indices[mep_markers[i]];
					
					
					if ( cur_indices_dcm.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[ cur_indices_dcm[j]];
							
							cur_xy_dcm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_dcm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
				
					
	
					var svg_name = '#' + mep_markers[i];
					
					d3.select(svg_name).select('#mep_dots').selectAll('circle')
					.data(cur_xy_dcm)
					.attr("cx", function(d) {return x2(d[0])})
					.attr("cy", function(d) {return x2(-d[1])})			
				
					
					
					
					var test = mep_markers[i].split("_")
					var morg = true;
					
					if (test.length==1)
						morg = true;
					else
						morg = false;
					
					
					
					
					if (hulls[mep_markers[i]].length > 0)
					{
						var cur_path_id = "#" + mep_markers[i] + "_path";
						
						
						
						d3.select(cur_path_id)						
								.attr("d", lines[mep_markers[i]][dim_id]);
					
					}
					
					
				
	
				}
			}
			
			
			
			if (ccm_tf)
			{
				for (var i=0; i<mep_markers.length; i++)
				{
						
					
					console.log ("ccm_tf");
					
					
					
					
					selected = new Array();
					
					
					
					
					var svg_name = '#' + mep_markers[i];
					
					
					
					
					
					var test = mep_markers[i].split("_")
					var morg = true;
					
					if (test.length==1)
						morg = true;
					else
						morg = false;
					
					
					
					
					
					
					
					
					var cur_path_id = "#" + mep_markers[i] + "_path";
					
					
					
					
					
					
					d3.select(cur_path_id)						
							.attr("d", lines[mep_markers[i]][dim_id]);
					
					
					
					
					if (!morg)
					{
						
						lasso_temp = new Array();
						
						
						
						
						var cur_xy_ccm = new Array();
							
						var cur_indices_ccm = sorted_indices[mep_markers[i]];
						
						
						if (cur_indices_ccm.length > 0)
						{
						
						
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[cur_indices_ccm[j]];
								
								cur_xy_ccm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
						}
						
						else
						{
							for (var j=0; j<nrow; j++)
							{
								var cur_index = dimensions[j];
								
								cur_xy_ccm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
							}
						}
				
					
						
						
						
						d3.select(svg_name).select('#mep_dots').selectAll('circle')
						.data(cur_xy_ccm)
						.attr("cx", function(d) {return x2(d[0])})
						.attr("cy", function(d) {return x2(-d[1])})		
						
						
						
						
						
						
						
						var cur_color = ex_colors[mep_markers[i]];
						
						d3.select("#" + mep_markers[i])
							.select('#mep_dots')
							.selectAll('circle')
							.data(cur_color)
							.attr("fill", function(d) {
								return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
					}
					
		
	
				}
			}
			
			
			
			if (rsm_tf)
			{
				for (var i=0; i<mep_markers.length; i++)
				{
					var test = mep_markers[i].split("_")
					var morg = true;
					
					if (test.length==1)
						morg = true;
					else
						morg = false;
					
				
					
					
					
					var svg_name = '#' + mep_markers[i];
					
					
					d3.select(svg_name)
					.attr("width", ep_size)
					.attr("height", ep_size+legend_size)
					
					d3.select(svg_name)
					.select('text')
					.attr("x", (ep_size / 2)) 
					.attr("y", legend_size/2+10)							 
					.style("font-size", font_size_str)  
					
					
					
					
					
					var cur_xy_rsm = new Array();
							
					var cur_indices_rsm = sorted_indices[mep_markers[i]];
					
					
					if (cur_indices_rsm.length > 0)
					{
					
					
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[cur_indices_rsm[j]];
							
							cur_xy_rsm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
					
					else
					{
						for (var j=0; j<nrow; j++)
						{
							var cur_index = dimensions[j];
							
							cur_xy_rsm[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
						}
					}
				
					
					
					
					
					d3.select(svg_name).select('#mep_dots').selectAll('circle')
					.data(cur_xy_rsm)
					.attr("cx", function(d) {return x2(d[0])})
					.attr("cy", function(d) {return x2(-d[1])})	
					.attr("r", ep_cell_size)
					
					
					
					
					
					if (hulls[mep_markers[i]].length > 0)
					{
					
						var smallest_area = Number.MAX_VALUE;
						
						for (var j=0; j<n_dims; j++)
						{
							var scaled_hull = new Array();
						
							var cur_hull = hulls[mep_markers[i]][j];
							
							for (var k=0; k<cur_hull.length; k++)
							{
								scaled_hull[k] = [x2(cur_hull[k][0]), x2(-cur_hull[k][1])];
							}
							
							lines[mep_markers[i]][j] = line(scaled_hull);
					
						}
				
					
						var cur_id = svg_name + "_path";
					
					
						d3.select(cur_id)
							.style("stroke-width", ep_cell_size*2)
							.attr("d", lines[mep_markers[i]][dim_id]);
				
					}
					
				
				
				
				}
		
			
			}
			
			
			
	
			am = new Array();
			rem = new Array();
			dcm = new Array();
			ccm = new Array();
			rsm = new Array();
			

		}
		
		
		
		var d3_category437 = [
		// 0xd3fe14, 0xfec7f8, 0x0b7b3e, 0x0bf0e9, 0xc203c8, 0xfd9b39, 0x888593, 
		0xd3fe14, 0xfec7f8, 0x0bf0e9, 0xc203c8, 0xfd9b39, 0x888593, 
		0x906407, 0x98ba7f, 0xfe6794, 0x10b0ff, 0xac7bff, 0xfee7c0, 0x964c63, 
		0x1da49c, 0x0ad811, 0xbbd9fd, 0xfe6cfe, 0x297192, 0xd1a09c, 0x78579e, 
		0x81ffad, 0x739400, 0xca6949, 0xd9bf01, 0x646a58, 0xd5097e, 0xbb73a9, 
		0xccf6e9, 0x9cb4b6, 0xb6a7d4, 0x9e8c62, 0x6e83c8, 0x01af64, 0xa71afd, 
		0xcfe589, 0xd4ccd1, 0xfd4109, 0xbf8f0e, 0x2f786e, 0x4ed1a5, 0xd8bb7d, 
		0xa54509, 0x6a9276, 0xa4777a, 0xfc12c9, 0x606f15, 0x3cc4d9, 0xf31c4e, 
		0x73616f, 0xf097c6, 0xfc8772, 0x92a6fe, 0x875b44, 0x699ab3, 0x94bc19, 
		0x7d5bf0, 0xd24dfe, 0xc85b74, 0x68ff57, 0xb62347, 0x994b91, 0x646b8c, 
		0x977ab4, 0xd694fd, 0xc4d5b5, 0xfdc4bd, 0x1cae05, 0x7bd972, 0xe9700a, 
		0xd08f5d, 0x8bb9e1, 0xfde945, 0xa29d98, 0x1682fb, 0x9ad9e0, 0xd6cafe, 
		0x8d8328, 0xb091a7, 0x647579, 0x1f8d11, 0xe7eafd, 0xb9660b, 0xa4a644, 
		0xfec24c, 0xb1168c, 0x188cc1, 0x7ab297, 0x4468ae, 0xc949a6, 0xd48295, 
		0xeb6dc2, 0xd5b0cb, 0xff9ffb, 0xfdb082, 0xaf4d44, 0xa759c4, 0xa9e03a, 
		0x0d906b, 0x9ee3bd, 0x5b8846, 0x0d8995, 0xf25c58, 0x70ae4f, 0x847f74, 
		0x9094bb, 0xffe2f1, 0xa67149, 0x936c8e, 0xd04907, 0xc3b8a6, 0xcef8c4, 
		0x7a9293, 0xfda2ab, 0x2ef6c5, 0x807242, 0xcb94cc, 0xb6bdd0, 0xb5c75d, 
		0xfde189, 0xb7ff80, 0xfa2d8e, 0x839a5f, 0x28c2b5, 0xe5e9e1, 0xbc79d8, 
		0x7ed8fe, 0x9f20c3, 0x4f7a5b, 0xf511fd, 0x09c959, 0xbcd0ce, 0x8685fd, 
		0x98fcff, 0xafbff9, 0x6d69b4, 0x5f99fd, 0xaaa87e, 0xb59dfb, 0x5d809d, 
		0xd9a742, 0xac5c86, 0x9468d5, 0xa4a2b2, 0xb1376e, 0xd43f3d, 0x05a9d1, 
		0xc38375, 0x24b58e, 0x6eabaf, 0x66bf7f, 0x92cbbb, 0xddb1ee, 0x1be895, 
		0xc7ecf9, 0xa6baa6, 0x8045cd, 0x5f70f1, 0xa9d796, 0xce62cb, 0x0e954d, 
		0xa97d2f, 0xfcb8d3, 0x9bfee3, 0x4e8d84, 0xfc6d3f, 0x7b9fd4, 0x8c6165, 
		0x72805e, 0xd53762, 0xf00a1b, 0xde5c97, 0x8ea28b, 0xfccd95, 0xba9c57, 
		0xb79a82, 0x7c5a82, 0x7d7ca4, 0x958ad6, 0xcd8126, 0xbdb0b7, 0x10e0f8, 
		0xdccc69, 0xd6de0f, 0x616d3d, 0x985a25, 0x30c7fd, 0x0aeb65, 0xe3cdb4, 
		0xbd1bee, 0xad665d, 0xd77070, 0x8ea5b8, 0x5b5ad0, 0x76655e, 0x598100, 
		0x86757e, 0x5ea068, 0xa590b8, 0xc1a707, 0x85c0cd, 0xe2cde9, 0xdcd79c, 
		0xd8a882, 0xb256f9, 0xb13323, 0x519b3b, 0xdd80de, 0xf1884b, 0x74b2fe, 
		0xa0acd2, 0xd199b0, 0xf68392, 0x8ccaa0, 0x64d6cb, 0xe0f86a, 0x42707a, 
		0x75671b, 0x796e87, 0x6d8075, 0x9b8a8d, 0xf04c71, 0x61bd29, 0xbcc18f, 
		0xfecd0f, 0x1e7ac9, 0x927261, 0xdc27cf, 0x979605, 0xec9c88, 
		0x8c48a3,0x676769, 0x546e64, 0x8f63a2, 0xb35b2d, 0x7b8ca2, 0xb87188, 
		0x4a9bda, 0xeb7dab, 0xf6a602, 0xcab3fe, 0xddb8bb, 0x107959, 0x885973, 
		0x5e858e, 0xb15bad, 0xe107a7, 0x2f9dad, 0x4b9e83, 0xb992dc, 0x6bb0cb, 
		0xbdb363, 0xccd6e4, 0xa3ee94, 0x9ef718, 0xfbe1d9, 0xa428a5, 0x93514c, 
		0x487434, 0xe8f1b6, 0xd00938, 0xfb50e1, 0xfa85e1, 0x7cd40a, 0xf1ade1, 
		0xb1485d, 0x7f76d6, 0xd186b3, 0x90c25e, 0xb8c813, 0xa8c9de, 0x7d30fe, 
		0x815f2d, 0x737f3b, 0xc84486, 0x946cfe, 0xe55432, 0xa88674, 0xc17a47, 
		0xb98b91, 0xfc4bb3, 0xda7f5f, 0xdf920b, 0xb7bbba, 0x99e6d9, 0xa36170, 
		0xc742d8, 0x947f9d, 0xa37d93, 0x889072, 0x9b924c, 0x23b4bc, 0xe6a25f, 
		0x86df9c, 0xa7da6c, 0x3fee03, 0xeec9d8, 0xaafdcb, 0x7b9139, 0x92979c, 
		0x72788a, 0x994cff, 0xc85956, 0x7baa1a, 0xde72fe, 0xc7bad8, 0x85ebfe, 
		0x6e6089, 0x9b4d31, 0x297a1d, 0x9052c0, 0x5c75a5, 0x698eba, 0xd46222, 
		0x6da095, 0xb483bb, 0x04d183, 0x9bcdfe, 0x2ffe8c, 0x9d4279, 0xc909aa, 
		0x826cae, 0x77787c, 0xa96fb7, 0x858f87, 0xfd3b40, 0x7fab7b, 0x9e9edd, 
		0xbba3be, 0xf8b96c, 0x7be553, 0xc0e1ce, 0x516e88, 0xbe0e5f, 0x757c09, 
		0x4b8d5f, 0x38b448, 0xdf8780, 0xebb3a0, 0xced759, 0xf0ed7c, 0xe0eef1, 
		0x0969d2, 0x756446, 0x488ea8, 0x888450, 0x61979c, 0xa37ad6, 0xb48a54, 
		0x8193e5, 0xdd6d89, 0x8aa29d, 0xc679fe, 0xa4ac12, 0x75bbb3, 0x6ae2c1, 
		0xc4fda7, 0x606877, 0xb2409d, 0x5874c7, 0xbf492c, 0x4b88cd, 0xe14ec0, 
		0xb39da2, 0xfb8300, 0xd1b845, 0xc2d083, 0xc3caef, 0x967500, 0xc56399, 
		0xed5a05, 0xaadff6, 0x6685f4, 0x1da16f, 0xf28bff, 0xc9c9bf, 0xc7e2a9, 
		0x5bfce4, 0xe0e0bf, 0xe8e2e8, 0xddf2d8, 0x9108f8, 0x932dd2, 0xc03500, 
		0xaa3fbc, 0x547c79, 0x9f6045, 0x04897b, 0x966f32, 0xd83212, 0x039f27, 
		0xdf4280, 0xef206e, 0x0095f7, 0xa5890d, 0x9a8f7f, 0xbc839e, 0x88a23b, 
		0xe55aed, 0x51af9e, 
		0x5eaf82, 0x9e91fa, 0xf76c79, 0x99a869, 0xd2957d, 0xa2aca6, 0xe3959e, 
		0xadaefc, 0x5bd14e, 0xdf9ceb, 0xfe8fb1, 0x87ca80, 0xfc986d, 0x2ad3d9, 
		0xe8a8bb, 0xa7c79c, 0xa5c7cc, 0x7befb7, 0xb7e2e0, 0x85f57b, 0xf5d95b, 
		0xdbdbff, 0xfddcff, 0x6e56bb, 0x226fa8, 0x5b659c, 0x58a10f, 0xe46c52, 
		0x62abe2, 0xc4aa77, 0xb60e74, 0x087983, 0xa95703, 0x2a6efb, 0x427d92
		].map(d3_rgbString);


		function d3_rgbString (value) {
		return d3.rgb(value >> 16, value >> 8 & 0xff, value & 0xff);
		}
		
		
		
		function draw_cluster_plot()
		{
			d3.select("#card_cluster_plot").style("display", "block")
			
			if (!first_plots)
			{
				d3.select("#clustering").select("svg").remove();	
			}
			
			else
			{
				first_plots = false;
			}

			
			var cur_clustering = new Array();

			for (var i=0; i<nrow; i++)
			{
				
				
				cur_clustering[i] = new Array();
				
				cur_clustering[i][0] = Number(dimensions[i][1+2*dim_id]);
				cur_clustering[i][1] = Number(dimensions[i][1+2*dim_id+1]);
				cur_clustering[i][2] = Number(clusterings[i][dim_id]);
				cur_clustering[i][3] = i;
			}
			
		
			
			cur_clustering.sort(function (a,b){ return a[2] - b[2] });
			
			
			
			
			
			
			
			var svg_clustering = d3.select("#clustering")	
			.append("svg")
			.attr("width", clustering_width)
			.attr("height", clustering_width)



			var legend_str = 'translate(' + legend_size + ',0)';
			var g = svg_clustering.append('g')
			.attr('transform', legend_str);


			var legend_font_size = (font_size*2)/3 + "px";
			var legend_trans = 'translate(' + smaller*0.007 + ',' + smaller*0.007 + ')';
			var colorLegendG = svg_clustering.append('g')
			.attr('transform', legend_trans)
			.style("font-size", legend_font_size);


			const colorScale = d3.scaleOrdinal()
			
			.range(d3_category437);

			
			var legend_circle_size = smaller * 0.002;
			const colorLegend = d3.legendColor()
			.scale(colorScale)
			.shape('circle')
			.shapeRadius(legend_circle_size);

			
			var dots = g.selectAll("circle")
			.data(cur_clustering).enter()
			.append("circle")
			.attr("id", function(d, i) {return d[3];})
			.attr("cx", function(d) {return x(d[0])})
			.attr("cy", function(d) {return x(-d[1])})
			.attr("r", cell_size)
			.attr("fill", function(d) {
			return colorScale(d[2])})
			

			colorLegendG.call(colorLegend)
			.selectAll('.cell text')
			.attr('dy', '0.005em');
			
			
			
			var lasso_start = function() {
					
				if (!cp_window_tf)
					lasso.items()				
			};
			
			
			var lasso_draw = function() {

			};
			
			
			
			
			var lasso_end = function() {
				

				if (selected_cp.length != 0)
				{
					lasso_cp.classed("selected",false);			
					lasso_cp = new Array();
					selected_cp = new Array();
					
				}
				
				lasso.selectedItems()
					.classed("selected",true);
				
				
				lasso_cp = lasso.selectedItems();
				
				
				selected_cp = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
				
				
				
				if (!cp_window_tf)
				{	
				
					var bounding_cp = d3.select("#clustering")["_groups"][0][0].getBoundingClientRect();
					
					d3.select('body')
						.append('div')

						.attr("id", "cp_window")
						
						.style('width', ep_size*1.5 + "px")
						
						.style('position', 'absolute')	
						.style('margin', '0 auto')
						.style('left', bounding_cp.left + 'px')
						.style('top', $(document).scrollTop() + bounding_cp.top + bounding_cp.height + 'px')
						.style('display', 'block')
						.style('background-color', '#e2e2e2')
						.raise()
						.append('ol')

						.attr("class", "col-xl-12")
						.attr("id", "cp_buttons")
					
						.style('position', 'absolute')
						.style('margin', '0 auto')						
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "window_removal")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Window Removal")	
						.on("click", function() {
							
							
							if (selected_cp.length != 0)
							{
								lasso_cp.classed("selected",false);			
								lasso_cp = new Array();
								selected_cp = new Array();
								
							}
							
							
							
							d3.select("#cp_window").remove();
							
							d3.select("#cluster_degs").remove();
							
							
							cp_window_tf = false;
							
						})
						
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "lasso_cancel_cp")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Lasso Cancel")	
						.on("click", function() {
							
							if (selected_cp.length != 0)
							{
								lasso_cp.classed("selected",false);			
								lasso_cp = new Array();
								selected_cp = new Array();
								
							}
							
							
							alert("Cancel Complete.");
						})	
					
					d3.select('#cp_buttons')		
						.append("input")
						.attr("id", "done_cp")
						.attr("class", "texts")
						.attr("type", "button")
						.attr("value", "Done")	
						.on("click", function() {
							
							
							if (selected_cp.length > 2)
							{
							
								d3.select('body')
									.append('div')
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')		
							
									.style('top', $(document).scrollTop() + height/2 + 'px')
									
								
								
								menu_svgs = new Array();
								added_degs = new Array();
								
								menu_size = 16;
								space_size = 10;
								text_size = font_size;
								menu_width = plot_size*2 + space_size*(Math.sqrt(menu_size)-1) + 'px';
								menu_height = (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
								
								var bounding_cp_window = d3.select("#cp_window")["_groups"][0][0].getBoundingClientRect();
								
								d3.select('body')
									.append('div')
									
									.attr('id', 'cluster_degs')
									.style('width', menu_width)
									.style('height', menu_height)
									.style("position", "absolute")									
									.style("left", bounding_cp_window.left + "px")					
									.style("top", $(document).scrollTop() + bounding_cp_window.top + bounding_cp_window.height + "px")
									.style('display', 'block')
								
									.style('background-color', '#f2f2f2')
									.raise()
								
								
							
						
						
								var cell_ids_string = "";
								for (var i=0; i<selected_cp.length; i++)
								{
									if (i==(selected_cp.length-1))
										cell_ids_string = cell_ids_string + selected_cp[i];
									else
										cell_ids_string = cell_ids_string + selected_cp[i] + "_";
								}
								
								var gene_cp = " ";
								
								
								var gene_label = document.getElementById("fd").value + "," + document.getElementById("ld").value + 
								"," + rds_name + "," + dim_id + "," + gene_cp + "," + cell_ids_string;
								
								
							
								
								console.time("others.r time:");	
					  
								$.ajax({
									
									async: true,
									type: "POST",
									url: "../rscripts/others.r",
									data: gene_label,
									contentType: "application/json",
									

									success: function(response){


										console.timeEnd("others.r time:");

										console.log("others.r finish")
										
										
										
										
										
										
										others2 = response.split(" ");
										
										if (others2=="")
											others2 = new Array();
										
										
		
										var others2_string;
										
										if (others2.length==0)
										{
											others2_string = "No gene."
										}
										else
										{
											others2_string = "";
											
											for (var j=0; j<others2.length; j++)
											{
												if (j==(others2.length-1))
													others2_string = others2_string + others2[j];
												else
													others2_string = others2_string + others2[j] + " ";
											}
										}
														
										var degs_spcae = (Math.ceil(others2.length/((font_size*2)/3))+4)*((font_size*2)/3);
										menu_height = degs_spcae + (plot_size+text_size)*2 + space_size*(Math.sqrt(menu_size)-1) + space_size*8 +'px';
										
										d3.select("#cluster_degs")
											.style("height", menu_height)
										
										
										
										var degs_width = plot_size*2 - 30 + 'px';
										
										var degs = d3.select("#cluster_degs")
										.append('ol')
										.attr('class', 'breadcrumb mb-4')
										
										
											.append('span')
											
											.html(others2_string)
											.style("display", "block")
											.style("width", degs_width)
											.style("word-wrap", "break-word")
										
										
										if (others2.length!=0)
										{

											
											var degs_string2 = "";
												
												
											for (var i=0; i<menu_size; i++)
											{
												if (others2.length>i)
												{
												
													if ((i == (menu_size-1)) || (i == (others2.length-1)))
													{
														degs_string2 += others2[i];
													}
													
													else
													{
														degs_string2 = degs_string2 + others2[i] + "_";
													}
												}
												
											}
											
											
											
											var degs_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + 
											"_" + rds_name + "_" + degs_string2;
											
											console.log(degs_string);
											
											console.time("degs.r time:");	
								  
											$.ajax({
												
												async: true,
												type: "POST",
												url: "../rscripts/degs.r",
												data: degs_string,
												contentType: "application/json",
												

												success: function(response){


													console.timeEnd("degs.r time:");

													console.log("degs.r finish")

													d3.select("#cluster_degs")
													.append("input")
													.attr("id", "add_degs_button")
													.attr("type", "button")
													.attr("value", "Add genes to the cirlce heatmap")
													.style("display", "block")
													.style("margin", "0 auto")
													.on("click", function() {
														
														
														
														
														var menu_loader_width = Number(menu_width.replace('px', ''))/2 + 'px';
														var menu_loader_height = Number(menu_height.replace('px', ''))/2 + 'px';
														
														
														
														d3.select("#cluster_degs")
															.append('div')											
															.attr('class', 'loader')
															.style('position', 'absolute')
														
															.style('left', menu_loader_width)
															.style('top', menu_loader_height)
															.raise();
														
													
														
														added_markers_list = new Array();
														
														for (var i=0; i<added_degs.length; i++)
														{
															added_markers_list[i] = added_degs[i];
														}
														
														added_degs = new Array();
														
														add_degs();
													})
											
											
													for (var i=0; i<menu_size; i++)
													{
														
														if (others2.length>i)
														{
															
															var ex_path = develop + "data2/" + rds_name_only + "_" + document.getElementById("fd").value + "_"
															+ document.getElementById("ld").value + "/" + others2[i] + "_expression.csv";
												
														
															var req_ex = new XMLHttpRequest();
															req_ex.open("GET", ex_path, false); 
															req_ex.send(null);

															expressions[others2[i]] = req_ex.responseText.split('\n');
															
															
															
															
															
															var cur_ex = expressions[others2[i]];
												
															var ex_max = Number.MIN_VALUE;
                                                            var ex_min = Number.MAX_VALUE;
															
															var cur_ex_temp = new Array();
									
															for (var j=0; j<nrow; j++)
															{		
																var cur_value = Number(cur_ex[j+1]);
																
																cur_ex_temp[j] = cur_value;
																
																if (cur_value > ex_max)
																{
																	ex_max = cur_value;
																}
                                                                
                                                                if (cur_value < ex_min)
																{
																	ex_min = cur_value;
																}
															}
															
															ex_maxs[others2[i]] = ex_max;
                                                            ex_mins[others2[i]] = ex_min;
															
															
															
															sorted_indices[others2[i]] = new Array();
												
															var cur_indices = sorted_indices[others2[i]];
															
															for (var j = 0; j < nrow; ++j) cur_indices[j] = j;
															cur_indices.sort(function (a, b) { return cur_ex_temp[a] < cur_ex_temp[b] ? -1 : cur_ex_temp[a] > cur_ex_temp[b] ? 1 : 0; });
														
														
															
															reverse_sorted_indices[others2[i]] = new Array();
															
															var cur_reverse_indices = reverse_sorted_indices[others2[i]];
															
															for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
															cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
														
														
														
															ex_colors[others2[i]] = new Array();
															var cur_color = ex_colors[others2[i]];
															
															
															for (var j = 0; j < nrow; j++)
															{
																var ge = Number(cur_ex[cur_indices[j]+1]);
                                                                var ge_ratio = (ge-ex_min) / (ex_max-ex_min);
															   
																cur_color[j] = new Array();
																
																for (var k = 0; k < 3; k++)
																{
																  
																   // cur_color[j][k] = (ge/ex_max)*point_color[k] + (1-ge/ex_max)*base_color[k];
                                                                   cur_color[j][k] = ge_ratio*point_color[k] + (1-ge_ratio)*base_color[k];
																}
															   
															}
															
													
												
														
															
															var deg_svg = d3.select("#cluster_degs")
																.append('svg')
																.attr("id", others2[i] + "deg")
																.attr("width", plot_size/2)
																.attr("height", plot_size/2+text_size)
																
																.style('background-color', '#f2f2f2')
																.on("click", function() {
																	var gene_string = this.textContent;
																	var d3_id = '#' + gene_string + "deg";
																	var border_str = border_size + "px solid #3b5998"
																	
																	var di = added_degs.indexOf(gene_string);
																	if (di==-1)
																	{	
																		added_degs[added_degs.length] = gene_string;
																		d3.select(d3_id).style("border", border_str);
																	}
																	else
																	{
																		added_degs.splice(di, 1);
																		d3.select(d3_id).style("border", "none");
																	}
																})
																
															menu_svgs[menu_svgs.length] = deg_svg;
															
															var small_font_size_str = (font_size*2)/3 + "px";
															deg_svg.append("text")
																.attr("x", (plot_size / 4))             								
																.attr("y", (text_size*2)/3)
																.attr("text-anchor", "middle")  														 
																.style("font-size", small_font_size_str)  
																.text(others2[i])
															



															var cur_xy = new Array();
										
															var cur_indices = sorted_indices[others2[i]];
															
															
															
															
															
															for (var j=0; j<nrow; j++)
															{
																var cur_index = dimensions[cur_indices[j]];
																
																cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
															}
															
															
															
														
															
															
															
															var mep_dots_data = deg_svg
															.selectAll()				
															.data(cur_xy).enter()
															.append("circle")
															.attr("id", function(d, i) {return i;})
															.attr("cx", function(d) {return x4(d[0])})
															.attr("cy", function(d) {return x4(-d[1])})			
															.attr("r", cell_size/2)
															
															
															mep_dots_data
																.data(ex_colors[others2[i]])
																.attr("fill", function(d) {
																return "rgb("+d[0]+","+d[1]+","+d[2]+")"});
															
															
															
															
														}
														
													}
													
													if (others2.length > menu_size)
													{
														
														d3.select("#cluster_degs")
															.append("input")
															.attr("id", "more_button")
															.attr("type", "button")
															.attr("value", "More")
															.style("display", "block")
															.style("margin", "0 auto")
															.on("click", function() {
																more();
															})
													
													
														others2_index = menu_size;
														
														
														
													
														
														lasso_cp.classed("selected",false);			
														lasso_cp = new Array();
														selected_cp = new Array();
														
														d3.select('.loader').remove();
													}
													
													
													else
													{
					
												
														lasso_cp.classed("selected",false);			
														lasso_cp = new Array();
														selected_cp = new Array();
														
														d3.select('.loader').remove();
													}
												}
											});
										}
										
										
							
										
										else
										{
						
											lasso_cp.classed("selected",false);			
											lasso_cp = new Array();
											selected_cp = new Array();
											
											
											
											d3.select('.loader').remove();
											
											
										}
			
										
									}
								});
								
								
							}
							
							else
							{
								alert("Please select cells befor Done.");
							}
							
							
						})
						
					cp_window_tf = true;
				}


			};
			
			
			

			
			var lasso = d3.lasso()
			.closePathSelect(true)
			.closePathDistance(100)
			.items(dots)					
			.targetArea(svg_clustering)
			.on("start",lasso_start)
			.on("draw",lasso_draw)
			.on("end",lasso_end);
		
			svg_clustering.call(lasso);
		}
		
		
		
		function highlight()
		{
			var highs = new Array();
			
			for (var i=0; i<markers_on.length; i++)
			{
				var test = markers_on[i].split("_")
				var morg = true;
				
				if (test.length==1)
					morg = true;
				else
					morg = false;
				
				
				
				
				highs[i] = new Array();
				
				highs[i][0] = dim_id*rec_width;
				
				
				if (morg)
				{
					highs[i][1] = (1+cur_groups.length+cur_markers.indexOf(markers_on[i]))*rec_height;
				}
				else
				{
					highs[i][1] = (1+cur_groups.indexOf(markers_on[i]))*rec_height;
				}
		
			}
			
			
			
			svg.selectAll()
				.data(highs)
				.enter()
				.append("rect")
				.attr("id", "highlight")
				.attr("x", function(d) {return d[0]})
				.attr("y", function(d) {return d[1]})
				.attr("width", rec_width)
				.attr("height", rec_height)				
			
				.attr("fill", "none")
				.attr("stroke", '#ff0000')
				.attr("stroke-width", hct*2)
			
		}
		
		
		
		
		function draw_heatmap()
		{
			

			if (!first_add)
			{
				d3.select("#heatmap").select("svg").remove();
				
			
			}
			
			
			else
			{
				tooltip = d3.select("#heatmap")
				.append("div")
				.style("opacity", 0)
				.attr("class", "tooltip")
				.style("background-color", "white")
				.style("border", "solid")
				.style("border-width", "2px")
				.style("border-radius", "5px")
				.style("padding", "5px")
				.style("font-size", font_size_str)

			  // Three function that change the tooltip when user hover / move / leave a cell
				mouseover = function(d) {
					tooltip.style("opacity", 1)
				}
				mousemove = function(d) {
					tooltip
					  .html(d.circles)
					  .style("left", (d3.mouse(this)[0]+heatmap_margin.left) + "px")
					  .style("top", (d3.mouse(this)[1]+heatmap_margin.top) + "px")
				}
				mouseleave = function(d) {
					tooltip.style("opacity", 0)
				}
				
				
				tml = d3.select("#heatmap")
				.append("div")
				.style("opacity", 0)
				.attr("class", "tooltip")
				.attr("id", "tooltip_total")
				.style("background-color", "white")
				.style("border", "solid")
				.style("border-width", "2px")
				.style("border-radius", "5px")
				.style("padding", "5px")
				.style("font-size", font_size_str)
				// .raise();
				
				
				
				
				first_add = false;
			}
			
			

		
			
			

			
			
			var heatmap_height = rec_height * y_length;
			
			
			
  
			svg = d3.select("#heatmap")
				.append("svg")
					.attr("width", heatmap_width + heatmap_margin.left + heatmap_margin.right)
					.attr("height", heatmap_height + heatmap_margin.top + heatmap_margin.bottom)  
				.append("g")
					.attr("transform",
							"translate(" + heatmap_margin.left + "," + heatmap_margin.top + ")");
			
			
			var x_names = new Array();	
			
			
			for (var i=0; i<n_dims; i++)
			{
				x_names[i] = String(fd_num + i);
			}
			
			var y_names = new Array();
			
			
			
			for (var i=0; i<cur_markers.length; i++)
			{
				y_names[i] = cur_markers[cur_markers.length-1-i]; 
			}
			
			for (var i=0; i<cur_groups.length; i++)
			{
				y_names[cur_markers.length+i] = cur_groups[cur_groups.length-1-i];
			}
			
			y_names[y_names.length] = "Total";
			
			
			
			

			var x_axis = d3.scaleBand()
				.range([0, heatmap_width])
				.domain(x_names)
				.padding(0.01);
			svg.append("g")
				.attr("id", "xaxis")
				.attr("class", "x axis")
				.style("font-size", font_size_str)
				.call(d3.axisTop(x_axis))
				
				
			var y_axis = d3.scaleBand()
				.range([heatmap_height, 0])
				.domain(y_names)
				.padding(0.01);
			svg.append("g")
				.attr("id", "yaxis")
				.attr("class", "y axis")
				.style("font-size", font_size_str)
				.call(d3.axisLeft(y_axis))
				
			
			
			  
			  
			
			
			 
			 
			svg.selectAll()
				.data(heatmap_data, function(d) {return d.dim+':'+d.gene;})
				.enter()
				.append("rect")
				.attr("x", function(d) {return x_axis(d.dim)})
				.attr("y", function(d) {return y_axis(d.gene)})
				.attr("width", x_axis.bandwidth())
				.attr("height", y_axis.bandwidth())

				.style("fill", function(d) {return colorScales[d.gene](d.circles)})
				.on("mouseover", mouseover)
				.on("mousemove", mousemove)
				.on("mouseleave", mouseleave)
			
			
			
			
			for (var i=0; i<markers_on.length; i++)
			{
				d3.select('#yaxis')
				.selectAll('text')
				.filter(function(x) {return x == markers_on[i];})
				.attr('style', "font-weight: bold;");
			}
			
			
			if (selected_dim!="empty")
			{
			
				d3.select('#xaxis')
				.selectAll('text')
				.filter(function(x) {return x == selected_dim;})
				.attr('style', "font-weight: bold;");
				
				
				if (markers_on.length>0)
				{
					
					highlight();
					
				}
			}
			
			
			
			
			
			
			d3.select('#yaxis')
			.selectAll('.tick')
			.on('click', function(d)
			{
			
				
				var mi = cur_markers.indexOf(d);
				var gi = cur_groups.indexOf(d);
				var oi = markers_on.indexOf(d);
				
				if ((mi!=-1 || gi!=-1) && oi==-1)
				{
					d3.select('#yaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: bold;");
					
					markers_on[markers_on.length] = d;
					
					if (dim_id!=-1)
					{
						d3.selectAll('#highlight').remove();						
						highlight();
					}
					
					if (!first_plots)
					{
						am = new Array();
						am[0] = d;
						
						draw_markers_plots();
					}
				}
				
				else if ((mi!=-1 || gi!=-1) && oi!=-1)
				{
					if (lasso_gene==d && filtering_on)
					{
                        remove_filtering_windows();
                    
						d3.select("#plot_size_slider").style('display', 'block');
						d3.select("#stop_plot_size_change").style('display', 'none');
					}
                    
                    
                    d3.select('#yaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: regular;");
					
					markers_on.splice(oi, 1);
					
					
					if (dim_id!=-1)
					{
						d3.selectAll('#highlight').remove();
						highlight();
					}
					
					if (!first_plots)
					{
						rem = new Array();
						rem[0] = d;
						
							
						draw_markers_plots();
					}
				}	
				
			
			})
			.on("mouseover", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{
					tml.style("opacity", 1);
					
					
							
				}
			})
			.on("mousemove", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{

					var total_string = total_markers[0];
					
					for (var i=1; i<total_markers.length; i++)
					{
						
						total_string += ", " + total_markers[i];
					}
					
					tml
					.html(total_string)
					.style("left", (d3.mouse(this)[0]+heatmap_margin.left) + "px")						
					.style("top", (d3.mouse(this)[1]+heatmap_margin.top) + "px")
		
				}
			})
			.on("mouseleave", function(d)
			{
				if (d=="Total" && total_markers.length > 0)
				{
					tml.style("opacity", 0);
				
				}
			})
			
			
			
			d3.select('#xaxis')
			.selectAll('.tick')
			.on('click', function(d)
			{
				
				
				
				if (selected_dim!="empty" && selected_dim!=d)
				{
					d3.select('#xaxis')
					.selectAll('text')
					.filter(function(x) {return x == selected_dim;})
					.attr('style', "font-weight: regular;");
				}
				
				if (selected_dim!=d)
				{
					d3.select('#xaxis')
					.selectAll('text')
					.filter(function(x) {return x == d;})
					.attr('style', "font-weight: bold;");
					
					
					
					if (selected_dim=="empty")
					{
						am = new Array();
						
						for (var i=0; i<markers_on.length; i++)
						{
							am[i] = markers_on[i];
						}
					}
					
					else
					{
						dcm = new Array();
						for (var i=0; i<markers_on.length; i++)
						{
							dcm[i] = markers_on[i];
						}
					}
					
					
					
					selected_dim = d;
					
					var selected_dim2 = Number(d);
					
					dim_id = selected_dim2-fd_num;
					
					
					if (markers_on.length>0)
					{
						d3.selectAll('#highlight').remove();
						highlight();
					}
					
					
					
					
					draw_cluster_plot();
					
					
					
					
					
					draw_markers_plots();
					

				}

			});
			
			
			

			for (var i=0; i<cur_groups.length; i++)
			{
		
				var cur_group = hulls[cur_groups[i]];
				
				
				if (cur_group!=-1)
				{
				
					if (cur_group.length!=0)
					{			
						for (var j=0; j<n_dims; j++)
						{
							var cur_hull = cur_group[j];
							
							
							if (typeof cur_hull != "undefined")
							{
					
								var scaled_hull = new Array();
								
								for (var k=0; k<cur_hull.length; k++)
								{
									scaled_hull[k] = [hc_scale_x(cur_hull[k][0]) + rec_width*j, hc_scale_y(-cur_hull[k][1]) + rec_height*(1+i)];
								}
								
								
								var cur_id = "#" + cur_groups[i] + j;
								
								
								
								svg
									.append("path")
									.attr("id", cur_id)
									.style("fill", "none")
									.style("stroke", "white")
									.style("stroke-width", hct)
									.attr("d", line(scaled_hull));
								
							
							}
						}
					}	
				}
			}
			
			for (var i=0; i<cur_markers.length; i++)
			{
				
				var cur_marker = hulls[cur_markers[i]];
				
				if ((cur_marker!=-1) && (cur_marker.length!=0))
				{
					for (var j=0; j<n_dims; j++)
					{
						var cur_hull = cur_marker[j];
						
						if (typeof cur_hull != "undefined")
						{
					
							var scaled_hull = new Array();
							
							for (var k=0; k<cur_hull.length; k++)
							{
								scaled_hull[k] = [hc_scale_x(cur_hull[k][0]) + rec_width*j, hc_scale_y(-cur_hull[k][1]) + rec_height*(1+cur_groups.length+i)];
							}
							
							
							var cur_id = "#" + cur_markers[i] + j;
							
							
							
							svg
								.append("path")
								.attr("id", cur_id)
								.style("fill", "none")
								.style("stroke", "white")
								.style("stroke-width", hct)
								.attr("d", line(scaled_hull));
						}
					}
					
					
					
				}
			}

			
		
				
			

			var smaller_wh = rec_width;
			
			if (rec_width > rec_height)
				smaller_wh = rec_height;
			
			var stride = smaller_wh * 0.1;

			var smallest_arr = new Array();
			
			smallest_arr[0] = [smallest_dim["Total"]*rec_width + stride, stride];
			
			
			for (var i=0; i<cur_groups.length; i++)
			{
				smallest_arr[smallest_arr.length] = [smallest_dim[cur_groups[i]]*rec_width + stride, (1+i)*rec_height + stride];
			}
			
			
			for (var i=0; i<cur_markers.length; i++)
			{
				smallest_arr[smallest_arr.length] = [smallest_dim[cur_markers[i]]*rec_width + stride, (1+cur_groups.length+i)*rec_height + stride];
			}
			
			
			
			
			
			
			
			svg.selectAll()
				.data(smallest_arr)
				.enter()
				.append("rect")
				.attr("id", "smallest_dims")
				.attr("x", function(d) {return d[0]})
				.attr("y", function(d) {return d[1]})
				.attr("width", (rec_width - stride*2))
				.attr("height", (rec_height - stride*2))				
				
				.attr("fill", "none")
				.attr("stroke", "yellow")
				.attr("stroke-width", hct*2)

			
				
			new_markers = new Array();
			old_markers = new Array();
			
			
            
            new_groups = new Array();
            old_groups = new Array();

			
			
			
			console.log("draw_heatmap finish");
			
			
			
			highlight();
			
			
			
			
			
			

			d3.select('.loader').remove();	
			
		}
		
		
		
		
		
	
		var width = $(window).width();
		var height = $(window).height();
		console.log(width, height);
		
		smaller = 1000000;
		if (width > height)
		{
			smaller = height;
		}
		else
			smaller = width;
		
		
		
		var slider = document.getElementById("slider");
		var style = document.querySelector('[data="test"]');
		var pointer_size = smaller * 0.02;
		style.innerHTML = ".slider::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
		
		
		
		slider_height = pointer_size / 4;
		shs = String(slider_height) + 'px';
		d3.select('.slider').style('height', shs);
		
		
		
		
		var slider_vertical = document.getElementById("plot_size_slider");
		var style_vertical = document.querySelector('[data="test_vertical"]');
		style_vertical.innerHTML = ".slider_vertical::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
		
		
		d3.select('.slider_vertical').style('height', shs);
		
		var slider_width = smaller/3;
		var sws = String(slider_width) + 'px';
		d3.select('.slider_vertical').style('width', sws);
		
		
		
		var svm = smaller*0.08 + 'px';
		d3.select('.slider_vertical').style('margin-top', svm);
		
		
		var vsb_len = smaller/3 + smaller*0.08 + 'px';
		d3.select('#vsb').style('height', vsb_len);
		
		
		font_size = smaller * 0.015;
		font_size_str = font_size + "px";
		
		border_size = font_size/5;
		
		d3.selectAll('.texts').style('font-size', font_size_str);
		
		
		
		
		
		
		document.querySelector("#plot_size_value").innerHTML = "Plot size: " + d3.select('#plot_size_slider')["_groups"][0][0].value;
		
		
		
		$(window).resize(function() {
			if(this.resizeTO) clearTimeout(this.resizeTO);
			this.resizeTO = setTimeout(function() {
				$(this).trigger('resizeEnd');
			}, 500);
		});

		$(window).bind('resizeEnd', function() {
			
			
			width = $(this).width();
			height = $(this).height();
			console.log(width, height);
			
			
	
			
			
			smaller = 1000000;
			if (width > height)
			{
				smaller = height;
			}
			else
				smaller = width;
			
			
			
			slider = document.getElementById("slider");
			style = document.querySelector('[data="test"]');
			pointer_size = smaller * 0.02;
			style.innerHTML = ".slider::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
			
			font_size = smaller * 0.015;
			font_size_str = font_size + "px";
			
			border_size = font_size/5;
			
			d3.selectAll('.texts').style('font-size', font_size_str);
			
			d3.select('.tooltip').style('font-size', font_size_str);
			
			slider_height = pointer_size / 4;
			shs = String(slider_height) + 'px';
			d3.select('.slider').style('height', shs);
			
			
			slider_vertical = document.getElementById("plot_size_slider");
			style_vertical = document.querySelector('[data="test_vertical"]');
			style_vertical.innerHTML = ".slider_vertical::-webkit-slider-thumb { width: " + pointer_size/2 + "px !important; height: " + pointer_size + "px !important; }";
			
			
			d3.select('.slider_vertical').style('height', shs);
			
			
			slider_width = smaller/3;
			sws = String(slider_width) + 'px';
			d3.select('.slider_vertical').style('width', sws);
			
			
			svm = smaller*0.08 + 'px';
			d3.select('.slider_vertical').style('margin-top', svm);
			
			vsb_len = smaller/3 + smaller*0.08 + 'px';
			d3.select('#vsb').style('height', vsb_len);
			
			
			/////////////////////////////////////////////////////////////////////////////////////////////////////
			
			
			
			margin_size = font_size*2;
			hct = smaller * 0.001;
			
			
			heatmap_margin = {top: margin_size, right: margin_size, bottom: margin_size, left: margin_size*7};
            
            hist_margin = {top: 10, right: 10, bottom: margin_size, left: margin_size*1.5};
			
			outer_width = d3.select('.outer')["_groups"][0][0].getBoundingClientRect().width;
			
			heatmap_width = outer_width - heatmap_margin.left - heatmap_margin.right;
			
			

			
			
			
			
					
			clustering_width = d3.select('#clustering')["_groups"][0][0].getBoundingClientRect().width;
						
			legend_size = width*0.015;	

			
			if (clustering_width > width*0.5)
			{
				plot_size = smaller*0.5;
				clustering_width = plot_size + legend_size;
			}
			else						
				plot_size = clustering_width - legend_size;
			
			ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
			ep_cell_size = ep_size*0.002;
			
			cell_size = smaller * 0.001;
			
			x = d3.scaleLinear()
				.domain([-dom, dom])
				.range([0, plot_size]);
				
			x2 = d3.scaleLinear()
					.domain([-dom, dom])
					
					.range([0, ep_size]);
					
			x4 = d3.scaleLinear()
			.domain([-dom, dom])
			.range([0, plot_size/2]);
			
			
			
				
			if (!first_add)
			{
		
				y_length = 1 + cur_groups.length + cur_markers.length;
			
			
				unit_height = height * 0.05;
				
				var cur_height = y_length*unit_height;
				var half_height = height/2;
				
				
				
				if (cur_height > half_height)
				{
					rec_height = half_height/y_length;
				}
				else
					rec_height = unit_height;
				
				if ((unit_height * n_dims) > heatmap_width)
				{
					rec_width = heatmap_width / n_dims;
				}
				else
				{
					rec_width = unit_height;
					heatmap_width = unit_height * n_dims;
				}
				

				hc_scale_x = d3.scaleLinear()
						.domain([-dom, dom])
						.range([0, rec_width]);
						
				hc_scale_y = d3.scaleLinear()
						.domain([-dom, dom])
						.range([0, rec_height]);
				
				
				draw_heatmap();
				
					
				
				
				if (dim_id!=-1)
				{
					draw_cluster_plot();
				
					if (markers_on.length > 0)
					{
						rsm = new Array();
						
						
						for (var i=0; i<groups.length; i++)
						{
							rsm[rsm.length] = groups[i];
						}
						
						for (var i=0; i<markers.length; i++)
						{
							rsm[rsm.length] = markers[i];
						}
						
						
						
						draw_markers_plots();
					}
				}
				
				
				
			}
			
			if (!first_ani)
			{
				renderer.setSize(plot_size, plot_size);
				uniforms[ "cell_size" ].value = cell_size;	
				if (cur_dim<(n_dims-1))
				{
					
					renderer.render(scene, camera);				
				}
			}
			
		});
		
		
		
		function getLinePoints(curvePoints, numPoints){
			path_ani.attr('d', line(curvePoints));
			var svgLine = path_ani.node();
			var lineLength = svgLine.getTotalLength();
			var interval;
			if (numPoints === 1) {
				interval = 0;
			} else {
				interval = lineLength / (numPoints - 1);
			}
			return d3.range(numPoints).map(function (d) {
			var point = svgLine.getPointAtLength(d * interval);
			return [ point.x, point.y ];
			});
		};
		
		
		

		
		
		function calculate_animation () {

			
			if (new_marker_ani != "")
			{
				animations[new_marker_ani] = new Array();
				
				
				for (var i=0; i<n_dims; i++)
				{
					animations[new_marker_ani][i] = getLinePoints(hulls[new_marker_ani][i], ndots)
					
					
				}

			}
			
			
			var cur_hulls = animations[cur_marker_ani];
			
			marker_tex_data = new Array();
					
			for (var i=0; i<n_dims; i++)
			{
				var cur_dim_hulls = cur_hulls[i];
				
				for (var j=0; j<ndots; j++)
				{
					var cur_dot = cur_dim_hulls[j];
					
					marker_tex_data[marker_tex_data.length] = cur_dot[0];
					marker_tex_data[marker_tex_data.length] = cur_dot[1];
				}
				
			}
		
			
			
			
			mw = ndots/2;
		
			mh = n_dims;
		   
			
			markerTex = new THREE.DataTexture(new Float32Array(marker_tex_data), mw, mh, THREE.RGBAGormat, THREE.FloatType);
			markerTex.minFilter = THREE.NearestFilter;
			markerTex.magFilter = THREE.NearestFilter;
			markerTex.needsUpdate = true;

			
			
	
			
			var members = cur_marker_ani.split("_");
			var morg = true;
			
			if (members.length > 1)
				morg = false;
			
			
			ex_tex_data = new Array();
			
			
			ew = 1;
			eh = Math.ceil(nrow/4);
			
			
			
			if (morg)
			{
			
				for (var j=0; j<nrow; j++)
				{
				
					var cur_value = Number(expressions[cur_marker_ani][j+1]);
					
					ex_tex_data[ex_tex_data.length] = cur_value;
	
				}
			
				
			}	
			
			else
			{
				var cur_ids = cell_ids[cur_marker_ani];
				
				for (var j=0; j<nrow; j++)
				{
					if (cur_ids.indexOf(j) == -1)
						ex_tex_data[j] = 0.0;
					else
						ex_tex_data[j] = 1.0;
					
					
	
				}
			}
				
				
				
			if (nrow%4!=0)
			{
				for (var j=0; j<(eh*4-nrow); j++)
				{
					ex_tex_data[ex_tex_data.length] = 0.0;
					
				}
			}
			
			
			
			exTex = new THREE.DataTexture(new Float32Array(ex_tex_data), ew, eh, THREE.RGBAGormat, THREE.FloatType);
			exTex.minFilter = THREE.NearestFilter;
			exTex.magFilter = THREE.NearestFilter;
			exTex.needsUpdate = true;
			
			
			uniforms["expression"].value = exTex;
			uniforms["ew"].value = ew;
			uniforms["eh"].value = eh;
			
			if (morg)
            {
				uniforms["e_max"].value = ex_maxs[cur_marker_ani];
                uniforms["e_min"].value = ex_mins[cur_marker_ani];
			}
            else
            {
				uniforms["e_max"].value = 1.0;
                uniforms["e_min"].value = 1.0;
			}
			
			
	
			
			uniforms["marker"].value = markerTex;
			uniforms["mw"].value = mw;
			uniforms["mh"].value = mh;
			
			

			d3.select("#card_animation").style("display", "block")
			
  
			if (cur_dim<(n_dims-1))		
			{
				
				renderer.render(scene, camera);
			}
		
			
			var cms = "";
			
			if (cur_marker_ani != "")
				cms = "<span style='color: red;'>" + cur_marker_ani + " </span>"
			
			
			document.querySelector("#current_markers").innerHTML = cms;
			
			
		
			
			
			new_marker_ani = "";
			old_marker_ani = "";
		}




		
		function intersect(a, b) {
			var tmp={}, res=[];
			for(var i=0;i<a.length;i++) tmp[a[i]]=1;
			for(var i=0;i<b.length;i++) if(tmp[b[i]]) res.push(b[i]);
			return res;
		}
		
		
		
		
		
		
		
		
	
        function calculate_groups ()
		{
			
			console.log("calculate_groups");
			
			
			
			if (intersect_tf)
			{
				for (var i=0; i<new_groups.length; i++)
                {                
                    var cur_group_name = new_groups[i];
                    
                    var cur_members = cur_group_name.split("_");
                    
                    var intersect_ids = cell_ids[cur_members[0]];
                    
                    for (var j=1; j<cur_members.length; j++)
                    {
                        intersect_ids = intersect(intersect_ids, cell_ids[cur_members[j]]);
                    }
                    
                    cell_ids[cur_group_name] = intersect_ids;
                }
			}
			
		
            
            var valid_groups = new Array();
            
            for (var i=0; i<new_groups.length; i++)
            {
                 var cur_group_name = new_groups[i];
                
                if (cell_ids[cur_group_name].length > 2)
                {
                    valid_groups[valid_groups.length] = cur_group_name;
                }
            }
            
            
            if (valid_groups.length > 0)
            {
            
                valid_groups_test = valid_groups.length;
                
                
                var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                  + rds_name + "_" + nrow + "_" + n_dims + "_" + valid_groups.length + "_" + density_th + "_";
                  
                for (var i=0; i<valid_groups.length; i++)
                {
                    var cur_cell_ids = cell_ids[valid_groups[i]];
                    
                    if (i!=0)
                    {
                        density_string += " ";
                    }
                    
                    density_string += cur_cell_ids.length;
                    
                    for (var j=0; j<cur_cell_ids.length; j++)
                    {
                        density_string = density_string + " " + cur_cell_ids[j];
                    }
                    
                    for (var j=0; j<nrow-cur_cell_ids.length; j++)
                    {
                        density_string = density_string + " " + 0;
                    }
                    
                }
                
                // density_string_test = density_string;
                  
                console.time("density.py time:");	
                            
                $.ajax({
                    async: true,
                
                    url: "density.py",
                    type: 'POST',
                    
                    contentTpye: 'application/json',
                    dataType: 'json',
                
                    data: {'fd_ld': density_string},
                    
                    success: function(response){
                        
                        var endTime2 = new Date().getTime();
                        
                        console.timeEnd("density.py time:");
                        
                        console.log("density.py finish");
                        
                        // 201126 group error
                        
                        var filtered_ids_result = response["filtered_ids"];
                           
                        filtered_ids_test = filtered_ids_result;
                        
                        
                        ids_test = response["ids"];
                        density_test = response["density"];
                        

                        for (var i=0; i<valid_groups.length; i++)
                        {
                            var cur_group_name = valid_groups[i];
                            
                            
                         
                            
                            filtered_ids[cur_group_name] = new Array();
                            
                            
                            
                            for (var j=0; j<n_dims; j++)
                            {                                                                                     
                                filtered_ids[cur_group_name][j] = new Array();
                                
                                var fc = 0;
                                
                                for (var k=0; k<nrow; k++)
                                {
                                    var cur_id = filtered_ids_result[i*n_dims*nrow + j*nrow + k];
                                    
                                    if (cur_id != -1)  
                                    {
                                        filtered_ids[cur_group_name][j][fc] = cur_id;
                                        
                                        fc++;
                                    }
                                }
                            }
                            
                            
                            var cur_ids = cell_ids[cur_group_name];
				
								
							sorted_indices[cur_group_name] = new Array();
							
							var cur_indices = sorted_indices[cur_group_name];
							
							for (var j=0; j<nrow; j++)
							{
								if (cur_ids.indexOf(j) == -1)
								{						
									cur_indices[cur_indices.length] = j;
								}
							}
							
							for (var j=0; j<cur_ids.length; j++)
							{
								cur_indices[cur_indices.length] = cur_ids[j];
							}
							
							
							
							
							reverse_sorted_indices[cur_group_name] = new Array();
												
							var cur_reverse_indices = reverse_sorted_indices[cur_group_name];
							
							for (var j = 0; j < nrow; ++j) cur_reverse_indices[j] = j;
							cur_reverse_indices.sort(function (a, b) { return cur_indices[a] < cur_indices[b] ? -1 : cur_indices[a] > cur_indices[b] ? 1 : 0; });
							
							
							

							ex_colors[cur_group_name] = new Array();
							var cur_color = ex_colors[cur_group_name];
							
							for (var j=0; j<(nrow-cur_ids.length); j++)
							{
								cur_color[cur_color.length] = [226, 226, 226];
							}
							
							for (var j=0; j<cur_ids.length; j++)
							{
								cur_color[cur_color.length] = [0, 0, 255];
							}
						
							
							
							console.log("The number of final selected cells: " + final_selected.length);
							
							
							hulls[cur_group_name] = new Array();
							lines[cur_group_name] = new Array();
							areas[cur_group_name] = new Array();
							
						
							
							var cur_areas = new Array();
							
							var smallest_area = Number.MAX_VALUE;
							var largest_area = Number.MIN_VALUE;
							
							for (var j=0; j<n_dims; j++)
							{						
								
								
                                
                                var cur_cells = filtered_ids[cur_group_name][j];
                                
                                var cur_len = cur_cells.length;
								
								
								if (cur_len > 2)
								{								
									
                                    
                                    

									var points = new Array();
														
									for (var k=0; k<cur_len; k++)
									{
										var cur_id_dim = dimensions[cur_cells[k]];
										
										points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
									} 
												
									var cur_hull = d3.polygonHull(points);
									
									hulls[cur_group_name][j] = cur_hull;
									
									var scaled_hull = new Array();
										
									for (var k=0; k<cur_hull.length; k++)
									{
										scaled_hull[k] = [x2(cur_hull[k][0]), x2(-cur_hull[k][1])];
									}
																						
									lines[cur_group_name][j] = line(scaled_hull);
									
									var cur_area = -d3.polygonArea(scaled_hull);
																					
									cur_areas[j] = cur_area;
																													
									if (cur_area > largest_area)
									{
										largest_area = cur_area;										
									}
																																	
									if (cur_area < smallest_area)
									{
										smallest_area = cur_area;
										smallest_dim[cur_group_name] = j;
									}
								}
								
								else
								{
									cur_areas[j] = 0;
									
									lines[cur_group_name][j] = 0;
								}
							}
							
							
					
							
							
							
							if (largest_area > 0)
							{
								for (var j=0; j<n_dims; j++)
								{									
									
                                    areas[cur_group_name][j] = (cur_areas[j]-smallest_area) / (largest_area-smallest_area);
								
								}
							}	
							
							else
							{
								for (var j=0; j<n_dims; j++)
								{									
									areas[cur_group_name][j] = 0;
								
								}
							}
                            
                            
                            
                            
                            
                        }
                        
                        
                        if (intersect_tf)
                        {
                            all_genes_done();
                        }
                        
                        else
                        {
                            if (cur_group_name in deg_others)
                            {
                                delete deg_others[cur_group_name];
                            }
                            
                            
                            if (markers_ani.indexOf(cur_group_name)!=-1)
                            {
                                new_marker_ani = cur_group_name;
                                cur_marker_ani = cur_group_name;
                                
                                calculate_animation();
                                
                                console.log("ani again");
                                
                            }
                            
                            var lasso_gene_id = "#" + cur_group_name;
                            
                          
                            
                            var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                            
                            // 201126
                            if (typeof selected_density != "undefined")
                            {
                                for (var j=0; j<selected_density.length; j++)
                                {
                    
                                    cur_lasso_dots[selected_density[j]].setAttribute("class", "");
                                }
                            }
                            
                            selected = new Array();
                            
                            final_selected = new Array();
                            
                            selected_density = new Array();
                            
                            
           
                            ccm = new Array();
                            
                            ccm[0] = lasso_gene;
                            
                            draw_markers_plots();
                            
                            
                 
                            
                            lasso_temp = new Array();
                        

                            
                            all_genes_done();
                            
                            
                            var cur_members = cur_group_name.split("_");
                    
                            for (var i=0; i<cur_members.length; i++)
                            {
                                d3.select('#lasso_window' + cur_members[i]).remove();
                            }
                            
                            d3.select('#inputs_window').remove();
                            
                            lasso_gene = "";
                            
                            
                            filtering_on = false;
                            density_on = false;
                            
                            intersect_tf = true;
							
							d3.select("#plot_size_slider").style('display', 'block');
							d3.select("#stop_plot_size_change").style('display', 'none');
                                
                        }
                    }
                });
            }    
                     
            else
            {
                // alert("The groups you entered are not in the data or the genes are differentially expressed in less than 3 cells.");
                
                for (var i=0; i<new_groups.length; i++)
                {
                    var cur_group_name = new_groups[i];
                    
                    
               
                    hulls[cur_group_name] = new Array();
                    lines[cur_group_name] = new Array();
                    areas[cur_group_name] = new Array();
                    
                    
                    
                    sorted_indices[cur_group_name] = new Array();
                    reverse_sorted_indices[cur_group_name] = new Array();
                    
                    ex_colors[cur_group_name] = new Array();
                    var cur_color = ex_colors[cur_group_name];
                    
                    
                    
                    for (var j=0; j<nrow; j++)
                    {
                        cur_color[j] = [226, 226, 226];
                    }
                    
                    for (var j=0; j<n_dims; j++)
                    {						
                        
                        areas[cur_group_name][j] = 0;	
                    }
                    
                    
                    smallest_dim[cur_group_name] = 0;
                    
                    
                    for (var j=0; j<n_dims; j++)
                    {
                        lines[cur_group_name][j] = 0;
                    }
                    
                    
                    
                }
                
                if (intersect_tf)
                {
                    all_genes_done();
                }
                
                else
                {
                    if (lasso_gene in deg_others)
                    {
                        delete deg_others[lasso_gene];
                    }
                    
                    
                    if (markers_ani.indexOf(lasso_gene)!=-1)
                    {
                        new_marker_ani = lasso_gene;
                        cur_marker_ani = lasso_gene;
                        
                        calculate_animation();
                        
                        console.log("ani again");
                        
                    }
                    
                    var lasso_gene_id = "#" + lasso_gene;
                    
                   
                    
                    var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
                    
                    
                    
                    for (var j=0; j<selected_density.length; j++)
                    {
        
                        cur_lasso_dots[selected_density[j]].setAttribute("class", "");
                    }
                    
                    
                    selected = new Array();
                    
                    final_selected = new Array();
                    
                    selected_density = new Array();
                    
                    
   
                    ccm = new Array();
                    
                    ccm[0] = lasso_gene;
                    
                    draw_markers_plots();
                    
                 
                    
                    
                    
                    lasso_temp = new Array();
                

                    
                    all_genes_done();
                    
            
                    for (var i=0; i<members.length; i++)
                    {
                        d3.select('#lasso_window' + members[i]).remove();
                    }
                    
                    d3.select('#inputs_window').remove();
                    
                    lasso_gene = "";
                    
                    
                    filtering_on = false;
                    density_on = false;
                
					d3.select("#plot_size_slider").style('display', 'block');
					d3.select("#stop_plot_size_change").style('display', 'none');
                }
  
            }
	
		}
		
		

		 
	
		function cell_filtering () {
	
			
			
				
			
			var members = lasso_gene.split("_")
			var morg = true;
			
			if (members.length==1)
				morg = true;
			else
				morg = false;
			
			
			
			var lasso_gene_id = '#' + lasso_gene;
			
			
			
			nrow = dimensions.length;
			
			dec = new Array();
			sorted_dec = new Array();
			
			density_indices = new Array();
			
			
			filtering_size = ep_size * (2/3);
			
			x_filtering = d3.scaleLinear()
						.domain([-dom, dom])
						.range([0, filtering_size]);
			
			
			if (morg)
			{
				var cur_bounding = d3.select(lasso_gene_id)["_groups"][0][0].getBoundingClientRect();
				
				
				histo_ex = new Array();
				var histo_ex_max = ex_maxs[lasso_gene];
				
				var cur_gene = expressions[lasso_gene];
				
				for (var i=0; i<nrow; i++)
				{
					
					var cur_ex = Number(cur_gene[i+1]);
					
					histo_ex[histo_ex.length] = cur_ex;

				}
				
				var histGenerator = d3.histogram()
				.domain([0, histo_ex_max])
				.thresholds(num_bins);
				
				bins = histGenerator(histo_ex);
			
				
				
				bins_ids = new Array();
				
				for (var i=0; i<bins.length; i++)
				{
					bins_ids[i] = new Array();
				}
				
				bins_range = bins[0].x1 - bins[0].x0;
			
				
				for (var i=0; i<nrow; i++)
				{			
					var bin_id = Math.floor(histo_ex[i] / bins_range);
					
					var cur_bin = bins_ids[bin_id];
					
					cur_bin[cur_bin.length] = i;
			
				}
				
				
				
				var slider_height = Number(d3.select('#slider')["_groups"][0][0].style.height.replace("px", ""));
				
				var lasso_window_w = filtering_size + hist_margin.left + hist_margin.right;
				
				var lasso_window_h = filtering_size + filtering_size/2 + hist_margin.top + hist_margin.bottom + slider_height + 50;
				
				d3.select('body')
					.append('div')
	
					.attr("id", "lasso_window" + lasso_gene)
					.style('width', lasso_window_w )
					.style('height', lasso_window_h)
					.style('position', 'absolute')
					.style('left', cur_bounding.left + 'px')
					.style('top', $(document).scrollTop() + cur_bounding.top + cur_bounding.height + 'px')
					.style('padding', '10px 10px 10px 10px')
					.style('display', 'block')
                    // .style('display', 'table')
					.style('background-color', '#e2e2e2')
					.raise();
				

				
				
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr('class', 'row')
					.attr("id", "mep"+lasso_gene)
					.style('padding-left', '10px')
					.style('padding-right', '20px');
					
				var cur_mep_name = "#mep" + lasso_gene;
				
				
				var mep_svg = d3.select(cur_mep_name)
				.append("svg")		
				.attr("id", "mep_svg" + lasso_gene)
				.attr("width", filtering_size)
				.attr("height", filtering_size)
				.style("background-color", "white")
				.style("margin", "0 auto")


		
				

				mep_svg.append("text")
				.attr("x", (filtering_size / 2)) 
				.attr("y", legend_size/2+10)
				.attr("text-anchor", "middle")  					 
				.style("font-size", font_size_str)  
				.text(lasso_gene)
				
				

				
				
				
				var cur_xy = new Array();
							
				var cur_indices = sorted_indices[lasso_gene];
				
				
				
				
				for (var j=0; j<nrow; j++)
				{
					var cur_index = dimensions[cur_indices[j]];
					
					cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
				}
				
				
				
				var mep_dots = mep_svg.append('g')
				.attr("id", "mep_dots" + lasso_gene)
				
				var mep_dots_data = mep_dots.selectAll()								
				.data(cur_xy).enter()
				.append("circle")
				.attr("id", function(d, i) {return i;})
				.attr("cx", function(d) {return x_filtering(d[0])})
				.attr("cy", function(d) {return x_filtering(-d[1])})			
				.attr("r", ep_cell_size)
				
			
			
				mep_dots_data.data(ex_colors[lasso_gene])
				.attr("fill", function(d) {
				return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
				
				
				
				
				var mep_dots_id = "#mep_dots" + lasso_gene;
				
				
				
				
				var lasso_start = function() {
					
					if (density_on)
						lasso.items()				
				};
				
				
				var lasso_draw = function() {

				};
				
				
				
				
				var lasso_end = function() {
					

					if (density_on)
					{
						
						
						
						if (selected.length != 0)
						{
							lasso_temp.classed("selected",false);			
							lasso_temp = new Array();
							selected = new Array();
							
						}
						
						
						lasso_temp = lasso.selectedItems();
						
						selected = lasso.selectedItems()['_groups'][0].map(d=>d.id).map(x=>+x);
						
						
						final_selected = new Array();
						selected_density = new Array();
					
					
                        // 201125 lasso
                    
						// var cur_indices_lasso = density_indices;
						
					
						for (var j=0; j<selected.length; j++)
						{
							var cur_density_id = selected[j];
                            
                            // if (cur_density_id >= (nrow-dec.length))
                            // {
                                // final_selected[final_selected.length] = dec[density_indices[cur_density_id]];
                                
                            var offset = nrow-dec.length;
                                  
                            
                            // if (cur_density_id >= (nrow-dec.length))
                            if (cur_density_id >= offset)
                            {
                                final_selected[final_selected.length] = dec[density_indices[cur_density_id-offset]];
								
								selected_density[selected_density.length] = cur_density_id;
                            }
                            
							
                            // var cur_ori_id = cur_indices_lasso[cur_density_id];
							
							// var fi = dec.indexOf(cur_ori_id);
							
							// if (fi!=-1)
							// {
								// final_selected[final_selected.length] = cur_ori_id;
								
								// selected_density[selected_density.length] = cur_density_id;
							// }
						}
						
						
						
						var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
							
						for (var j=0; j<selected_density.length; j++)
						{
			
							cur_lasso_dots[selected_density[j]].setAttribute("class", "selected");
						}
						
						
						
					}
					

				};
				
				
				

				
				var lasso = d3.lasso()
				.closePathSelect(true)
				.closePathDistance(100)
				.items(mep_dots_data)					
				.targetArea(mep_svg)
				.on("start",lasso_start)
				.on("draw",lasso_draw)
				.on("end",lasso_end);
			
				mep_svg.call(lasso);
					
		

				var histogram_w = filtering_size + hist_margin.left + hist_margin.right;
				var histogram_h = filtering_size/2 + hist_margin.top + hist_margin.bottom;
					
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("class", "row")
					.attr("id", "histogram")
					.style('width',  histogram_w)
					.style('height', histogram_h)	
	
					// .style('padding-left', '10px')
                    // .style('padding-left', '50px')
					// .style('padding-right', '20px')
                    // .style("margin", "0 auto")
					.style('display', 'block')
                    // .style('display', 'table-cell')
					.raise();
                    
				
				// 201201 histogram
                
				var svg_hist = d3.select('#histogram')
					.append("svg")
                        .attr("id", "histogram_svg")
						.attr("width", filtering_size + hist_margin.left + hist_margin.right)
						.attr("height", filtering_size/2 + hist_margin.top + hist_margin.bottom)
                        .style('display', 'block')
                        .style("margin", "0 auto")
					.append("g")
						.attr("transform",
							"translate(" + hist_margin.left + "," + hist_margin.top + ")");
							
				var hist_x = d3.scaleLinear()
					.domain([0, histo_ex_max])
					.range([0, filtering_size]);
				
				svg_hist.append("g")
					.attr("transform", "translate(0," + filtering_size/2 + ")")
					.call(d3.axisBottom(hist_x));
					
				var hist_y = d3.scaleLinear()
					.range([filtering_size/2, 0]);
					
				hist_y.domain([0, d3.max(bins, function(d) {return d.length;})]);
				
				svg_hist.append("g")
					.attr("id", "hist_y")
					.call(d3.axisLeft(hist_y));
				
				
				svg_hist.selectAll("rect")
					.data(bins)
					.enter()
					.append("rect")
						.attr("x", 1)
						.attr("transform", function(d) { return "translate(" + hist_x(d.x0) + "," + hist_y(d.length) + ")"; })
						.attr("width", function(d) { return hist_x(d.x1) - hist_x(d.x0) -1 ; })
						.attr("height", function(d) { return filtering_size/2 - hist_y(d.length); })
						.style("fill", "#69b3a2")

				
				
				hist_th = histo_ex_max;
				
				svg_hist.append("rect")
					.attr("id", "selection")
					.attr("transform", "translate(" + hist_x(hist_th) + ",0)")
					.attr("width", hist_x(histo_ex_max - hist_th))
					.attr("height", filtering_size/2)
					.style("fill", "rgba(0, 0, 255, 0.3)");
					
				var slider_padding = hist_margin.left + 10 + "px 10px 10px 10px";
					
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("class", "row")
					.attr("id", "selection_slider")

					.style('width',  histogram_w)
					.style('height', slider_height)
					
					// .style('padding-left', '10px')
					// .style('padding-right', '20px')
					.style('padding-bottom', '10px')
					.style('display', 'block')
                    // .style("margin", "0 auto")									
					.raise();
				
				
		
				var slider_left = hist_margin.left  + "px";

				var slider_width = filtering_size*(bins.length/(bins.length-1)) + "px";
				
				
				var slider_margin_left = (hist_margin.left + d3.select("#histogram_svg")._groups[0][0].getBoundingClientRect().x - d3.select("#histogram")._groups[0][0].getBoundingClientRect().x) + "px";
				
                console.log(slider_margin_left);
                
				var th_id;
                
				d3.select('#selection_slider')
                    // .append("g")
						// .attr("transform",
							// "translate(" + hist_margin.left + ",0)")
					.append("input")								
                    .attr("id", "silderid")
					.attr("type", "range")
				
					.attr("value", histo_ex_max)
					.attr("min", 0)
					.attr("max", histo_ex_max)
			
					.attr("step", bins[0].x1 - bins[0].x0)
		
					// .style("position", "absolute")
	
					// .style("left", slider_left)
	
					// .style("width", slider_width)
                    .style("width", filtering_size + "px")
					// .style("margin-bottom", "30px")
                    .style('display', 'block')
                    // .style("margin", "0 auto")	
                    // .style("margin-left", slider_margin_left)
					.on("change", function() { 

						if (!density_on)
						{
							var cur_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
						
							for (var i=0; i<sorted_dec.length; i++)
							{
								
							
								cur_dots[sorted_dec[i]].setAttribute("class", "");
							
								
							}
							
							
							
							dec = new Array();
							sorted_dec = new Array();
							
							
							//ex_th = this.value;
							
							hist_th = this.value;										
							th_id = hist_th / bins_range;
							
							
							var cur_reverse = reverse_sorted_indices[lasso_gene];
							
							for (var i=0; i<bins_ids.length; i++)
							{
								if (i >= th_id)
								{
									var cur_bin = bins_ids[i];
									
									for (var j=0; j<cur_bin.length; j++)
									{
										var cur_id = cur_bin[j];
										
										dec[dec.length] = cur_id;
										
										
										
										
										var sorted_id = cur_reverse[cur_id];
										
										
										
										cur_dots[sorted_id].setAttribute("class", "selected");
										
										
										
										sorted_dec[sorted_dec.length] = sorted_id;
									}
								}						
							}
							
							
						

							
							d3.select("#selection")
								.attr("transform", "translate(" + hist_x(hist_th) + ",0)")
								.attr("width", hist_x(histo_ex_max - hist_th));
						}
						
					});
					
				// 210916
				
				d3.select('#lasso_window' + lasso_gene)
					.append('div')
					.attr("id", "set_center")
					.append('ol')
					//.attr("class", "breadcrumb mb-4")
					.attr("id", "inputs")
					
				
				
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "density_plot")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Density Plot")
					.style("margin", "0 auto")
				
					.on("click", function() {
						
						if (dec.length > 2)
						{
							if (density_on)
							{
								if (final_selected.length > 0)
								{
								
									lasso_temp = new Array();
									
									
									

									var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
										
									for (var j=0; j<selected_density.length; j++)
									{
						
										cur_lasso_dots[selected_density[j]].setAttribute("class", "");
									}
									
									
									selected = new Array();
									
									fianl_selected = new Array();
									
									sorted_fianl_selected = new Array();
									

								}
								
								
								
								
								var cur_xy_dp = new Array();
							
								var cur_indices_dp = sorted_indices[lasso_gene];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices_dp[j]];
									
									cur_xy_dp[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								
								

								
								d3.select(mep_dots_id)
								.selectAll('circle')
								.data(cur_xy_dp)
								.attr("cx", function(d) {return x_filtering(d[0])})
								.attr("cy", function(d) {return x_filtering(-d[1])})
								
						
							
								
								
								d3.select(mep_dots_id)
									.selectAll('circle')
									.data(ex_colors[lasso_gene])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
									
								


								var cur_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];

								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									
									 cur_dots[sorted_dec[i]].setAttribute("class", "selected");
								
									
								}
								
								
								
								
								
								document.getElementById("selection_slider").disabled = false;
								d3.select("#legend").remove();
									
								density_on = false;
								
								
								d3.select('#density_plot').attr("value", "Density Plot");
								d3.select('#lasso_cancel').style('display', 'none');
								d3.select('#done').style('display', 'none');
							}
							
							else
							{
								
								
								
								d3.select('body')									
									.append('div')											
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')
									.style('top', $(document).scrollTop() + height/2 + 'px')		
									.style('display', 'block')
									.raise();
								
                                
								d3.select('#density_plot').attr("value", "Return to Expression Threshold Selection");
								d3.select('#lasso_cancel').style('display', 'block');
								d3.select('#done').style('display', 'block');
								
								
                                // 201125
                                
                                
                                var dec_num = dec.length;
                                
                                var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                                  + rds_name + "_" + nrow + "_" + n_dims + "_" + dim_id + "_" + dec_num;
                                  
                                  
                                for (var i=0; i<dec_num; i++)
								{
									
                                    density_string = density_string + " " + dec[i];     
								}
                                  
                                 
                                // console.log(density_string);
                                  
                                console.time("density_plot.py time:");	
                                            
                                $.ajax({
                                    async: true,
                                
                                    url: "density_plot.py",
                                    type: 'POST',
                                    
                                    contentTpye: 'application/json',
                                    dataType: 'json',
                                
                                    data: {'fd_ld': density_string},
                                    
                                    success: function(response){
                                        
                                        var endTime2 = new Date().getTime();
                                        
                                        console.timeEnd("density.py time:");
                                        
                                        console.log("density.py finish");
                                        
                                       
                                        // 201125
                                       
                                        
                                        var density_values = response["density"];
                                        
                                        
           
							
										density_indices = new Array();
									
										
										
										for (var j = 0; j < dec_num; ++j) density_indices[j] = j;
										density_indices.sort(function (a, b) { return density_values[a] < density_values[b] ? -1 : density_values[a] > density_values[b] ? 1 : 0; });
									
                                    
                                     
              
										
										var cur_xy_dp = new Array();
                                        
                                        var ori_count = 0;
					
										for (var i=0; i<nrow; i++)
										{
											var cur_index;
                                            
                                            if (i < (nrow-dec_num))
                                            {
                                                var ori_id = dec.indexOf(ori_count);
                                                
                                                while(ori_id != -1)
                                                {
                                                    ori_count++;
                                                    
                                                    ori_id = dec.indexOf(ori_count);
                                                }
                                                
                                                cur_index = dimensions[ori_count];
                                                
                                                ori_count++;
                                                // cur_xy_dp[i] = [0.0, 0.0];
                                            }
                                            
                                            else
                                            {
                                          
                                                cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                                
                                                // cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            }
                                            
                                            cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            
                                            
                                            
                                            // if (i < (nrow-dec_num))
                                            // {
                                                
                                                // cur_xy_dp[i] = [0.0, 0.0];
                                            // }
                                            
                                            // else
                                            // {
                                          
                                                // var cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                                
                                                // cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            // }
										}
										
										
										
                                        
                                        
                                        var density_min = Number.MAX_VALUE;
                                        var density_max = Number.MIN_VALUE;
                                        
                                        for (var i=0; i<dec_num; i++)
                                        {
                                            var cur_density = density_values[i];
                                            
                                            if (cur_density < density_min)
                                                density_min = cur_density;
                                            
                                            if (cur_density > density_max)
                                                density_max = cur_density;
                                        }
                                        
                                        var density_range = (density_max - density_min) / 5;
                                        
                                        // for (var i=0; i<dec_num; i++)
                                        // {
                                            // density_values[i] = (density_values[i]-density_min) / (density_max-density_min);                             
                                        // }
                                        
                                        
                                        // sorted_density_colors = new Array();
										
                                        
                                        
										// for (var j=0; j<nrow; j++)
										// {
											// sorted_density_colors[j] = density_colors[density_indices[j]];
										// }
										
                                        
                                        
                                        
                                        var color_scale = d3.scaleLinear()
                                                            .domain([density_min, density_min+density_range, density_min+2*density_range, density_min+3*density_range, density_min+4*density_range, density_max])
                                                            .range(["#000099", "#00FEFF", "#45FE4F", "#FCFF00", "#FF9400", "#FF3100"]);
                                        
                                        
                                        density_colors = new Array();
                                        
                                        
                                        for (var i=0; i<nrow; i++)
                                        {
                                            if (i < (nrow-dec_num))
                                            {
                                                // density_colors[i] = "#FFFFFF";
                                                density_colors[i] = "#E2E2E2";
                                            }
                                            
                                            else
                                            {
                                  
                                                density_colors[i] = color_scale(density_values[density_indices[i - (nrow-dec_num)]]);
                                            }
                    
                                        }
                                       
                                        
                                        
                                        var cur_circle = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
			
										for (var i=0; i<sorted_dec.length; i++)
										{
											
											
											cur_circle[sorted_dec[i]].setAttribute("class", "");
										
											
										}
                                        
                                        
                                        
										
										d3.select(mep_dots_id)
										.selectAll('circle')
										.data(cur_xy_dp)
										.attr("cx", function(d) {return x_filtering(d[0])})
										.attr("cy", function(d) {return x_filtering(-d[1])})	
										
										

										
										
										d3.select(mep_dots_id)
											.selectAll('circle')
											.data(density_colors)
											.attr("fill", function(d) {
											return d});
															
										
                                        // 201125 legend
                        
                                        mep_svg.append("defs")
                                            .append("linearGradient")
                                            .attr("id", "legend-density")
                                            .attr("x1", "0%").attr("y1", "0%")
                                            .attr("x2", "100%").attr("y2", "0%")
                                            .selectAll("stop") 
                                            .data([
                                                {offset: "0%", color: "#000099"},
                                                {offset: "20%", color: "#00FEFF"},
                                                {offset: "40%", color: "#45FE4F"},
                                                {offset: "60%", color: "#FCFF00"},
                                                {offset: "80%", color: "#FF9400"},
                                                {offset: "100%", color: "#FF3100"}
                                             
                                              ])
                                            .enter().append("stop")
                                            .attr("offset", function(d) { return d.offset; })
                                            .attr("stop-color", function(d) { return d.color; });
                                   
                                     
                                        var cur_legend_bounding = d3.select("#lasso_window"+lasso_gene)["_groups"][0][0].getBoundingClientRect();
                                        
                                        
                                        // var legned_div_w = lasso_window_w;
                                        var legned_div_w = cur_legend_bounding.width;
                                        var legned_div_h = font_size*5;
                                        
                                        var legendWidth = legned_div_w-2;
                                        var legendHeight = font_size;
                                        
                                        
                                        
                                        //Color Legend container
                                        // var legendsvg = mep_svg.append("g")
                                        var legendsvg = d3.select('body')
                                            .append('div')
                                            .attr("id", "legend")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .style('position', 'absolute')
                                            // .style('left', cur_bounding.left + lasso_window_w - legendWidth/2 + 'px')
                                            // .style('left', cur_legend_bounding.left + lasso_window_w/2 - legendWidth/2 + hist_margin.left + 10+ 'px')
                                            // .style('left', cur_legend_bounding.left + (legned_div_w - legendWidth)/2 + 'px')
                                            .style('left', cur_legend_bounding.left + 'px')
                                            .style('top', $(document).scrollTop() + cur_legend_bounding.top - legned_div_h + 'px')
                                            // .style('top', $(document).scrollTop() + cur_legend_bounding.top + cur_legend_bounding.height - legendHeight + 'px')
                                            // .style('padding', '1px 1px 1px 1px')
                                            .style('display', 'block')
                                            .style('background-color', '#e2e2e2')
                                            .raise()
                                            
                                            .append("svg")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .append("g")
                                            .attr("class", "legendWrapper")
                                            .attr("transform", "translate(" + (legned_div_w/2) + "," + legned_div_h/2 + ")");
                                            
                                         
                                        // 201126 
                                        

                                        var tri_size = font_size * 0.7;
                                        
                                        var tri_scale = d3.scaleLinear()
                                            .domain([0, 1])
                                            .range([-legendWidth/2, legendWidth/2]);
                                                
                                        var legend_scale = d3.scaleLinear()
                                             .domain([0, legendWidth])
                                             .range([0, 1]);
                                        
										// 210826_3
										
                                        //Draw the Rectangle
                                        legendsvg
                                            .append("rect")
                                            .attr("class", "legendRect")
                                            .attr("x", -legendWidth/2)
                                            .attr("y", 0) 
                                                    
                                            .attr("width", legendWidth)
                                            .attr("height", font_size)
                                            .style("fill", "url(#legend-density)")
                                            .on("click", function() 
                                            {                  
                                                var dim = this.getBoundingClientRect();
                                                var x = d3.event.pageX - dim.left;
                                                // var y = d3.event.pageY - dim.top;
                                                // console.log("x: "+x);
                                                
                                                density_th = legend_scale(x);
                                                console.log("density_th: " + density_th);
                                                
                                                // d3.select("#triangle").remove();
                                                
                                                
                                                // legendsvg
                                                    // .append("path")  
                                                    // .attr("id", "triangle")
                                                    // .attr("x", tri_scale(density_th))
                                                    // .attr("y", -tri_size)
                                                    // .attr("d", "M " + (-tri_size) + " " + (-tri_size) + " L " + tri_size + " " + (-tri_size) + " L 0 0")
                                                    // .attr("fill", "Black");
                                                
                                                // d3.select("#triangle").attr("x", tri_scale(density_th));
                                                
                                                var cur_offset = tri_scale(density_th);
                                                
                                                d3.select("#triangle")
                                                .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0");
                                                // .attr("d", "M " + (-tri_size) + " " + (-tri_size) + " L " + tri_size + " " + (-tri_size) + " L 0 0");
                                            });
                                            // .style("margin", "0 auto")
                                            
                                        // 201126 path
                                        
                                        // legendsvg
                                            // .append("path")  
                                            // .attr("id", "triangle")
                                            // .attr("x", tri_scale(density_th))
                                            // .attr("y", -font_size)
                                            // .attr("d", "M " + (-font_size) + " " + (-font_size) + " L " + font_size + " " + (-font_size) + " L 0 0")
                                            // .attr("fill", "Black");
                                        
                                        
                                        var cur_offset = tri_scale(density_th);
                                        
                                        legendsvg
                                            .append("path")  
                                            .attr("id", "triangle")
                                            // .attr("x", tri_scale(density_th))
                                            .attr("x", 0)
                                            .attr("y", -tri_size)
                                            .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0")
                                            // .attr("d", "M " + (-tri_size) + " " + (-tri_size) + " L " + tri_size + " " + (-tri_size) + " L 0 0")
                                            .attr("fill", "Black");




                                        //Append title
                                        legendsvg.append("text")
                                            .attr("class", "legendTitle")
                                            .attr("x", 0)
                                            // .attr("y", -font_size*2)
                                            .attr("y", -font_size-tri_size)
                                            .style("text-anchor", "middle")
                                            .style("font-size", font_size*0.8+"px")  
                                            .text("Normalized local density");
                                            
                                        
                                             
                                        
                                        
                                        //210826_2

                                        //Set scale for x-axis
                                        var xScale = d3.scaleLinear()
                                             .range([-legendWidth/2, legendWidth/2])
											 .domain([0.0, 1.0]);
                                             //.domain([density_min, density_max]);
                                        
                                        
                                        
                                        
                                        
                                        //Define x-axis
                                        // var xAxis = d3.svg.axis()
                                              // .orient("bottom")
                                              // .ticks(5)                                      
                                              // .scale(xScale);
                                              
                                        var xAxis = d3.axisBottom(xScale)                                 
                                              .ticks(5);                                
                                 

                                        //Set up X axis
                                        legendsvg.append("g")
                                            .attr("class", "axis")
                                            .attr("transform", "translate(0," + font_size + ")")
                                            .style("font-size", font_size*0.5+"px")  
                                            .call(xAxis);
                                        
                                        
                                        
                                        
                                        
                                        // console.log("density_min: ", density_min);
                                        // console.log("density_max: ", density_max);
                                        // color_scale_test = color_scale;
														
										document.getElementById("selection_slider").disabled = true;

														
										density_on = true;	
										
										
										d3.select(".loader").remove();
                                    }
                                });							
							}
						}
						
						else
						{
							alert("Please select cells first.")
						}
					})
				
				
				
				// 210916_2
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "lasso_cancel")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Lasso Cancel")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						if (final_selected.length > 0)
						{
						
							lasso_temp.classed("selected",false);
						
						
						
							lasso_temp = new Array();
							
							
							
							
							
							
		
						
							
							var cur_lasso_dots = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
								
							for (var j=0; j<selected_density.length; j++)
							{
				
								cur_lasso_dots[selected_density[j]].setAttribute("class", "");
							}
							
							
							selected = new Array();
							
							
							final_selected = new Array();
							
							selected_density = new Array();
							
							
							
							
							var members = lasso_gene.split("_")
							var morg = true;
							
							if (members.length==1)
								morg = true;
							else
								morg = false;
							
							
							

							alert("Cancellation Complete.");
						}
						
						else
						{
							alert("No selection.")
						}
					
					});
				
				
				
				
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "done")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Done")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						
						
						// if ((final_selected.length > 2) && density_on)
                        if (density_on)
						{
						
							d3.select('body')									
								.append('div')											
								.attr('class', 'loader')
								.style('position', 'absolute')
								.style('left', width/2 + 'px')
								.style('top', $(document).scrollTop() + height/2 + 'px')		
								.style('display', 'block')
								.raise();
						

							console.log("The number of final selected cells: " + final_selected.length);
							
			
							
							lasso_temp = new Array();
                            
                            cell_ids[lasso_gene] = new Array();
							
                            if (final_selected.length > 0)
							{
       
                                for (var i=0; i<final_selected.length; i++)
                                {
                                    cell_ids[lasso_gene][i] = final_selected[i];
                                }
                            }
                            else
                            {
                                for (var i=0; i<dec.length; i++)
                                {
                                    cell_ids[lasso_gene][i] = dec[i];
                                }
                            }
                            
                            var cur_cell_ids = cell_ids[lasso_gene];
                            
                            var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                              + rds_name + "_" + nrow + "_" + n_dims + "_" + 1 + "_" + density_th + "_" + cur_cell_ids.length;
                              
                          
                            
                            for (var i=0; i<cur_cell_ids.length; i++)
                            {
                                density_string = density_string + " " + cur_cell_ids[i];
                            }
                                
                            
               
                            console.time("density.py time:");	
                                        
                            $.ajax({
                                async: true,
                            
                                url: "density.py",
                                type: 'POST',
                                
                                contentTpye: 'application/json',
                                dataType: 'json',
                            
                                data: {'fd_ld': density_string},
                                
                                success: function(response){
                                    
                                    var endTime2 = new Date().getTime();
                                    
                                    console.timeEnd("density.py time:");
                                    
                                    console.log("density.py finish");
                                          
                                    var filtered_ids_result = response["filtered_ids"];
                                       

                                        
                                    filtered_ids[lasso_gene] = new Array();
                                    
                                    
                                    
                                    for (var j=0; j<n_dims; j++)
                                    {                                                                                     
                                        filtered_ids[lasso_gene][j] = new Array();
                                        
                                        var fc = 0;
                                        
                                        for (var k=0; k<nrow; k++)
                                        {
                                            var cur_id = filtered_ids_result[j*nrow + k];
                                            
                                            if (cur_id != -1)  
                                            {
                                                filtered_ids[lasso_gene][j][fc] = cur_id;
                                                
                                                fc++;
                                            }
                                        }
                                    }
                                    
                                    
                                    
                                    selected = new Array();
									final_selected = new Array();
									selected_density = new Array();
											
									
									
									
							
									hulls[lasso_gene] = new Array();
									lines[lasso_gene] = new Array();
									areas[lasso_gene] = new Array();
									
								
									
									var cur_areas = new Array();
									
									var smallest_area = Number.MAX_VALUE;
									var largest_area = Number.MIN_VALUE;
									
                                    
                                    var cur_marker_ids = filtered_ids[lasso_gene];
                                    
									for (var j=0; j<n_dims; j++)
									{						
										
										var cur_cells = cur_marker_ids[j];
				
										
										var cur_len = cur_cells.length;
										
						
										if (cur_len > 2)
										{
				
											
			
											var points = new Array();
																
											for (var k=0; k<cur_len; k++)
											{
												var cur_id_dim = dimensions[cur_cells[k]];
												
												points[k] = [Number(cur_id_dim[1 + 2*j]), Number(cur_id_dim[1 + 2*j +1])];
											} 
											
											
											var cur_hull = d3.polygonHull(points);
											
											hulls[lasso_gene][j] = cur_hull;
											
											var scaled_hull = new Array();
												
											for (var k=0; k<cur_hull.length; k++)
											{
												scaled_hull[k] = [x2(cur_hull[k][0]), x2(-cur_hull[k][1])];
											}
											
																	
											lines[lasso_gene][j] = line(scaled_hull);
											
											var cur_area = -d3.polygonArea(scaled_hull);
											
									
															
											cur_areas[j] = cur_area;
											
										
																								
											if (cur_area > largest_area)
											{
												largest_area = cur_area;										
											}
											
										
																												
											if (cur_area < smallest_area)
											{
												smallest_area = cur_area;
												smallest_dim[lasso_gene] = j;
											}
										}
										
										else
										{
											cur_areas[j] = 0;
											
											
											lines[lasso_gene][j] = 0;
										}
										
										
									}
									
									
									
									
									
									if (largest_area > 0)
									{
										for (var j=0; j<n_dims; j++)
										{									
											areas[lasso_gene][j] = (cur_areas[j]-smallest_area) / (largest_area-smallest_area);
										
										}
									}	
									
									else
									{
										for (var j=0; j<n_dims; j++)
										{									
											areas[lasso_gene][j] = 0;
										
										}
									}
										
										
									
									
									
									
									
									if (lasso_gene in deg_others)
									{
										delete deg_others[lasso_gene];
									}
									
									
									if (markers_ani.indexOf(lasso_gene)!=-1)
									{
										new_marker_ani = lasso_gene;
										cur_marker_ani = lasso_gene;
										
										calculate_animation();
										
										console.log("ani again");
										
									}
									
									
					
									
									
									ccm = new Array();
									
									ccm[0] = lasso_gene;
									
									draw_markers_plots();
									
									
							

									
									
									all_genes_done();
									
								
								
								
									d3.select("#legend").remove();
                                    
									d3.select('#lasso_window' + lasso_gene).remove();
									
									
									
									
									lasso_gene = "";
									
									
									filtering_on = false;
									density_on = false;
									
									d3.select("#plot_size_slider").style('display', 'block');
									d3.select("#stop_plot_size_change").style('display', 'none');
                                }
                            });
                            

						}
						
						else
						{
							alert("Please click this button after performing Lasso Selection on Density Plot.")
						}
					});
				
				
				
				
				
				
				
				
				// 210826_4		
				
				
				
				
				
				var slider_margin_left = (hist_margin.left + d3.select("#histogram_svg")._groups[0][0].getBoundingClientRect().x - d3.select("#histogram")._groups[0][0].getBoundingClientRect().x) + "px";
                d3.select('#silderid')
				.style("margin-left", slider_margin_left)	
                
                console.log("end slider margin left: " + slider_margin_left);
					

			}
			
			else
			{
				
				
				
				histo_ex = new Object;								
				bins = new Object;
				bins_ids = new Object;
				bins_range = new Object;
				hist_th = new Object;

				histo_ex_max = new Object;
				decs = new Object;
				sorted_decs = new Object;
				
				
				
				
				var slider_height = Number(d3.select('#slider')["_groups"][0][0].style.height.replace("px", ""));
					
				
				var lasso_window_w = filtering_size + hist_margin.left + hist_margin.right;
				var lasso_window_h = filtering_size + filtering_size/2 + hist_margin.top + hist_margin.bottom + slider_height + 50;
				
				
				
				
				for (var k=0; k<members.length; k++)
				{
					
					var cur_member = members[k];
					var cur_id = "#" + cur_member;
					
					
					
					decs[cur_member] = new Array();
					sorted_decs[cur_member] = new Array();
					
					var cur_bounding = d3.select(cur_id)["_groups"][0][0].getBoundingClientRect();
					
					
					
					
					
					
					
					
					histo_ex[cur_member] = new Array();
					
					
					
					var cur_histo_ex = histo_ex[cur_member];
					
					histo_ex_max[cur_member] = ex_maxs[cur_member];
				
					var cur_gene = expressions[cur_member];
					
					for (var i=0; i<nrow; i++)
					{
						
						var cur_ex = Number(cur_gene[i+1]);
						
						cur_histo_ex[cur_histo_ex.length] = cur_ex;		
					}
					
					var histGenerator = d3.histogram()
					.domain([0, histo_ex_max[cur_member]])
					.thresholds(num_bins);
					
					bins[cur_member] = histGenerator(cur_histo_ex);
					
					
					
					
					bins_ids[cur_member] = new Array();
					
					for (var i=0; i<bins[cur_member].length; i++)
					{
						bins_ids[cur_member][i] = new Array();
					}
					
					bins_range[cur_member] = bins[cur_member][0].x1 - bins[cur_member][0].x0;
				
					
					for (var i=0; i<nrow; i++)
					{
						var bin_id = Math.floor(histo_ex[cur_member][i] / bins_range[cur_member]);
						
						var cur_bin = bins_ids[cur_member][bin_id];
						
				
						cur_bin[cur_bin.length] = i;
						
					}
					
					//////////////////////////////////////////////////////////////////////////
					
					
					var cur_left = cur_bounding.left - ((lasso_window_w - cur_bounding.width) / 2);
					
					
					
					d3.select('body')
					.append('div')

					.attr("id", "lasso_window" + cur_member)
					.style('width', lasso_window_w)
					.style('height', lasso_window_h)
					.style('position', 'absolute')
	
				
					.style('left', cur_left + 'px')
					.style('top', $(document).scrollTop() + cur_bounding.top + cur_bounding.height + 'px')
					.style('padding', '10px 10px 10px 10px')
					.style('display', 'block')
					.style('background-color', '#e2e2e2')
					.raise();
					

						
				
					

					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr('class', 'row')
						.attr("id", "mep"+cur_member)
						.style('padding-left', '10px')
						.style('padding-right', '20px');
						
					var cur_mep_name = "#mep" + cur_member;
					
					
					var mep_svg = d3.select(cur_mep_name)
					.append("svg")		
					.attr("id", "mep_svg" + cur_member)
					.attr("width", filtering_size)
					.attr("height", filtering_size)
					.style("background-color", "white")
					.style("margin", "0 auto")


			
					

					mep_svg.append("text")
					.attr("x", (filtering_size / 2)) 
					.attr("y", legend_size/2+10)
					.attr("text-anchor", "middle")  					 
					.style("font-size", font_size_str)  
					.text(cur_member)
					
					
					
					
					
					var cur_xy = new Array();
							
					var cur_indices = sorted_indices[cur_member];
					
					
					
					
					for (var j=0; j<nrow; j++)
					{
						var cur_index = dimensions[cur_indices[j]];
						
						cur_xy[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
					}
					
					

				
					
					var mep_dots = mep_svg.append('g')
					.attr("id", "mep_dots" + cur_member)
					
					var mep_dots_data = mep_dots.selectAll()								
					.data(cur_xy).enter()
					.append("circle")
					.attr("id", function(d, i) {return i;})
					.attr("cx", function(d) {return x_filtering(d[0])})
					.attr("cy", function(d) {return x_filtering(-d[1])})			
					.attr("r", ep_cell_size)
					
				
				
					mep_dots_data.data(ex_colors[cur_member])
					.attr("fill", function(d) {
					return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
					
					
					
					
					
					
					var mep_dots_id = "#mep_dots" + cur_member;
				
				
					
					
					
					
					
					
					//////////////////////////////////////////////////////////////////
					
						
					var histogram_w = filtering_size + hist_margin.left + hist_margin.right;
					var histogram_h = filtering_size/2 + hist_margin.top + hist_margin.bottom;
						
		
					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr("class", "row")
						.attr("id", "histogram" + cur_member)
						.style('width',  histogram_w)
						.style('height', histogram_h)	

						.style('padding-left', '10px')
						.style('padding-right', '20px')
						.style('display', 'block')
						.raise();
					
					
					var cur_his_name = "#histogram" + cur_member;
					
					var svg_hist = d3.select(cur_his_name)
						.append("svg")
							.attr("width", filtering_size + hist_margin.left + hist_margin.right)
							.attr("height", filtering_size/2 + hist_margin.top + hist_margin.bottom)
						.append("g")
							.attr("transform",
								"translate(" + hist_margin.left + "," + hist_margin.top + ")");
								
					var hist_x = d3.scaleLinear()
						.domain([0, histo_ex_max[cur_member]])
						.range([0, filtering_size]);
						
					hist_x_test = hist_x;
					
					svg_hist.append("g")
						.attr("transform", "translate(0," + filtering_size/2 + ")")
						.call(d3.axisBottom(hist_x));
						
					var hist_y = d3.scaleLinear()
						.range([filtering_size/2, 0]);
						
					hist_y.domain([0, d3.max(bins[cur_member], function(d) {return d.length;})]);
					
					svg_hist.append("g")
						.attr("id", "hist_y")
						.call(d3.axisLeft(hist_y));
					
					
					svg_hist.selectAll("rect")
						.data(bins[cur_member])
						.enter()
						.append("rect")
							.attr("x", 1)
							.attr("transform", function(d) { return "translate(" + hist_x(d.x0) + "," + hist_y(d.length) + ")"; })
							.attr("width", function(d) { return hist_x(d.x1) - hist_x(d.x0) -1 ; })
							.attr("height", function(d) { return filtering_size/2 - hist_y(d.length); })
							.style("fill", "#69b3a2")
			
					
					hist_th[cur_member] = histo_ex_max[cur_member];
					
					svg_hist.append("rect")
						.attr("id", "selection" + cur_member)
						.attr("transform", "translate(" + hist_x(hist_th[cur_member]) + ",0)")
						.attr("width", hist_x(histo_ex_max[cur_member] - hist_th[cur_member]))
						.attr("height", filtering_size/2)
						.style("fill", "rgba(0, 0, 255, 0.3)");
						
					var slider_padding = hist_margin.left + 10 + "px 10px 10px 10px";
						

					d3.select('#lasso_window' + cur_member)
						.append('div')
						.attr("class", "row")
						.attr("id", "selection_slider" + cur_member)
			
						.style('width',  histogram_w)
						.style('height', slider_height)
						
						.style('padding-left', '10px')
						.style('padding-right', '20px')
						.style('padding-bottom', '10px')
						.style('display', 'block')									
						.raise();
					
					
			
					var slider_left = hist_margin.left  + "px";

					var slider_width = filtering_size*(bins[cur_member].length/(bins[cur_member].length-1)) + "px";
					
					
					var cur_slider_name = "#selection_slider" + cur_member;
					
					
					
					var cur_selection = "#selection" + cur_member;
					
					
					
					d3.select(cur_slider_name)
		
						.append("input")
						.attr("id", "slider" + cur_member)
	
						.attr("type", "range")
						
						.attr("value", histo_ex_max[cur_member])
						.attr("min", 0)
						.attr("max", histo_ex_max[cur_member])
	
						.attr("step", bins[cur_member][0].x1 - bins[cur_member][0].x0)
			
						.style("position", "absolute")
			
						.style("left", slider_left)

						.style("width", slider_width)
				
						.style("margin-bottom", "30px")
		
						.on("change", function() { 
							
							if (!density_on)
							{
							
							
								var gene = this.id.replace("slider", "");
								
								
								var cur_mep_id = "#mep_dots" + gene;
								
								
								
								
								
								var cur_dots = d3.select(cur_mep_id).selectAll('circle')["_groups"][0];
								
								
								for (var i=0; i<sorted_decs[gene].length; i++)
								{
									
									cur_dots[sorted_decs[gene][i]].setAttribute("class", "");
								}
								
								
								decs[gene] = new Array();
								sorted_decs[gene] = new Array();
								
								
			

							
								hist_th[gene] = this.value;										
								var th_id = hist_th[gene] / bins_range[gene];
								
								
								
								var cur_reverse = reverse_sorted_indices[gene];
								
								for (var i=0; i<bins_ids[gene].length; i++)
								{
									if (i >= th_id)
									{
			
										var cur_bin = bins_ids[gene][i];
			
										for (var j=0; j<cur_bin.length; j++)
										{
											
											var cur_id = cur_bin[j];
											
											decs[gene][decs[gene].length] = cur_id;
											
											
											var sorted_id = cur_reverse[cur_id];
											
											
											cur_dots[sorted_id].setAttribute("class", "selected");
											
											sorted_decs[gene][sorted_decs[gene].length] = sorted_id;
											
										}
									}						
								}
								
								
								var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									cur_lasso_dots[sorted_dec[i]].setAttribute("class", "");
								}
								
								
								dec = new Array();
								sorted_dec = new Array();
								
								var first_gene = members[0];
								var first_dec = decs[first_gene];
								
								
								for (var i=0; i<first_dec.length; i++)
								{
									dec[i] = first_dec[i];
								}
								
								
								for (var i=1; i<members.length; i++)
								{
									var next_gene = members[i];
									var next_dec = decs[next_gene];
									
									
									
									
									dec = intersect(dec, next_dec);
									
								}
								
								
								
								if (hulls[lasso_gene].length > 0)
								{
								
								
									var lasso_reverse = reverse_sorted_indices[lasso_gene];
									
									
									for (var i=0; i<dec.length; i++)
									{
										var cur_id = lasso_reverse[dec[i]];
										
										sorted_dec[i] = cur_id;
										
										
										
										cur_lasso_dots[cur_id].setAttribute("class", "selected");
									}
								}
								
								else
								{
									for (var i=0; i<dec.length; i++)
									{
										var cur_id = dec[i];
										
										sorted_dec[i] = cur_id;
										
										cur_lasso_dots[cur_id].setAttribute("class", "selected");
										
									}
								}
								

								
								var cur_hist_x = d3.scaleLinear()
									.domain([0, histo_ex_max[gene]])
									.range([0, filtering_size]);

								
								d3.select("#selection" + gene)
									.attr("transform", "translate(" + cur_hist_x(hist_th[gene]) + ",0)")
									.attr("width", cur_hist_x(histo_ex_max[gene] - hist_th[gene]));

								
							}
						});
					
				}
				
				
				
				/////////////////////////////////////////////////////////////////////
					
				
				var lasso_bounding = d3.select(lasso_gene_id)["_groups"][0][0].getBoundingClientRect();
				
				d3.select('body')
					.append('div')

					.attr("id", "inputs_window")
					
					.style('width', ep_size + "px")
					
					.style('position', 'absolute')
					.style("margin", "0 auto")
					
					
	
				
					.style('left', lasso_bounding.left + 'px')
					.style('top', $(document).scrollTop() + lasso_bounding.top + lasso_bounding.height + 'px')
					
					.style('display', 'block')
					.style('background-color', '#e2e2e2')
					.raise()
					.append('div')
					.attr("id", "set_center")
					.append('ol')
				
					//.attr("class", "col-xl-12")
					.attr("id", "inputs")
					
					.style('position', 'absolute')
					.style("margin", "0 auto")
				// 210916

				d3.select('#inputs')
				
					.append("input")
					.attr("id", "density_plot")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Density Plot")
					.style("margin", "0 auto")
					.on("click", function() {
						
						if (dec.length > 2)
						{
						
							if (density_on)
							{
					
								
								
								if (final_selected.length > 0)
								{
								
									lasso_temp = new Array();
									
									var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
									for (var j=0; j<selected_density.length; j++)
									{
						
										cur_lasso_dots[selected_density[j]].setAttribute("class", "");
									}
									
									
									selected = new Array();
									
									final_selected = new Array();
									
									selected_density = new Array();

								}
								
								
								
								
								var cur_xy_dp = new Array();
							
								var cur_indices_dp = sorted_indices[lasso_gene];
								
								
								
								
								
								for (var j=0; j<nrow; j++)
								{
									var cur_index = dimensions[cur_indices_dp[j]];
									
									cur_xy_dp[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
								}
								
								
								
								

								
								d3.select(lasso_gene_id).select("#mep_dots")
								.selectAll('circle')
								.data(cur_xy_dp)
								.attr("cx", function(d) {return x2(d[0])})
								.attr("cy", function(d) {return x2(-d[1])})
								
						
							
								
								
								d3.select(lasso_gene_id).select("#mep_dots")
									.selectAll('circle')
									.data(ex_colors[lasso_gene])
									.attr("fill", function(d) {
									return "rgb("+d[0]+","+d[1]+","+d[2]+")"})
								
					
								

								var cur_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
								for (var i=0; i<sorted_dec.length; i++)
								{
									
									
									cur_dots[sorted_dec[i]].setAttribute("class", "selected");
								
									
								}
						
								
								d3.select("#legend").remove();
								
								for (var i=0; i<members.length; i++)
									document.getElementById("selection_slider" + members[i]).disabled = false;
								
									
								density_on = false;
								
								d3.select('#density_plot').attr("value", "Density Plot");
								d3.select('#lasso_cancel').style('display', 'none');
								d3.select('#done').style('display', 'none');
							}
							
							else
							{
								
								
								
								d3.select('body')									
									.append('div')											
									.attr('class', 'loader')
									.style('position', 'absolute')
									.style('left', width/2 + 'px')
									.style('top', $(document).scrollTop() + height/2 + 'px')		
									.style('display', 'block')
									.raise()
								
								d3.select('#density_plot').attr("value", "Return to Expression Threshold Selection");
								d3.select('#lasso_cancel').style('display', 'block')
								d3.select('#done').style('display', 'block')
								
								
								// 201125 density_plot group
                                
                                var dec_num = dec.length;
                                
                                var density_string = document.getElementById("fd").value + "_" + document.getElementById("ld").value + "_" 
                                  + rds_name + "_" + nrow + "_" + n_dims + "_" + dim_id + "_" + dec_num;
                                  
                                  
                                for (var i=0; i<dec_num; i++)
								{
									
                                    density_string = density_string + " " + dec[i];     
								}
                                  
                                 
                                // console.log(density_string);
                                  
                                console.time("density_plot.py time:");	
                                            
                                $.ajax({
                                    async: true,
                                
                                    url: "density_plot.py",
                                    type: 'POST',
                                    
                                    contentTpye: 'application/json',
                                    dataType: 'json',
                                
                                    data: {'fd_ld': density_string},
                                    
                                    success: function(response){
                                        
                                        var endTime2 = new Date().getTime();
                                        
                                        console.timeEnd("density.py time:");
                                        
                                        console.log("density.py finish");
                                        
                                 
                                       
                                        
                                        var density_values = response["density"];
                                        
                                        
           
							
										density_indices = new Array();
									
										
										
										for (var j = 0; j < dec_num; ++j) density_indices[j] = j;
										density_indices.sort(function (a, b) { return density_values[a] < density_values[b] ? -1 : density_values[a] > density_values[b] ? 1 : 0; });
									
              
										
										var cur_xy_dp = new Array();
					
										var ori_count = 0;
					
										for (var i=0; i<nrow; i++)
										{
											var cur_index;
                                            
                                            if (i < (nrow-dec_num))
                                            {
                                                var ori_id = dec.indexOf(ori_count);
                                                
                                                while(ori_id != -1)
                                                {
                                                    ori_count++;
                                                    
                                                    ori_id = dec.indexOf(ori_count);
                                                }
                                                
                                                cur_index = dimensions[ori_count];
                                                
                                                ori_count++;
                                                // cur_xy_dp[i] = [0.0, 0.0];
                                            }
                                            
                                            else
                                            {
                                          
                                                cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                                
                                                // cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            }
                                            
                                            cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            
                                            
                                            
                                            // if (i < (nrow-dec_num))
                                            // {
                                                
                                                // cur_xy_dp[i] = [0.0, 0.0];
                                            // }
                                            
                                            // else
                                            // {
                                          
                                                // var cur_index = dimensions[dec[density_indices[i - (nrow-dec_num)]]];
                                                
                                                // cur_xy_dp[i] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
                                            // }
										}
										
										
										
                                        
                                        
                                        var density_min = Number.MAX_VALUE;
                                        var density_max = Number.MIN_VALUE;
                                        
                                        for (var i=0; i<dec_num; i++)
                                        {
                                            var cur_density = density_values[i];
                                            
                                            if (cur_density < density_min)
                                                density_min = cur_density;
                                            
                                            if (cur_density > density_max)
                                                density_max = cur_density;
                                        }
                                        
                                        var density_range = (density_max - density_min) / 5;
                                        
                                     
                                        
                               
                                        var color_scale = d3.scaleLinear()
                                                            .domain([density_min, density_min+density_range, density_min+2*density_range, density_min+3*density_range, density_min+4*density_range, density_min+5*density_range])
                                                            .range(["#000099", "#00FEFF", "#45FE4F", "#FCFF00", "#FF9400", "#FF3100"]);
                                        
                                        
                                        density_colors = new Array();
                                        
                                        
                                        for (var i=0; i<nrow; i++)
                                        {
                                            if (i < (nrow-dec_num))
                                            {
                                                 // density_colors[i] = "#FFFFFF";
                                                density_colors[i] = "#E2E2E2";
                                            }
                                            
                                            else
                                            {
                                  
                                                density_colors[i] = color_scale(density_values[density_indices[i - (nrow-dec_num)]]);
                                            }
                    
                                        }
                                       
                                        
                                        
                                        // var cur_circle = d3.select(mep_dots_id).selectAll('circle')["_groups"][0];
                                        var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
			
										for (var i=0; i<sorted_dec.length; i++)
										{
											
											
											cur_circle[sorted_dec[i]].setAttribute("class", "");
										
											
										}
                                        
                                        
                                        
										
										// d3.select(mep_dots_id)
										// .selectAll('circle')
										// .data(cur_xy_dp)
										// .attr("cx", function(d) {return x_filtering(d[0])})
										// .attr("cy", function(d) {return x_filtering(-d[1])})	
										
										

										
										
										// d3.select(mep_dots_id)
											// .selectAll('circle')
											// .data(density_colors)
											// .attr("fill", function(d) {
											// return d});
															
										
															
														
										// document.getElementById("selection_slider").disabled = true;
                                        
                                        d3.select(lasso_gene_id).select("#mep_dots")
										.selectAll('circle')
										.data(cur_xy_dp)
										.attr("cx", function(d) {return x2(d[0])})
										.attr("cy", function(d) {return x2(-d[1])})	
                                        
                                        d3.select(lasso_gene_id).select("#mep_dots")
                                        .selectAll('circle')
                                        .data(density_colors)
                                        .attr("fill", function(d) {
                                        return d});
                                        
                                        
                                        
                                        
                     
                                        d3.select("#"+lasso_gene).append("defs")
                                            .append("linearGradient")
                                            .attr("id", "legend-density")
                                            .attr("x1", "0%").attr("y1", "0%")
                                            .attr("x2", "100%").attr("y2", "0%")
                                            .selectAll("stop") 
                                            .data([
                                                {offset: "0%", color: "#000099"},
                                                {offset: "20%", color: "#00FEFF"},
                                                {offset: "40%", color: "#45FE4F"},
                                                {offset: "60%", color: "#FCFF00"},
                                                {offset: "80%", color: "#FF9400"},
                                                {offset: "100%", color: "#FF3100"}
                                             
                                              ])
                                            .enter().append("stop")
                                            .attr("offset", function(d) { return d.offset; })
                                            .attr("stop-color", function(d) { return d.color; });
                                   
                                   
                                        var legned_div_w = ep_size;
                                        var legned_div_h = font_size*5;
                                        
                                        var legendWidth = legned_div_w - 2;
                                        var legendHeight = font_size;

                                        var cur_legend_bounding = d3.select("#"+lasso_gene)["_groups"][0][0].getBoundingClientRect();
                                        
                                        //Color Legend container
                                        // var legendsvg = mep_svg.append("g")
                                        var legendsvg = d3.select('body')
                                            .append('div')
                                            .attr("id", "legend")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .style('position', 'absolute')
                                            // .style('left', cur_bounding.left + lasso_window_w - legendWidth/2 + 'px')
                                            // .style('left', cur_legend_bounding.left + lasso_window_w/2 - legendWidth/2 + hist_margin.left + 10+ 'px')
                                            // .style('left', cur_legend_bounding.left + (legned_div_w - legendWidth)/2 + 'px')
                                            .style('left', cur_legend_bounding.left + 'px')
                                            .style('top', $(document).scrollTop() + cur_legend_bounding.top - legned_div_h + 'px')
                                            // .style('top', $(document).scrollTop() + cur_legend_bounding.top - legendHeight + 'px')
                                            // .style('top', $(document).scrollTop() + cur_legend_bounding.top + cur_legend_bounding.height - legendHeight + 'px')
                                            // .style('padding', '1px 1px 1px 1px')
                                            .style('display', 'block')
                                            .style('background-color', '#e2e2e2')
                                            .raise()
                                            
                                            .append("svg")
                                            .style('width', legned_div_w )
                                            .style('height', legned_div_h)
                                            .append("g")
                                            .attr("class", "legendWrapper")
                                            .attr("transform", "translate(" + legned_div_w/2 + "," + legned_div_h/2 + ")");
                                            
                                         
                                        // 201126 
                                         
                                        
                                        var tri_size = font_size * 0.7;
                                        
                                        var tri_scale = d3.scaleLinear()
                                            .domain([0, 1])
                                            .range([-legendWidth/2, legendWidth/2]);
                                        
                                        
                                        var legend_scale = d3.scaleLinear()
                                             .domain([0, legendWidth])
                                             .range([0, 1]);
                                        
                                        //Draw the Rectangle
                                        legendsvg
                                            .append("rect")
                                            .attr("class", "legendRect")
                                            .attr("x", -legendWidth/2)
                                            .attr("y", 0) 
                                                    
                                            .attr("width", legendWidth)
                                            .attr("height", font_size)
                                            .style("fill", "url(#legend-density)")
                                            .on("click", function() 
                                            {                  
                                                var dim = this.getBoundingClientRect();
                                                var x = d3.event.pageX - dim.left;
                                                // var y = d3.event.pageY - dim.top;
                                                // console.log("x: "+x);
                                                
                                                density_th = legend_scale(x);
                                                console.log("density_th: " + density_th);
                                                
                                                
                                                var cur_offset = tri_scale(density_th);
                                                
                                                d3.select("#triangle")
                                                .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0");
                                              
                                            });
                                            // .style("margin", "0 auto")
                                            
                                            
                                        var cur_offset = tri_scale(density_th);
                                        
                                        legendsvg
                                            .append("path")  
                                            .attr("id", "triangle")
                                            // .attr("x", tri_scale(density_th))
                                            .attr("x", 0)
                                            .attr("y", -tri_size)
                                            .attr("d", "M " + (-tri_size+cur_offset) + " " + (-tri_size) + " L " + (tri_size+cur_offset) + " " + (-tri_size) + " L " + cur_offset + " 0")
                                            // .attr("d", "M " + (-tri_size) + " " + (-tri_size) + " L " + tri_size + " " + (-tri_size) + " L 0 0")
                                            .attr("fill", "Black");

    
                                            
                                            
                                        //Append title
                                        legendsvg.append("text")
                                            .attr("class", "legendTitle")
                                            .attr("x", 0)
                                            // .attr("y", -font_size*2)
                                            .attr("y", -font_size-tri_size)
                                            .style("text-anchor", "middle")
                                            .style("font-size", font_size*0.8+"px")  
                                            .text("Normalized local density");

                                        //Set scale for x-axis
                                        var xScale = d3.scaleLinear()
                                             .range([-legendWidth/2, legendWidth/2])
											 .domain([0.0, 1.0]);
                                             //.domain([density_min, density_max]);

                                        //Define x-axis
                                        // var xAxis = d3.svg.axis()
                                              // .orient("bottom")
                                              // .ticks(5)                                      
                                              // .scale(xScale);
                                              
                                        var xAxis = d3.axisBottom(xScale)                                 
                                              .ticks(5);                                      
                                 

                                        //Set up X axis
                                        legendsvg.append("g")
                                            .attr("class", "axis")
                                            .attr("transform", "translate(0," + font_size + ")")
                                            .style("font-size", font_size*0.5+"px")  
                                            .call(xAxis);
                                        
                                       
                                        
                	
                                        
                                        for (var i=0; i<members.length; i++)
											document.getElementById("selection_slider" + members[i]).disabled = true;

														
										density_on = true;	
										
										
										d3.select(".loader").remove();
                                    }
                                });
								
                                
                                
                                
                                
                                
                                
                                // var dec_string = document.getElementById("fd").value + "," + document.getElementById("ld").value + "," + 
								// rds_name + "," + dim_id + ",";
								
								
								// for (var i=0; i<dec.length; i++)
								// {
							
									// var cur_dec = dec[i]+1;
									
									// if (i==(dec.length-1))
									// {
									
										// dec_string = dec_string + cur_dec;
									// }
									
									// else
									// {
										
										// dec_string = dec_string + cur_dec + "_";
									// }
			
								// }
								
								
								
			
								// console.log("density.r start")
		
								// console.time("density.r time: ");	
								
								

											
								// $.ajax({
								
									// async: true,
							
									// url: "../rscripts/density.r",
									// type: 'POST',
									
									// contentTpye: 'application/json',
								
									// data: dec_string,
									
									// success: function(response){
										
								
										
							
										// console.timeEnd("density.r time:");
										

										// console.log("density.r finish");
									
										
										// var cur_circle = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
										
										// for (var i=0; i<sorted_dec.length; i++)
										// {
											
											
											// cur_circle[sorted_dec[i]].setAttribute("class", "");
										
											
										// }
			
			
										
										// var density_results = response.split(",");
										
										
										// var density_results_colors = density_results[0].split(" ");
										

										// var density_results_values = density_results[1].split(" ");
										
										
										// density_colors = new Array();
										
										// density_values = new Array();
										
										
										
										
										// for (var i=0; i<nrow; i++)
										// {
											// var di = dec.indexOf(i);
											
											// if (di==-1)
											// {
												// density_colors[i] = "rgba(0, 0, 0, 0)";
												// density_values[i] = 0;
											// }
											
											// else
											// {
												// density_colors[i] = density_results_colors[di];
												// density_values[i] = Number(density_results_values[di]);
											// }
										// }
										
										
										
			
										// density_indices = new Array();
									
										
										
										// for (var j = 0; j < nrow; ++j) density_indices[j] = j;
										// density_indices.sort(function (a, b) { return density_values[a] < density_values[b] ? -1 : density_values[a] > density_values[b] ? 1 : 0; });
									
									
										
							
										// var cur_xy_dp = new Array();
							
										
										
										// for (var j=0; j<nrow; j++)
										// {
											// var cur_index = dimensions[density_indices[j]];
											
											// cur_xy_dp[j] = [Number(cur_index[1+2*dim_id]), Number(cur_index[1+2*dim_id+1])];
										// }
										
										
										// sorted_density_colors = new Array();
										
										// for (var j=0; j<nrow; j++)
										// {
											// sorted_density_colors[j] = density_colors[density_indices[j]];
										// }
										

										
										// d3.select(lasso_gene_id).select("#mep_dots")
										// .selectAll('circle')
										// .data(cur_xy_dp)
										// .attr("cx", function(d) {return x2(d[0])})
										// .attr("cy", function(d) {return x2(-d[1])})	
										
										

										
										
										// d3.select(lasso_gene_id).select("#mep_dots")
											// .selectAll('circle')
											// .data(sorted_density_colors)
											// .attr("fill", function(d) {
											// return d});
										
										
														
										// for (var i=0; i<members.length; i++)
											// document.getElementById("selection_slider" + members[i]).disabled = true;

														
										// density_on = true;	
										
										// d3.select(".loader").remove();
										
								
									// }
								// });
								
							}
						}
						
						else
						{
							alert("Please select cells first.");
						}
					})
				
				// 210916_2
				
				d3.select('#inputs')
					
					.append("input")
					.attr("id", "lasso_cancel")
					.attr("class", "texts")
					.attr("type", "button")
					.attr("value", "Lasso Cancel")
					.style('display', 'none')
					.style("margin", "0 auto")
					.on("click", function() {
						if (final_selected.length > 0)
						{
						
							lasso_temp.classed("selected",false);
						
						
						
							lasso_temp = new Array();
							
							
							
							
							
							
						
							
							var cur_lasso_dots = d3.select(lasso_gene_id).select("#mep_dots").selectAll('circle')["_groups"][0];
								
							for (var j=0; j<selected_density.length; j++)
							{
				
								cur_lasso_dots[selected_density[j]].setAttribute("class", "");
							}
							
							
							selected = new Array();
							
							final_selected = new Array();
							
							selected_density = new Array();
		

							alert("Cancellation Complete.");
						}
						
						else
						{
							alert("No selection.")
						}
					
					});
				
				
				
					
				d3.select('#inputs')
				.append("input")
				.attr("id", "done")
				.attr("class", "texts")
				.attr("type", "button")
				.attr("value", "Done")
				.style('display', 'none')
				.style("margin", "0 auto")
				.on("click", function() {
					
					

					// if ((final_selected.length > 2) && density_on)
                    if (density_on)
					{
					
						d3.select('body')									
							.append('div')											
							.attr('class', 'loader')
							.style('position', 'absolute')
							.style('left', width/2 + 'px')
							.style('top', $(document).scrollTop() + height/2 + 'px')		
							.style('display', 'block')
							.raise();
					
					
                        console.log("The number of final selected cells: " + final_selected.length);
							
			
							
                        lasso_temp = new Array();
                        
                        cell_ids[lasso_gene] = new Array();
					
						if (final_selected.length > 0)
                        {

                            for (var i=0; i<final_selected.length; i++)
                            {
                                cell_ids[lasso_gene][i] = final_selected[i];
                            }
                        }
                        
                        else
                        {
                            for (var i=0; i<dec.length; i++)
                            {
                                cell_ids[lasso_gene][i] = dec[i];
                            }
                        }
						
						intersect_tf = false;
                        
                        new_groups[0] = lasso_gene;
                        
                        
                        d3.select("#legend").remove();
						
						calculate_groups();
						
                        
                        
                        
                        
		
					}
					
					else
					{
						alert("Please click this button after performing Lasso Selection on Density Plot.");
					}
					
				});
			}	
		}		
		
		
		

		function all_genes_done ()
		{

			var total = new Array();
			for (var i=0; i<n_dims; i++)
			{
				total[i] = 0;
			}
			
			
			
			
			if (cur_groups.length > 0)
			{
				for (var i=0; i<cur_groups.length; i++)
				{
					for (var j=0; j<n_dims; j++)
					{
						
						
						total[j] += areas[cur_groups[i]][j];
					}
				}
			}
			
			
			if (total_markers.length > 0)
			{
				for (var i=0; i<total_markers.length; i++)
				{
					for (var j=0; j<n_dims; j++)
					{
									
						total[j] += areas[total_markers[i]][j];
					}
				}
			}
			
			
			
			
			
			var total_size = cur_groups.length + total_markers.length;
			
			if (total_size != 0)
			{
				for (var i=0; i<n_dims; i++)
				{
					total[i] /= total_size;
				}
			}
			
			var smallest_area = Number.MAX_VALUE;
			
			for (var i=0; i<n_dims; i++)
			{
				if (total[i] < smallest_area)
				{
					smallest_area = total[i];
					smallest_dim["Total"] = i;
				}
				
				
			}
			
			
			
			
			
			heatmap_data = new Array();
			
			
			colorDomains = new Object;
			colorScales = new Object;
			
			
			var y_circles = new Object;			
			
			
			
			y_circles["Total"] = new Array();
			
			for (var i=fd_num; i<=ld_num; i++)
			{
				var cur_id = heatmap_data.length;
				var cur_cn = total[i-fd_num];
				
				heatmap_data[cur_id] = new Object;
				heatmap_data[cur_id].dim = String(i);
				heatmap_data[cur_id].gene = "Total";
				heatmap_data[cur_id].circles = cur_cn;
				
				y_circles["Total"][i-fd_num] = cur_cn;
			}
			
			colorDomains["Total"] = d3.extent(y_circles["Total"], function(d){return d;});
			colorScales["Total"] = d3.scaleLinear()
				.domain(colorDomains["Total"])
				.range(["lightblue", "blue"]);
			
		
			

			
			for (var i=0; i<cur_markers.length; i++)
			{
				y_circles[cur_markers[i]] = new Array();
				
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_id2 = heatmap_data.length;
					
					var cur_area = areas[cur_markers[i]][j-fd_num];
					
					heatmap_data[cur_id2] = new Object;
					heatmap_data[cur_id2].dim = String(j);
					heatmap_data[cur_id2].gene = cur_markers[i];
					heatmap_data[cur_id2].circles = cur_area;
					
					
					y_circles[cur_markers[i]][j-fd_num] = cur_area;
					
					
				}
				
				colorDomains[cur_markers[i]] = d3.extent(y_circles[cur_markers[i]], function(d){return d;});
				colorScales[cur_markers[i]] = d3.scaleLinear()
					.domain(colorDomains[cur_markers[i]])
					.range(["lightblue", "blue"]);
			
			}
			
			
			for (var i=0; i<cur_groups.length; i++)
			{
				y_circles[cur_groups[i]] = new Array();
				
				for (var j=fd_num; j<=ld_num; j++)
				{
					var cur_id3 = heatmap_data.length;
					
					var cur_area = areas[cur_groups[i]][j-fd_num];
					
					heatmap_data[cur_id3] = new Object;
					heatmap_data[cur_id3].dim = String(j);
					heatmap_data[cur_id3].gene = cur_groups[i];
					heatmap_data[cur_id3].circles = cur_area;
					
					y_circles[cur_groups[i]][j-fd_num] = cur_area;
				}
				
				colorDomains[cur_groups[i]] = d3.extent(y_circles[cur_groups[i]], function(d){return d;});
				colorScales[cur_groups[i]] = d3.scaleLinear()
					.domain(colorDomains[cur_groups[i]])
					.range(["lightblue", "blue"]);
			}
			
			
		
			console.log("all_genes_done finish");
			
			draw_heatmap();
			
			
		

		}
		
		
		$(document).ready(function(){
			$("#add_total_button").click(function(){
				
				if (rds_exist)
				{
					var added_total_markers = document.getElementById("added_markers").value; 
					var atml = added_total_markers.split(" ");
					  
					  
					var si = atml.indexOf("");
					while (si!=-1)
					{
						atml.splice(si, 1);
						si = atml.indexOf("");
					}
					
					atml = Array.from(new Set(atml));
					
					
					var valid_markers = new Array();
					
					for (var i=0; i<atml.length; i++)
					{
						if (markers.indexOf(atml[i]) != -1)
						{
							valid_markers[valid_markers.length] = atml[i];
							
							var ti = total_markers.indexOf(atml[i]);
							
							if (ti==-1)
								total_markers[total_markers.length] = atml[i];
						
						}
					}
					
					if (valid_markers.length > 0)
					{
						all_genes_done();
					}
					
					else
					{
						alert("Please enter correct markers.");
					}
					
					
					
					
					
				}
				
				else
				{
					alert("Please add marekrs first.");
				}
			});
		});
		
		
		
		$(document).ready(function(){
			$("#remove_total_button").click(function(){
				
				if (rds_exist)
				{
					var removed_total_markers = document.getElementById("added_markers").value; 
					var rtml = removed_total_markers.split(" ");
					  
					  
					var si = rtml.indexOf("");
					while (si!=-1)
					{
						rtml.splice(si, 1);
						si = rtml.indexOf("");
					}
					
					rtml = Array.from(new Set(rtml));
					
					
					var r_count = 0;
					
					for (var i=0; i<rtml.length; i++)
					{
						
						var ri = total_markers.indexOf(rtml[i]);
						
						if ( ri != -1)
						{
							
							
							total_markers.splice(ri, 1);
							
							r_count++;
						
						}
					}
					
					if (r_count > 0)
					{
						all_genes_done();
					}
					
					else
					{
						alert("Please enter correct markers.");
					}
					
					
					
					
					
				}
				
				else
				{
					alert("Please add marekrs first.");
				}
			});
		});
		
		
		
		

		$(document).ready(function(){
			$("#remove_groups_button").click(function(){
				
				
				if (rds_exist)
				{
				
					var removed_groups = document.getElementById("added_markers").value; 
					var removed_groups_list = removed_groups.split(" ");
				  
				  
					var si = removed_groups_list.indexOf("");
					while (si!=-1)
					{
						removed_groups_list.splice(si, 1);
						si = removed_groups_list.indexOf("");
					}
					

					removed_groups_list = Array.from(new Set(removed_groups_list));
					
					
                    rem = new Array();
                    
                    for (var i=0; i<removed_groups_list.length; i++)
                    {
                        var cur_group_name = removed_groups_list[i];
                        
                        if (cur_group_name.indexOf("_") != -1)
                        {
                            var ci = cur_groups.indexOf(cur_group_name);
                            
                            if (ci!=-1)
                            {
                                cur_groups.splice(ci, 1);
                                
                                var oi = markers_on.indexOf(cur_group_name);
                                if (oi!=-1)
                                {
                                    markers_on.splice(oi, 1);
                                    
                                    // 201201 remove_groups
                                
                                    
                                    rem[rem.length] = cur_group_name;
                                    
                                    // draw_markers_plots();
                                }
   				
                            }
                        }
                    }
                    
                    y_length = 1 + cur_groups.length + cur_markers.length;
                        
                    var cur_height = y_length*unit_height;
                    var half_height = height/2;
                    
                    if (cur_height > half_height)
                    {
                        rec_height = half_height/y_length;
                    }
                    else
                        rec_height = unit_height;
                    
                    
                    
                    hc_scale_y = d3.scaleLinear()
                            .domain([-dom, dom])
                            .range([0, rec_height]);
                    
                    draw_markers_plots();

                    all_genes_done();	
                    
                    
					// var valid_markers = new Array();
					
					// for (var i=0; i<removed_groups_list.length; i++)
					// {
						// if (groups_markers.indexOf(removed_groups_list[i])!=-1)
						// {
							// valid_markers[valid_markers.length] = removed_groups_list[i];
						// }
					// }
					
					
					
					// group_name = valid_markers[0];
					// for (var i=1; i<valid_markers.length; i++)
					// {
						// group_name = group_name + "_" + valid_markers[i];
					// }
					
					
					
					
					
					
					// var ci = cur_groups.indexOf(group_name);
					// if (ci!=-1)
					// {
						// cur_groups.splice(ci, 1);
						
						// var oi = markers_on.indexOf(group_name);
						// if (oi!=-1)
						// {
							// markers_on.splice(oi, 1);
							
							
						
							// rem = new Array();
							// rem[0] = group_name;
							
							// draw_markers_plots();
						// }

						// y_length = 1 + cur_groups.length + cur_markers.length;
				
						// var cur_height = y_length*unit_height;
						// var half_height = height/2;
						
						// if (cur_height > half_height)
						// {
							// rec_height = half_height/y_length;
						// }
						// else
							// rec_height = unit_height;
						
						
						
						// hc_scale_y = d3.scaleLinear()
								// .domain([-dom, dom])
								// .range([0, rec_height]);
								
								
				
						// draw_markers_plots();

						// all_genes_done();					
					// }
				}
				
				
			
				else
				{
					alert("Please add markers first.");
				}
			});
		});
		 
		 
		 
		 
		



		



		 $(document).ready(function(){
			$("#add_groups_button").click(function(){

				
				if (rds_exist)
				{
					
					// alert("Start processing. Please wait.");
				
					console.log("Add group strart");
					
					d3.select('body')
					.append('div')
					.attr('class', 'loader')
					.style('position', 'absolute')
					.style('left', width/2 + 'px')		
					
					.style('top', $(document).scrollTop() + height/2 + 'px')
			

					console.log("Add group end");
			
					var run_time = new Date().getTime();
			
					
					
					
					added_groups = document.getElementById("added_markers").value;
          
					added_groups_list = added_groups.split(" ");
				  
				  
					var si = added_groups_list.indexOf("");
					while (si!=-1)
					{
						added_groups_list.splice(si, 1);
						si = added_groups_list.indexOf("");
					}
					
					added_groups_list = Array.from(new Set(added_groups_list));
                    
                    
                    
                   
                    
                    for (var i=0; i<added_groups_list.length; i++)
                    {
                        var cur_group_name = added_groups_list[i];
                        
                        if (cur_group_name.indexOf("_") != -1)
                        {
                           
                            
                            var cur_group_markers = cur_group_name.split("_");
                            
                            var valid_marker_check = 0;
                            
                            for (var j=0; j<cur_group_markers.length; j++)
                            {
                                if (markers.indexOf(cur_group_markers[j])!=-1)
                                {
                                    valid_marker_check++;
                                }
                            }
                            
                            if (valid_marker_check == cur_group_markers.length)
                            {
                                if (groups.indexOf(cur_group_name) == -1 )
                                {

                                    new_groups[new_groups.length] = cur_group_name;
                                    
                                   
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                    
                                    groups[groups.length] = cur_group_name;
                                    
                                    for (var j=0; j<cur_group_markers.length; j++)
                                    {
                                        groups_markers[groups_markers.length] = cur_group_markers[j];
                                    }
                                }
                                
                                else if (cur_groups.indexOf(cur_group_name) == -1)
                                {
                                    old_groups[old_groups.length] = cur_group_name;
                                    
                                    cur_groups[cur_groups.length] = cur_group_name;
                                }
       
                                
                            }
                        }
                    }
                    
		
				
					if (new_groups.length>0 || old_groups.length>0)
					{								
						y_length = 1 + cur_groups.length + cur_markers.length;
						
						
						var cur_height = y_length*unit_height;
						var half_height = height/2;
						
						if (cur_height > half_height)
						{
							rec_height = half_height/y_length;
						}
						else
							rec_height = unit_height;
						
						
						
						hc_scale_y = d3.scaleLinear()
								.domain([-dom, dom])
								.range([0, rec_height]);
								
								
						
						
						
		
						if (new_groups.length>0)
						{			
							
                            calculate_groups();
							
							
						}
						
						else
						{
							all_genes_done();
						}
					}
					else
					{
						alert ("Please enter correct markers in the correct form (markerA_markerB markerC_markerD_markerE).")
						
						d3.select('.loader').remove();
					}
				}
				
				
				
				else
				{
					alert("Please add markers first.");
				}
				 
			}); 
		});



		 $(document).ready(function(){
			$("#remove_button").click(function(){
				
				if (rds_exist)
				{
				
					var removed_markers = document.getElementById("added_markers").value; 
					var removed_markers_list = removed_markers.split(" ");
				  
				  
					var si = removed_markers_list.indexOf("");
					while (si!=-1)
					{
						removed_markers_list.splice(si, 1);
						si = removed_markers_list.indexOf("");
					}
					
					removed_markers_list = Array.from(new Set(removed_markers_list));
					
					
					
					var rmc = 0;
					rem = new Array();
					
					for (var i=0; i<removed_markers_list.length; i++)
					{
						
						
						var ci = cur_markers.indexOf(removed_markers_list[i]);
						if (ci!=-1)
						{
							cur_markers.splice(ci, 1);
							
							var oi = markers_on.indexOf(removed_markers_list[i]);
							if (oi!=-1)
							{
								markers_on.splice(oi, 1);
								
								rmc++;
								
								rem[rem.length] = removed_markers_list[i];
							}
							
							
							
							
						}
						
						
						
					}
					
					
					y_length = 1 + cur_groups.length + cur_markers.length;
				
					var cur_height = y_length*unit_height;
					var half_height = height/2;
					
					if (cur_height > half_height)
					{
						rec_height = half_height/y_length;
					}
					else
						rec_height = unit_height;
					
					
					
					hc_scale_y = d3.scaleLinear()
							.domain([-dom, dom])
							.range([0, rec_height]);
							
					
			
					console.log("remove_button - rem");
					console.log(rem);
				
					draw_markers_plots();
							
					all_genes_done();
				}
				
				
				else
				{
					alert("Please add markers first.");
				}
				
			});
		 });





		$(document).ready(function(){
			$("#add_button").click(function(){

				if (first_add)
				{
				
					
					
					
					rds_name = d3.select('#rds')["_groups"][0][0].value;
					rds_name_only = rds_name.replace('.rds', '')
					
					
					
					var rds_path = "../rscripts/" + rds_name;
					
					
					$.ajax({
						async: false,
						type: "POST",
						url: "../rscripts/rds_check.r",					
						data: rds_name,					 
						contentType: "application/json" ,

						success: function(response){
						

							if (response=="true")
							{
								rds_exist = true;
							}
							else
							{
								alert("The file you entered does not exist in the server.");
							}
						}
					});
					
					
					if ((document.getElementById("fd").value != "") && (document.getElementById("ld").value != ""))
					{
						rds_exist = true;
					}
					
					else
					{
						rds_exist = false;
					}
		
				}
				
				
				if (rds_exist)
				{
				
				
					d3.select('body')
						.append('div')
						.attr('class', 'loader')
						.style('position', 'absolute')
						.style('left', width/2 + 'px')
						
						.style('top', $(document).scrollTop() + height/2 + 'px')
						
			
					var run_time = new Date().getTime();
			
					
					if (first_add)
					{					
						d3.select("#card_heatmap").style("display", "block");	
                        d3.select("#card_cluster_plot").style("display", "block");	
						d3.select("#card_meps").style("display", "block");	
						d3.select("#card_plot_size").style("display", "block");	
						d3.select("#card_animation").style("display", "block");	
						
						
						state = 0;
						
						n_dims = Number(document.getElementById("ld").value) - Number(document.getElementById("fd").value) + 1;
						
						markers = new Array();
						cur_markers = new Array();
						
						groups = new Array();
						
						cur_groups = new Array();
					
						
						markers_on = new Array();
						
						selected_dim = "empty";
						
						
						
						
						
						expressions = new Object;
						circles = new Object;
						
						
						ndots = 100;
						
						
						
					
						
						svg_width = smaller/4;
						
						dom = 60; //50
							
						
							
							
						point_color = [0, 0, 255];
						base_color = [226, 226, 226];
						
						dr_y = 25;
						
						mpn = 0;
						
						selected = new Array();
						
						max_ep = 9;
						
						dim_id = -1;
						
						groups_markers = new Array();
						
						
                        new_groups = new Array();
                        old_groups = new Array();
						
						group_name = "";
						
					
						
						eps = 2.0; // good for cell filtering of TRDC_TRGC2
						
				
						
						minPts = 0.04; // good for cell filtering of TRDC_TRGC2
						
						groups_params = new Object;
						
						heatmap_circles = new Object;
						

						heatmap_circles_x = new Object;
						
						
						ortho_size = 60;
						
						
						
						margin_size = font_size*2;
						hct = smaller * 0.001;
					
						heatmap_margin = {top: margin_size, right: margin_size, bottom: margin_size, left: margin_size*7};
						
						outer_width = d3.select('.outer')["_groups"][0][0].getBoundingClientRect().width;
						
						heatmap_width = outer_width - heatmap_margin.left - heatmap_margin.right;
						
						
						//////////////////////////////////////////////////////////
						
						unit_height = height * 0.05;
						rec_height = unit_height;
						
						if ((unit_height * n_dims) > heatmap_width)
						{
							rec_width = heatmap_width / n_dims;
						}
						else
						{
							rec_width = unit_height;
							heatmap_width = rec_width * n_dims;
						}
						
			

						hc_scale_x = d3.scaleLinear()
								.domain([-dom, dom])
								.range([0, rec_width]);
								
						hc_scale_y = d3.scaleLinear()
								.domain([-dom, dom])
								.range([0, rec_height]);
						
						
						////////////////////////////////////////////////////////
						
						
						
						clustering_width = d3.select('#clustering')["_groups"][0][0].getBoundingClientRect().width;
							
						legend_size = width*0.015;	

						
						if (clustering_width > width*0.5)
						{
							plot_size = smaller*0.5;
							clustering_width = plot_size + legend_size;
						}
						else						
							plot_size = clustering_width - legend_size;
						
						
						ep_size = plot_size*(Number(d3.select('#plot_size_slider')['_groups'][0][0].value)/5.0);
						ep_cell_size = ep_size*0.002;
						
						cell_size = smaller * 0.001;
						
						x = d3.scaleLinear()
							.domain([-dom, dom])
							.range([0, plot_size]);
							
						x2 = d3.scaleLinear()
						.domain([-dom, dom])
						
						.range([0, ep_size]);
						
						x4 = d3.scaleLinear()
						.domain([-dom, dom])
						.range([0, plot_size/2]);
						
					
						
						
						lasso_gene = "";
						
						
						deg_others = new Object;
						
						
						am = new Array();
						rem = new Array();
						dcm = new Array();
						ccm = new Array();
						rsm = new Array();
						
					
						
						ex_colors = new Object;
						
						lasso_temp = new Array();
						
					
						develop = "";
						
						num_bins = 19;
						
						// hist_margin = {top: 10, right: 10, bottom: margin_size, left: margin_size};
                        hist_margin = {top: 10, right: 10, bottom: margin_size, left: margin_size*1.5};
						
						
						areas = new Object;
						
						heatmap_groups = new Object;
								
						heatmap_genes = new Object;
						
						genes_stride = 1;
						
						
						
						cell_ids = new Object;
						filtered_ids = new Object;
						
						fd_num = Number(document.getElementById("fd").value);
						ld_num = Number(document.getElementById("ld").value);
						
						total_markers = new Array();
						
						ex_maxs = new Object;
                        ex_mins = new Object;
						
						
						filtering_on = false;
						density_on = false;
						
						
						markers_ani = new Array();
						cur_marker_ani = "";
						new_marker_ani = "";
						old_marker_ani = "";
						
						sorted_final_selected = new Array();
						final_selected = new Array();
						selected = new Array();
						
						hulls = new Object;
						lines = new Object;
						
						line = d3.line().curve(d3.curveLinearClosed);
						
						intersect_tf = true;
						
						sorted_indices = new Object;
						reverse_sorted_indices = new Object;
						
						smallest_dim = new Object;
						
						
						selected_cp = new Array();
						lasso_cp = new Array();
						
						cp_window_tf = false;
                        
                        density_th = 0.3;
						
						
						
			
						d3.select("#vsb")
							.append("text")
							.attr("id", "stop_plot_size_change")
							.attr("text-anchor", "middle")
							.style("font-size", font_size_str)
							.style("display", "none")
							.text("Please turn off cell filtering mode to change plot size.");
							
						
						
                        // legend_height_offset = -30;
					}
					
                    
                    // 201201
					
					
					added_markers = document.getElementById("added_markers").value; 
					added_markers_list = added_markers.split(" ");
				  
				  
					var si = added_markers_list.indexOf("");
					while (si!=-1)
					{
						added_markers_list.splice(si, 1);
						si = added_markers_list.indexOf("");
					}
					
					added_markers_list = Array.from(new Set(added_markers_list));
					
					
					for (var i=(added_markers_list.length-1); i>=0; i--)
                    {                      
                        if (added_markers_list[i].indexOf("_") != -1)
                        {
                            added_markers_list.splice(i, 1); 
                        }
                    }
					
					
					if (added_markers_list.length > 0)
						add_degs();
					
					else
					{
						alert("Please enter markers.");
						
						d3.select('.loader').remove();
					}
				
				}

				
			}); 
		}); 

			

			





		document.getElementById("add").onclick = function() {
		  
			
			
			if (rds_exist)
			{	
			
			
				if (first_ani)
				{
					
					
					
					
					
					
					
					
					cur_dim = 0;
					interval = 2000.0;
					ratio = interval;

					var name_size = 20;
					selected_genes = [];    
					cur_circles_num = 0;
					
					first_pause = true;           
					slider_change = false;
					
					pdi = 0;
					
					var dpn = 3;
					max_iter = 5;
					cpn = 3;
					
					
					max_markers = 1;
					
					max_ncircles = 1;
					
					
					nrow = dimensions.length;
					
					start_dim = fd_num;
					ncol = n_dims*2;
					
					
					
					
					animations = new Object;
					
					
					marker_tex_data = new Array();
					
					
					mae = 0;
					
					
				
					ncircles = new Object;
					nci_array = new Object;
					total_ncircles = new Object;
					
					
					
					
					
					
					////////////////////////////////////////////////////////////////////////////////
					
					
					
					
					var particles = nrow;

																
					var positions = new Float32Array(nrow*3 + ndots*max_ncircles*max_markers*3);
					
					

					
				   
					for(var i = 0; i < nrow*3; i+=3) {
						positions[i] = Number(dimensions[i/3][1]);
						positions[i+1] = Number(dimensions[i/3][2]);
						positions[i+2] = 0;

					}
					
					var cur_particles = nrow;
					

					for (var i=0; i<max_ncircles*ndots*max_markers; i++)
					{
						positions[nrow*3 + i*3] = 0.0; 
						positions[nrow*3 + i*3+1] = 0.0; 
						positions[nrow*3 + i*3+2] = 0.0;  
					}
					
					cur_particles = nrow + max_ncircles*ndots*max_markers;
				   

					
					tw = n_dims*2;
					th = Math.ceil(nrow/4);
					
					

					
					tex_data = new Array();
					
					var index = 0;
					for (var i = 0; i < nrow; i++)
					{
						for (var j = 1; j < ncol+1; j++)
						{
							tex_data[index] = Number(dimensions[i][j]);
							
							index++;
						}
						
						
					}
					
					
					if (nrow%4!=0)
					{
						for (var k=0; k<(th*4-nrow); k++)
						{
						
							for (var j=0; j<n_dims*2; j++)
							{
								tex_data[index] = 0.0;
							
								
							
							
								index++;
							}
						}
					}
					
				   
			
					
					dataTex = new THREE.DataTexture(new Float32Array(tex_data), tw, th, THREE.RGBAGormat, THREE.FloatType);
					dataTex.minFilter = THREE.NearestFilter;
					dataTex.magFilter = THREE.NearestFilter;
					dataTex.needsUpdate = true;
					
					
					
				   
					

					uniforms = 
					{
						color: {
						  type: 'c',

						  value: new THREE.Color(0xFFFFFF)
						},
						alpha: { type: 'f', value: 1 },

						
					  
						vertices: { type: 't', value: dataTex },

						
						marker: {type: 't', value: 0},
						expression: {type: 't', value: 0},
						
						
						e_max: {type: 'f', value: 0},
                        e_min: {type: 'f', value: 0},
						ew: {type: 'i', value: 0},
						eh: {type: 'i', value: 0},
						mae: {type: 'i', value: mae},
						

						tw: { type: 'i', value: tw},
						th: { type: 'i', value: th},
						ratio: { type: 'f', value: ratio},
						interval: { type: 'f', value: interval},
						cur_dim: { type: 'i', value: cur_dim},
						n_dims: { type: 'i', value: n_dims},
						nrow: { type: 'i', value: nrow},
					
						ndots: { type: 'i', value: ndots},

						
						mw: { type: 'i', value: 0},
						mh: { type: 'i', value: 0},
					
						nc: { type: 'v3', value:  new THREE.Vector3( 0, 0, 0 )},
						nci: { type: 'v3', value:  new THREE.Vector3( 0, 0, 0 )},
						nc3: { type: 'v3', value:  new THREE.Vector3( 0, 0, 0 )},
						nci3: { type: 'v3', value:  new THREE.Vector3( 0, 0, 0 )},
						
						
						cell_size: { type: 'f', value: cell_size},
						
						max_ncircles: {type: 'i', value: max_ncircles},
						total_ncircles: {type: 'v3', value: new THREE.Vector3( 0, 0, 0 )}
						
						
						
					};

					
					var sizes = new Float32Array(cur_particles)
					for(var i = 0; i < cur_particles; i++) sizes[i] = cell_size;

					
					var indices = new Float32Array(cur_particles)
					for(var i = 0; i < cur_particles; i++) indices[i] = i;
					
					var attributes = {
					  size: { type: 'f', value: [] },
					  id: { type: 'f', value: [] }
					}
					
					

					


					var cloudMat = new THREE.ShaderMaterial({
						uniforms:       uniforms,
						attributes:     attributes,
						vertexShader:   d3.select('#vertexshader').node().textContent,
						fragmentShader: d3.select('#fragmentshader').node().textContent,
						transparent:    true,
						setDepthTest: false,

					})

					

					
					var cloudGeom = new THREE.BufferGeometry()
					
					var posBuff = new THREE.BufferAttribute(positions, 3)
					
				  
					
					
				  
				  
					cloudGeom.addAttribute('position', posBuff)
					cloudGeom.addAttribute('size', new THREE.BufferAttribute(sizes, 1))
					
					
					cloudGeom.addAttribute('id', new THREE.BufferAttribute(indices, 1))
					
					
					cloudGeom.computeBoundingSphere()

					

					
					var pointCloud = new THREE.PointCloud(cloudGeom, cloudMat)
					
					
					
					
					
					scene = new THREE.Scene()
					camera = new THREE.OrthographicCamera(-dom, dom, dom, -dom, 1, 10000)
					scene.add(camera)
					camera.position.z = 1000
					
					scene.add(pointCloud)


				   

					
					var canvas = document.getElementById("canvasID");
					
					renderer = new THREE.WebGLRenderer({alpha: true, canvas: canvas})

				  
					
					
					
					renderer.setSize(plot_size, plot_size);
			
					renderer.setClearColor(0x000000);
					

					document.getElementById('animation').appendChild( renderer.domElement );
					
					
					
					
					
					
					
					///////////////////////////////////////////////////////////////////////////////////////////////////
					
					
					
					
					var maxDuration = (n_dims-1)*interval+10;

					// d3.timer wrapped in an observable
					const timer$ = Rx.Observable.create((observer) => {
						
						
						// On subscribe, create a new timer
						const t = d3.timer(elapsed => {
							// Pass the elapsed time from the timer
							observer.next(elapsed);
						});
						// Stop the timer when unsubscribed
						return t.stop;
					});

					// Create click events for the play, pause, stop, and speed buttons
					const play$ = Rx.Observable.fromEvent(document.querySelector("#play"), "click");
					const pause$ = Rx.Observable.fromEvent(document.querySelector("#pause"), "click");
					const stop$ = Rx.Observable.fromEvent(document.querySelector("#stop"), "click");
					
					const observer = event => {
						
						pause_status = true;

					  
					 
					  
					  
				   

					};
					pause$.subscribe(observer);
				  

					// Map to speed 1x button to the value 1 on click
					const speed1x$ = Rx.Observable.fromEvent(document.querySelector("#speed1x"), "click")
						.mapTo(1);

					// Map the speed 2x button to the value 2 on click
					const speed2x$ = Rx.Observable.fromEvent(document.querySelector("#speed2x"), "click")
						.mapTo(2);

					// Create the change event for the slider for when a person clicks on the timer. 
					// Map it to the new value of the slider and convert that to a position on our timeline
					// var slider = document.querySelector("input");
					var slider = document.querySelector("#slider");
					var sliderChange$ = Rx.Observable.fromEvent(slider, "change")
						.map(evt=>evt.target.value / 100 * maxDuration);
						
					const observer2 = event => {
					  

					  
					  slider_change = true;
					  
					};
					sliderChange$.subscribe(observer2);    
						

					const speed$ = speed1x$
						.merge(speed2x$)
						.startWith(1);

					// An observable of new times to jump to based on either stopping or clicking the timer range
					const scrub$ = stop$.mapTo(0)
						.merge(sliderChange$);

					// Whenever someone presses play, create a new timer and calculate the intervals between each elapsed time
					const interval$ = play$.switchMap(() => 
						timer$
							.startWith(0) // start with 0
							.pairwise() // emit the last 2 values at a time in an array
							.map(([a, b]) => b - a) // calculate the difference between the last two values
							.combineLatest(speed$, (interval, speed) => interval * speed) // multiply the interval by the current speed
							.takeUntil(pause$.merge(stop$)) // emit these timer intervals until a pause or stop event
					);

					// Use the interval stream with the scrub stream to either add time or jump in time
					const time$ = interval$
						.map(m => (v) => v + m) // When interval stream fires, pass a function that takes previous value and adds latest interval
						.merge(scrub$.map(m => (v) => m)) // When the scrub stream fires, jump to the new value
						.startWith(0) // start the time at 0
						.scan((val, fn) => fn(val)) // for each value, apply the latest function that fired (either increment or jump)
						.filter(t=> t <= maxDuration); // only take times within our max duration range

					// Subscribe: Print the time and update the slider position
					time$.subscribe(t=>{
						//document.querySelector("#time").innerHTML = t
						slider.value = t / maxDuration * 100;
						
						
						pause_status = false;
						
						cur_dim = parseInt(t/interval);
						ratio = interval - parseInt(t)%parseInt(interval);
						
						
						
						
						document.querySelector("#time").innerHTML = "Current dimensionality: " + (start_dim+cur_dim);
				 

						

						uniforms[ "ratio" ].value = ratio;			
						uniforms[ "cur_dim" ].value = cur_dim;
			
					
						
				 
						
						if ((cur_dim<(n_dims-1)) && !first_ani )
						{

							renderer.render(scene, camera);				
						}

					});
					
					
					svg_ani = d3.select('body')
						.append('svg')
						.style('display', 'none');
						
					path_ani = svg_ani.append('path');
					
					
					first_ani = false;
				}
				
				
				
				
				if (cur_marker_ani.length==max_markers)
				{
					// alert("The maximum number of markers is 4.");
					alert("You can add only one marker.");
				}
				
				else
				{
					added_markers_ani = document.getElementById("marker").value; 
					var ama_list = added_markers_ani.split(" ");
						  
						  
					var si = ama_list.indexOf("");
					while (si!=-1)
					{
						ama_list.splice(si, 1);
						si = ama_list.indexOf("");
					}
					
					ama_list = Array.from(new Set(ama_list));
					
					
					var ai_arr = new Array();
				
					for (var i=0; i<ama_list.length; i++)
					{				
						if ((markers.indexOf(ama_list[i]) == -1) && (groups.indexOf(ama_list[i]) == -1))
						{
							ai_arr[ai_arr.length] = ama_list[i];
							
							
						}
					}
					
					for (var i=0; i<ai_arr.length; i++)
					{
						
						ama_list.splice(ama_list.indexOf(ai_arr[i]), 1);
					}
					
					
					
					
					
					for (var i=0; i<ama_list.length; i++)
					{
						if (markers_ani.indexOf(ama_list[i]) == -1 )
						{
							
							new_marker_ani = ama_list[i];
							cur_marker_ani = ama_list[i];
							markers_ani[markers_ani.length] = ama_list[i];
							
						
							break;
						}
						
						else if (cur_marker_ani != ama_list[i])
						{
							old_marker_ani = ama_list[i];
							cur_marker_ani = ama_list[i];
							
						
							break;
						}
					}
				 

											
					pause_status = true;



					if (cur_marker_ani != "")
					{
						mae = 1;
						
						uniforms["mae"].value = mae;
						
						calculate_animation();
					}
					
					else
					{
						alert("Please enter a correct marker or group.");
					}
					
				}
			}
			
			
			
			else
			{
				alert("Please add a marker or group first.");
			}
		}



		document.getElementById("remove").onclick = function() {
			
			if (rds_exist)
			{	
				var removed_markers_ani = document.getElementById("marker").value; 
				rma_list = removed_markers_ani.split(" ");
					  
					  
				var ri = rma_list.indexOf("");
				while (ri!=-1)
				{
					rma_list.splice(ri, 1);
					ri = rma_list.indexOf("");
				}
				
				
				rma_list = Array.from(new Set(rma_list));
				
				
				
				var removed_marker = "";
				
				
				var ci = rma_list.indexOf(cur_marker_ani);
				
				if (ci!= -1)
					removed_marker = cur_marker_ani;
					
			
				

				if (removed_marker == "")
				{
					alert("There is no such marker.");
				}
				
			
				else
				{
					
					cur_marker_ani = "";
					
					
					
					mae = 0;
						
					uniforms["mae"].value = mae;
					
			
					if (cur_dim<(n_dims-1))
						renderer.render(scene, camera);
					
				
					
					document.querySelector("#current_markers").innerHTML = "";
				}	  
			}
			
	
			else
			{
				alert("Please add markers first.");
			}
		}
			 
		</script>
    </body>
</html>
